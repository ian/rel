directive @unique on FIELD_DEFINITION

directive @relation(type: String!, direction: RelDirection!) on FIELD_DEFINITION

directive @transient on FIELD_DEFINITION

directive @default(value: String!) on FIELD_DEFINITION

directive @computed(value: String!) on FIELD_DEFINITION

directive @constraint(minLength: Int, maxLength: Int, startsWith: String, endsWith: String, contains: String, notContains: String, pattern: String, format: String, min: Float, max: Float, exclusiveMin: Float, exclusiveMax: Float, multipleOf: Float) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

input BooleanInput {
  ne: Boolean
  eq: Boolean
}

input CreateNoteInput {
  body: String!
  archived: Boolean
}

input CreateUserInput {
  name: String!
  email: String
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID!]
}

input IntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int!]
  between: [Int!]
}

input MutateNoteInput {
  body: String
  archived: Boolean
  _id: ID
}

input MutateUserInput {
  name: String
  email: String
  _id: ID
}

type Mutation {
  createNote(input: CreateNoteInput!): Note
  updateNote(input: MutateNoteInput!): Note
  updateNotes(filter: NoteFilter, input: MutateNoteInput!): NoteMutationResultList
  deleteNote(_id: ID!): Note
  deleteNotes(filter: NoteFilter): NoteMutationResultList
  createUser(input: CreateUserInput!): User
  updateUser(input: MutateUserInput!): User
  updateUsers(filter: UserFilter, input: MutateUserInput!): UserMutationResultList
  deleteUser(_id: ID!): User
  deleteUsers(filter: UserFilter): UserMutationResultList
}

type Note {
  body: String!
  archived: Boolean
  _id: ID
  count(of: OfNoteInput, distinct: Boolean): Int
  createdAt: Timestamp
  updatedAt: Timestamp
}

enum NoteFieldsEnum {
  _id
  body
  archived
  createdAt
  updatedAt
}

input NoteFilter {
  body: StringInput
  archived: BooleanInput
  _id: IDInput
  and: [NoteFilter!]
  or: [NoteFilter!]
  not: NoteFilter
  createdAt: TimestampInput
  updatedAt: TimestampInput
}

type NoteMutationResultList {
  items: [Note]!
}

input NoteOrderByInput {
  field: NoteFieldsEnum
  order: SortDirectionEnum = ASC
}

type NoteResultList {
  items: [Note]!
  offset: Int
  limit: Int
  count: Int
}

input NoteSubscriptionFilter {
  and: [NoteSubscriptionFilter!]
  or: [NoteSubscriptionFilter!]
  not: NoteSubscriptionFilter
  body: StringInput
  archived: BooleanInput
  _id: IDInput
  count: IntInput
}

input OfNoteInput {
  of: NoteFieldsEnum
}

input OfUserInput {
  of: UserFieldsEnum
}

input PageRequest {
  limit: Int
  offset: Int
}

type Query {
  getNote(_id: ID!): Note
  findNotes(filter: NoteFilter, page: PageRequest, orderBy: [NoteOrderByInput]): NoteResultList!
  getUser(_id: ID!): User
  findUsers(filter: UserFilter, page: PageRequest, orderBy: [UserOrderByInput]): UserResultList!
}

enum RelDirection {
  IN
  OUT
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newNote(filter: NoteSubscriptionFilter): Note!
  updatedNote(filter: NoteSubscriptionFilter): Note!
  deletedNote(filter: NoteSubscriptionFilter): Note!
  newUser(filter: UserSubscriptionFilter): User!
  updatedUser(filter: UserSubscriptionFilter): User!
  deletedUser(filter: UserSubscriptionFilter): User!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input TimestampInput {
  ne: Timestamp
  eq: Timestamp
  le: Timestamp
  lt: Timestamp
  ge: Timestamp
  gt: Timestamp
  in: [Timestamp!]
  between: [Timestamp!]
}

type User {
  name: String!
  email: String
  _id: ID
  count(of: OfUserInput, distinct: Boolean): Int
  createdAt: Timestamp
  updatedAt: Timestamp
}

enum UserFieldsEnum {
  _id
  name
  email
  createdAt
  updatedAt
}

input UserFilter {
  name: StringInput
  email: StringInput
  _id: IDInput
  and: [UserFilter!]
  or: [UserFilter!]
  not: UserFilter
  createdAt: TimestampInput
  updatedAt: TimestampInput
}

type UserMutationResultList {
  items: [User]!
}

input UserOrderByInput {
  field: UserFieldsEnum
  order: SortDirectionEnum = ASC
}

type UserResultList {
  items: [User]!
  offset: Int
  limit: Int
  count: Int
}

input UserSubscriptionFilter {
  and: [UserSubscriptionFilter!]
  or: [UserSubscriptionFilter!]
  not: UserSubscriptionFilter
  name: StringInput
  email: StringInput
  _id: IDInput
  count: IntInput
}
