{"version":3,"sources":["../../../node_modules/.pnpm/tsup@5.11.9_typescript@4.5.4/node_modules/tsup/assets/esm_shims.js","../../../node_modules/.pnpm/dataloader@2.0.0/node_modules/dataloader/index.js","../src/index.ts","../src/SchemaCRUDPlugin.ts","../src/writer/schemaFormatters.ts","../src/definitions/schemaDefinitions.ts","../src/definitions/copyWrappingType.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value,' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n\n    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n\n\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            return resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  };\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    return process.nextTick(fn);\n  });\n} : setImmediate || setTimeout; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    return dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    return failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;","export * from './SchemaCRUDPlugin'\nexport * from './definitions/schemaDefinitions'\n\n// Required for plugins\nexport { SchemaCRUDPlugin as Plugin } from './SchemaCRUDPlugin'\n","/* eslint-disable max-lines */\nimport { resolve, dirname, join } from 'path'\nimport { existsSync, mkdirSync, writeFileSync } from 'fs'\nimport DataLoader from 'dataloader'\nimport { SchemaComposer, NamedTypeComposer } from 'graphql-compose'\nimport { IResolvers, IObjectTypeResolver } from '@graphql-tools/utils'\nimport { GraphQLNonNull, GraphQLObjectType, GraphQLSchema, GraphQLInt, GraphQLFloat, isScalarType, isSpecifiedScalarType, GraphQLResolveInfo, isObjectType, GraphQLInputObjectType, GraphQLScalarType } from 'graphql'\nimport { Timestamp, getFieldName, printSchemaWithDirectives, getSubscriptionName, GraphbackCoreMetadata, GraphbackOperationType, GraphbackPlugin, ModelDefinition, addRelationshipFields, extendRelationshipFields, extendOneToManyFieldArguments, getInputTypeName, FieldRelationshipMetadata, GraphbackContext, getSelectedFieldsFromResolverInfo, isModelType, getPrimaryKey, graphbackScalarsTypes, FILTER_SUPPORTED_SCALARS, FindByArgs } from '@graphback/core'\nimport { gqlSchemaFormatter, jsSchemaFormatter, tsSchemaFormatter } from './writer/schemaFormatters'\nimport { buildOrderByInputType,buildFilterInputType, createModelListResultType, StringScalarInputType, BooleanScalarInputType, SortDirectionEnum, buildCreateMutationInputType, buildFindOneFieldMap, buildMutationInputType, OrderByInputType, buildSubscriptionFilterType, IDScalarInputType, PageRequest, createInputTypeForScalar, createVersionedFields, createVersionedInputFields, addCreateObjectInputType, addUpdateObjectInputType, getInputName, createMutationListResultType } from './definitions/schemaDefinitions'\n\n/**\n * Configuration for Schema generator CRUD plugin\n */\nexport interface SchemaCRUDPluginConfig {\n  /**\n   * RelativePath for the output files created by generator\n   * e.g. /path/to/schema/schema.graphql\n   */\n  outputPath?: string\n}\n\nexport const SCHEMA_CRUD_PLUGIN_NAME = 'SchemaCRUD'\n\n/**\n * Graphback CRUD operations plugin\n *\n * Plugins adds additional Queries, Mutations and Subscriptions into the Schema along\n * with required input types and scalars. Plugin can be used automatically define best\n * patterns for CRUD operations on top of GraphQL Schema\n * Plugin checkes all types annotated with model\n *\n * Used graphql metadata:\n *\n * - model: marks type to be processed by CRUD generator\n * - crud: controls what types of operations can be generated.\n * For example crud.update: false will disable updates for type\n */\nexport class SchemaCRUDPlugin extends GraphbackPlugin {\n  private readonly pluginConfig: SchemaCRUDPluginConfig\n\n  public constructor (pluginConfig?: SchemaCRUDPluginConfig) {\n    super()\n    this.pluginConfig = {\n      ...pluginConfig\n    }\n  }\n\n  public transformSchema (metadata: GraphbackCoreMetadata): GraphQLSchema {\n    const schema = metadata.getSchema()\n\n    const models = metadata.getModelDefinitions()\n    if (models.length === 0) {\n      this.logWarning('Provided schema has no models. Returning original schema without any changes.')\n\n      return schema\n    };\n\n    const schemaComposer = new SchemaComposer(schema)\n\n    this.createAggregationForModelFields(schemaComposer, models)\n    this.buildSchemaModelRelationships(schemaComposer, models)\n    this.buildSchemaForModels(schemaComposer, models)\n    this.addMetadataFields(schemaComposer, models)\n    \n    return schemaComposer.buildSchema()\n  }\n\n  /**\n   * Creates CRUD resolvers\n   *\n   * @param {GraphbackCoreMetadata} metadata - Core metatata containing all model information\n   */\n  public createResolvers (metadata: GraphbackCoreMetadata): IResolvers {\n    const models = metadata.getModelDefinitions()\n\n    if (models.length === 0) {\n      return undefined\n    }\n\n    const resolvers: IResolvers = {}\n\n    // Graphback scalar resolvers\n    const schema = metadata.getSchema()\n    for (const graphbackScalar of graphbackScalarsTypes) {\n      if (schema.getType(graphbackScalar.name)) {\n        resolvers[graphbackScalar.name] = graphbackScalar\n      }\n    }\n\n    const modelNameToModelDefinition = models\n      .reduce((acc: any, model: ModelDefinition) => {\n        return {\n          ...acc,\n          [model.graphqlType.name]: model\n        }\n      }, {})\n\n    for (const model of models) {\n      this.addQueryResolvers(model, resolvers)\n      this.addMutationResolvers(model, resolvers)\n      this.addSubscriptionResolvers(model, resolvers)\n      this.addRelationshipResolvers(model, resolvers, modelNameToModelDefinition)\n    }\n\n    return resolvers\n  }\n\n  public createResources (metadata: GraphbackCoreMetadata): void {\n    if (!this.pluginConfig.outputPath) {\n      return\n    }\n\n    let schemaPath = resolve(this.pluginConfig.outputPath)\n\n    // check if user path is to directory or full path to schema\n    // assign default file name otherwise\n    if (!schemaPath.includes('.')) {\n      schemaPath = join(schemaPath, 'schema.graphql')\n    }\n\n    // get file extension\n    const fileExtension = schemaPath.split('.').pop()\n\n    const schemaString = this.transformSchemaToString(metadata.getSchema(), fileExtension)\n\n    const outputDir = resolve(dirname(this.pluginConfig.outputPath))\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true })\n    }\n\n    writeFileSync(schemaPath, schemaString)\n  }\n\n  public getPluginName () {\n    return SCHEMA_CRUD_PLUGIN_NAME\n  }\n\n  protected buildSchemaForModels (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    this.createSchemaCRUDTypes(schemaComposer)\n\n    for (const model of Object.values(models)) {\n      const modelName = model.graphqlType.name\n      let modifiedType = schemaComposer.getOTC(modelName)\n      const errorMessage = (field: string) => `@model ${modelName} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if(model.fields.id) {\n        throw new Error(errorMessage(\"id\"))\n      }\n\n      if(model.fields.__unique) {\n        throw new Error(errorMessage(\"__unique\"))\n      }\n\n      modifiedType.addFields({\n        __id: {\n          type: \"ID\"\n        }\n      })\n      this.createQueries(model, schemaComposer)\n      this.createMutations(model, schemaComposer)\n      this.createSubscriptions(model, schemaComposer)\n      modifiedType = schemaComposer.getOTC(modelName)\n      extendOneToManyFieldArguments(model, modifiedType)\n    }\n  }\n\n  protected createSubscriptions (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n\n    buildSubscriptionFilterType(schemaComposer, modelType)\n\n    const subscriptionFields = {}\n    if (model.crudOptions.subCreate) {\n      const operation = getSubscriptionName(name, GraphbackOperationType.CREATE)\n\n      const filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n      const subCreateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n      subscriptionFields[operation] = {\n        type: GraphQLNonNull(modelType),\n        args: {\n          filter: {\n            type: subCreateFilterInputType\n          }\n        }\n      }\n    }\n    if (model.crudOptions.subUpdate) {\n      const operation = getSubscriptionName(name, GraphbackOperationType.UPDATE)\n\n      const filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_UPDATE)\n      const subUpdateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n      subscriptionFields[operation] = {\n        type: GraphQLNonNull(modelType),\n        args: {\n          filter: {\n            type: subUpdateFilterInputType\n          }\n        }\n      }\n    }\n    if (model.crudOptions.subDelete) {\n      const operation = getSubscriptionName(name, GraphbackOperationType.DELETE)\n\n      const filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_DELETE)\n      const subDeleteFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n      subscriptionFields[operation] = {\n        type: GraphQLNonNull(modelType),\n        args: {\n          filter: {\n            type: subDeleteFilterInputType\n          }\n        }\n      }\n    }\n\n    schemaComposer.Subscription.addFields(subscriptionFields)\n  }\n\n  protected createSchema (queryTypes: any, mutationTypes: any, subscriptionTypes: any) {\n    const queryType = new GraphQLObjectType({\n      name: 'Query',\n      fields: () => (queryTypes)\n    })\n\n    let mutationType\n    if (Object.keys(mutationTypes).length !== 0) {\n      mutationType = new GraphQLObjectType({\n        name: 'Mutation',\n        fields: () => (mutationTypes)\n      })\n    }\n\n    let subscriptionType\n    if (Object.keys(subscriptionTypes).length !== 0) {\n      subscriptionType = new GraphQLObjectType({\n        name: 'Subscription',\n        fields: () => (subscriptionTypes)\n      })\n    }\n\n    return new GraphQLSchema({\n      query: queryType,\n      mutation: mutationType,\n      subscription: subscriptionType\n    })\n  }\n\n  protected createMutations (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const resultListType = createMutationListResultType(modelType)\n    buildMutationInputType(schemaComposer, modelType)\n\n    const mutationFields = {}\n    if (model.crudOptions.create) {\n      const operationType = GraphbackOperationType.CREATE\n\n      buildCreateMutationInputType(schemaComposer, modelType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const createMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n      const operation = getFieldName(name, operationType)\n      mutationFields[operation] = {\n        type: modelType,\n        args: {\n          input: {\n            type: GraphQLNonNull(createMutationInputType)\n          }\n        }\n      }\n    }\n    if (model.crudOptions.update) {\n      const operationType = GraphbackOperationType.UPDATE\n      const operation = getFieldName(name, operationType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n      mutationFields[operation] = {\n        type: modelType,\n        args: {\n          input: {\n            type: GraphQLNonNull(updateMutationInputType)\n          }\n        }\n      }\n    }\n    if (model.crudOptions.updateBy) {\n      const operationType = GraphbackOperationType.UPDATE_BY\n      const operation = getFieldName(name, operationType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n      const filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n\n      mutationFields[operation] = {\n        type: resultListType,\n        args: {\n          filter: {\n            type: filterInputType\n          },\n          input: {\n            type: GraphQLNonNull(updateMutationInputType)\n          }\n        }\n      }\n    }\n    if (model.crudOptions.delete) {\n      const operationType = GraphbackOperationType.DELETE\n      const operation = getFieldName(name, operationType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const deleteMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n      mutationFields[operation] = {\n        type: modelType,\n        args: buildFindOneFieldMap(model, schemaComposer)\n      }\n    }\n    if (model.crudOptions.deleteBy) {\n      const operationType = GraphbackOperationType.DELETE_BY\n      const operation = getFieldName(name, operationType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const deleteMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n      const filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n      mutationFields[operation] = {\n        type: resultListType,\n        args: {\n          filter: {\n            type: filterInputType\n          }\n        }\n      }\n    }\n\n    schemaComposer.Mutation.addFields(mutationFields)\n  }\n\n  protected createQueries (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const aggFields = {}\n    const aggregations = ['avg', 'max', 'min', 'sum']\n    aggFields.count = {\n      type: 'Int',\n      args: {\n        of: {\n          type: `Of${name}Input`\n        },\n        distinct: {\n          type: \"Boolean\"\n        }\n      },\n      description: '@transient'\n    }\n    if(schemaComposer.has(`Of${name}NumberInput`)) {\n      aggregations.forEach(agg => {\n        aggFields[agg] = {\n          type: 'Int',\n          args: {\n            of: {\n              type: `Of${name}NumberInput`\n            },\n            distinct: {\n              type: \"Boolean\"\n            }\n          },\n          description: '@transient'\n        }\n      })\n    }\n    modelTC.addFields(aggFields)\n\n    buildFilterInputType(schemaComposer, modelType)\n\n    const queryFields = {}\n    if (model.crudOptions.findOne) {\n      const operation = getFieldName(name, GraphbackOperationType.FIND_ONE)\n      queryFields[operation] = {\n        type: model.graphqlType,\n        args: buildFindOneFieldMap(model, schemaComposer)\n      }\n    }\n    if (model.crudOptions.find) {\n      const operationType = GraphbackOperationType.FIND\n      const operation = getFieldName(name, operationType)\n\n      const inputTypeName = getInputTypeName(name, operationType)\n      const filterInputType = schemaComposer.getITC(inputTypeName).getType()\n      const resultListType = createModelListResultType(modelType)\n      queryFields[operation] = {\n        type: GraphQLNonNull(resultListType),\n        args: {\n          filter: {\n            type: filterInputType\n          },\n          page: {\n            type: PageRequest\n          },\n          orderBy: {\n            type: [buildOrderByInputType(name)]\n          }\n        }\n      }\n    }\n\n    schemaComposer.Query.addFields(queryFields)\n  }\n\n  protected createAggregationForModelFields (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    for (const model of models) {\n      const modelName = model.graphqlType.name\n      const enumName = `${modelName}FieldsEnum`\n      const numberEnumName = `${modelName}NumberFieldsEnum`\n      const fieldKeys = Object.keys(model.fields)\n      const fields = fieldKeys.filter(field => {\n        return !model.fields[field].transient\n      }).join(' ')\n      const numberTypes = [\"Int\", \"Float\",\"BigInt\", \"NonPositiveFloat\", \"NonPositiveInt\", \"NonNegativeInt\", \n      \"NonNegativeFloat\", \"NegativeFloat\", \"NegativeInt\", \"PositiveInt\", \"PositiveFloat\"]\n      const numberFields = fieldKeys.filter(field => {\n        return !model.fields[field].transient && numberTypes.includes(model.fields[field].type.replace(\"!\", \"\"))\n      }).join(' ')\n      schemaComposer.createEnumTC(`enum ${enumName} { ${fields} }`)\n      schemaComposer.createInputTC(`input Of${modelName}Input { of: ${enumName}}`)\n      if(numberFields !== '') {\n        schemaComposer.createEnumTC(`enum ${numberEnumName} { ${numberFields} }`)\n        schemaComposer.createInputTC(`input Of${modelName}NumberInput { of: ${numberEnumName}}`)\n      }\n    }\n  }\n\n  protected addMetadataFields (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    const timeStampInputName = getInputName(Timestamp)\n    let timestampInputType: GraphQLInputObjectType\n    let timestampType: GraphQLScalarType\n    for (const model of models) {\n      const name = model.graphqlType.name\n      const modelTC = schemaComposer.getOTC(name)\n      const updateField = model.fields.updatedAt\n      const createAtField = model.fields.createdAt\n      const errorMessage = (field: string) => `@model ${name} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if (createAtField && createAtField.type !== Timestamp.name) {\n        throw new Error(errorMessage(\"createdAt\"))\n      }\n\n      if (updateField && updateField.type !== Timestamp.name) {\n        throw new Error(errorMessage(\"updatedAt\"))\n      }\n\n      if (!timestampInputType) {\n        if (schemaComposer.has(Timestamp.name)) {\n          timestampInputType = schemaComposer.getITC(timeStampInputName).getType()\n        } else {\n          schemaComposer.createScalarTC(Timestamp)\n          timestampInputType = createInputTypeForScalar(Timestamp)\n          schemaComposer.add(timestampInputType)\n        }\n\n        timestampType = schemaComposer.getSTC(Timestamp.name).getType()\n      }\n\n      const metadataFields = createVersionedFields(timestampType)\n     \n      modelTC.addFields(metadataFields)\n\n      const inputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND))\n      if (inputType) {\n        const metadataInputFields = createVersionedInputFields(timestampInputType)\n        inputType.addFields(metadataInputFields)\n      }\n    };\n  }\n\n  /**\n   *\n   * Print schema as a string and format in one of the available languages\n   *\n   * @param {GraphQLSchema} schema\n   * @param {string} fileExtension\n   */\n  protected transformSchemaToString (schema: GraphQLSchema, fileExtension: string) {\n    const schemaString = printSchemaWithDirectives(schema)\n    if (this.pluginConfig) {\n      if (fileExtension === 'ts') {\n        return tsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'js') {\n        return jsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'graphql') {\n        return gqlSchemaFormatter.format(schemaString)\n      }\n    }\n    throw Error(`Invalid format '${fileExtension}' specified. \\`options.format\\` supports only \\`ts\\`, \\`js\\` and \\`graphql\\` flags`)\n  }\n\n  /**\n   * Create Query resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addQueryResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    if (model.crudOptions.findOne || model.crudOptions.find) {\n      resolvers.Query = (resolvers.Query || {}) as IObjectTypeResolver\n\n      if (model.crudOptions.findOne) {\n        this.addFindOneQueryResolver(model, resolvers.Query)\n      }\n      if (model.crudOptions.find) {\n        this.addFindQueryResolver(model, resolvers.Query)\n      }\n    }\n  }\n\n  /**\n   * Create Mutation resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addMutationResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    if (model.crudOptions.create || model.crudOptions.update || model.crudOptions.delete) {\n      resolvers.Mutation = (resolvers.Mutation || {}) as IObjectTypeResolver\n\n      if (model.crudOptions.create) {\n        this.addCreateMutationResolver(model, resolvers.Mutation)\n      }\n      if (model.crudOptions.update) {\n        this.addUpdateMutationResolver(model, resolvers.Mutation)\n      }\n      if (model.crudOptions.updateBy) {\n        this.addUpdateByMutationResolver(model, resolvers.Mutation)\n      }\n      if (model.crudOptions.delete) {\n        this.addDeleteMutationResolver(model, resolvers.Mutation)\n      }\n      if (model.crudOptions.deleteBy) {\n        this.addDeleteByMutationResolver(model, resolvers.Mutation)\n      }\n    }\n  }\n\n  /**\n   * Create Subscription resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addSubscriptionResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    const modelType = model.graphqlType\n\n    if (model.crudOptions.subCreate || model.crudOptions.subUpdate || model.crudOptions.subDelete) {\n      resolvers.Subscription = (resolvers.Subscription || {}) as IObjectTypeResolver\n\n      if (model.crudOptions.subCreate) {\n        this.addCreateSubscriptionResolver(modelType, resolvers.Subscription)\n      }\n      if (model.crudOptions.subUpdate) {\n        this.addUpdateSubscriptionResolver(modelType, resolvers.Subscription)\n      }\n      if (model.crudOptions.subDelete) {\n        this.addDeleteSubscriptionResolver(modelType, resolvers.Subscription)\n      }\n    }\n  }\n\n  /**\n   * Create relationship resolver fields\n   *\n   * @param {ModelDefinition} model - Model definition with relationship metadata\n   * @param {IResolvers} resolversObj - Resolvers object\n   * @param modelNameToModelDefinition - model type name to its definition for quick search\n   */\n  protected addRelationshipResolvers (model: ModelDefinition, resolversObj: IResolvers, modelNameToModelDefinition: any) {\n    const relationResolvers = {}\n    for (const relationship of model.relationships) {\n      if (relationship.kind === 'oneToMany') {\n        this.addOneToManyResolver(relationship, relationResolvers, modelNameToModelDefinition)\n      } else {\n        this.addOneToOneResolver(relationship, relationResolvers, modelNameToModelDefinition)\n      }\n    }\n\n    if (Object.keys(relationResolvers).length > 0) {\n      resolversObj[model.graphqlType.name] = relationResolvers\n    }\n  }\n\n  /**\n   * Creates a Create mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const resolverCreateField = getFieldName(modelName, GraphbackOperationType.CREATE)\n\n    mutationObj[resolverCreateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].create(args.input, context, info, model.uniqueFields)\n    }\n  }\n\n  /**\n   * Creates an Update mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].update(args.input, context, info, model.uniqueFields)\n    }\n  }\n\n  /**\n   * Creates an UpdateBy mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateByMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE_BY)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].updateBy(args, context, info, model.uniqueFields)\n    }\n  }\n\n  /**\n   * Creates a Delete Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].delete(args, context, info, model.uniqueFields)\n    }\n  }\n\n  /**\n   * Creates a DeleteBy Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteByMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE_BY)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].deleteBy(args, context, info, model.uniqueFields)\n    }\n  }\n\n  /**\n   * Creates a Find Query resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindQueryResolver (model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findField = getFieldName(modelName, GraphbackOperationType.FIND)\n\n    queryObj[findField] = async (_: any, args: FindByArgs, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      return await context.graphback[modelName].findBy(args, context, info, 'items')\n    }\n  }\n\n  /**\n   * Creates a FindOne Query resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindOneQueryResolver (model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findOneField = getFieldName(modelName, GraphbackOperationType.FIND_ONE)\n    const primaryKeyLabel = model.primaryKey.name\n\n    queryObj[findOneField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].findOne({ [primaryKeyLabel]: args.id }, context, info)\n    }\n  }\n\n  /**\n   * Creates a Create Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.CREATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToCreate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates an Update Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.UPDATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToUpdate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates a Delete Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.DELETE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToDelete(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates a OneToMany Relationship resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IResolvers} resolverObj - Resolvers object\n   * @param modelNameToModelDefinition - model type name to its definition for quick search\n   */\n  protected addOneToManyResolver (relationship: FieldRelationshipMetadata, resolverObj: IResolvers, modelNameToModelDefinition: any) {\n    const modelName = relationship.relationType.name\n    const relationOwner = relationship.ownerField.name\n    const model = modelNameToModelDefinition[modelName]\n\n    resolverObj[relationOwner] = (parent: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (Object.keys(parent).includes(relationOwner)) {\n        return parent[relationOwner]\n      }\n\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].batchLoadData(\n        relationship.relationForeignKey,\n        parent[model.primaryKey.name],\n        args.filter,\n        context,\n        info\n      )\n    }\n  }\n\n  /**\n   * Creates a OneToOne/ManyToOne Relationship resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IResolvers} resolverObj - Resolvers object\n   * @param modelNameToModelDefinition - model type name to its definition for quick search\n   */\n  protected addOneToOneResolver (relationship: FieldRelationshipMetadata, resolverObj: IResolvers, modelNameToModelDefinition: any) {\n    const modelName = relationship.relationType.name\n    const relationIdField = getPrimaryKey(relationship.relationType)\n    const relationOwner = relationship.ownerField.name\n    const model = modelNameToModelDefinition[modelName]\n\n    resolverObj[relationOwner] = (parent: any, _: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (Object.keys(parent).includes(relationOwner)) {\n        return parent[relationOwner]\n      }\n\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      const selectedFields = getSelectedFieldsFromResolverInfo(info, model)\n      selectedFields.push(relationIdField.name)\n\n      const fetchedKeys = selectedFields.join('-')\n\n      // construct a unique key to identify the dataloader\n      const dataLoaderName = `${modelName}-${relationship.kind}-${relationIdField.name}-${relationship.relationForeignKey}-${fetchedKeys}-DataLoader`\n\n      if (!context[dataLoaderName]) {\n        context[dataLoaderName] = new DataLoader<string, any>(async (keys: string[]) => {\n          const service = context.graphback[modelName]\n          const results = await service.findBy({ [relationIdField.name]: { in: keys } }, context, info)\n\n          return keys.map((key: string) => {\n            return results.items.find((item: any) => item[relationIdField.name].toString() === key.toString())\n          })\n        })\n      }\n\n      const relationForeignKey = parent[relationship.relationForeignKey]\n\n      // eslint-disable-next-line no-null/no-null\n      if (relationForeignKey === undefined || relationForeignKey === null) {\n        // eslint-disable-next-line no-null/no-null\n        return null\n      }\n\n      return context[dataLoaderName].load(relationForeignKey)\n    }\n  }\n\n  private createSchemaCRUDTypes (schemaComposer: SchemaComposer<any>) {\n    schemaComposer.add(PageRequest)\n    schemaComposer.add(IDScalarInputType)\n    schemaComposer.add(SortDirectionEnum)\n    schemaComposer.add(StringScalarInputType)\n    schemaComposer.add(BooleanScalarInputType)\n    schemaComposer.add(createInputTypeForScalar(GraphQLInt))\n    schemaComposer.add(createInputTypeForScalar(GraphQLFloat))\n\n    schemaComposer.forEach((tc: NamedTypeComposer<any>) => {\n      const namedType = tc.getType()\n      if (isScalarType(namedType) && !isSpecifiedScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) {\n        schemaComposer.add(createInputTypeForScalar(namedType))\n\n        return\n      }\n\n      const isRootType = ['Query', 'Subscription', 'Mutation'].includes(namedType.name)\n      if (isObjectType(namedType) && !isModelType(namedType) && !isRootType) {\n        addCreateObjectInputType(schemaComposer, namedType)\n        addUpdateObjectInputType(schemaComposer, namedType)\n      }\n    })\n  }\n\n  /**\n   * Add relationship fields to GraphQL model types\n   *\n   * @param schema\n   * @param models\n   */\n  private buildSchemaModelRelationships (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    // create or update relationship fields to the model types.\n    for (const model of models) {\n      const modifiedType = schemaComposer.getOTC(model.graphqlType.name)\n\n      addRelationshipFields(model, modifiedType)\n      extendRelationshipFields(model, modifiedType)\n    }\n  }\n}\n","import { SchemaFormatter } from './SchemaFormatter'\n\nconst noteString = 'NOTE: This schema was generated by Rel and should not be changed manually'\n\n/**\n * Typescript string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const tsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nexport const schemaString = \\`\n${schemaString}\n\\`;\n`\n  }\n}\n\n/**\n * JS string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const jsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nconst schemaString = \\`\n${schemaString}\n\\`;\n\nmodule.exports = { schemaString };\n`\n  }\n}\n\n/**\n * GQL string template that returns schema in original form\n */\nexport const gqlSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `## ${noteString}\\n\\n${schemaString}`\n  }\n}\n","/* eslint-disable max-lines */\nimport { GraphQLInputObjectType, GraphQLNamedInputType, GraphQLList, GraphQLBoolean, GraphQLInt, GraphQLString, GraphQLID, GraphQLEnumType, GraphQLObjectType, GraphQLNonNull, GraphQLField, getNamedType, isScalarType, GraphQLInputFieldMap, GraphQLScalarType, GraphQLNamedType, GraphQLInputField, isEnumType, isObjectType, isInputObjectType, GraphQLInputType, getNullableType, isListType } from 'graphql'\nimport { GraphbackOperationType, getInputTypeName, getInputFieldName, getInputFieldTypeName, isOneToManyField, getPrimaryKey, ModelDefinition, FILTER_SUPPORTED_SCALARS, isTransientField, isAutoPrimaryKey } from '@graphback/core'\nimport { SchemaComposer } from 'graphql-compose'\nimport { copyWrappingType } from './copyWrappingType'\n\nconst PageRequestTypeName = 'PageRequest'\nconst SortDirectionEnumName = 'SortDirectionEnum'\nconst OrderByInputTypeName = 'OrderByInput'\n\nexport const getInputName = (type: GraphQLNamedType) => {\n  if (isEnumType(type)) {\n    return 'StringInput'\n  }\n\n  if (isInputObjectType(type)) {\n    return type.name\n  }\n\n  return `${type.name}Input`\n}\n\nexport const createInputTypeForScalar = (scalarType: GraphQLScalarType) => {\n  const newInput = new GraphQLInputObjectType({\n    name: getInputName(scalarType),\n    fields: {\n      ne: { type: scalarType },\n      eq: { type: scalarType },\n      le: { type: scalarType },\n      lt: { type: scalarType },\n      ge: { type: scalarType },\n      gt: { type: scalarType },\n      in: { type: GraphQLList(GraphQLNonNull(scalarType)) },\n      between: { type: GraphQLList(GraphQLNonNull(scalarType)) }\n    }\n  })\n\n  return newInput\n}\n\nexport const StringScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLString),\n  fields: {\n    ne: { type: GraphQLString },\n    eq: { type: GraphQLString },\n    le: { type: GraphQLString },\n    lt: { type: GraphQLString },\n    ge: { type: GraphQLString },\n    gt: { type: GraphQLString },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLString)) },\n    contains: { type: GraphQLString },\n    startsWith: { type: GraphQLString },\n    endsWith: { type: GraphQLString }\n  }\n})\n\nexport const IDScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLID),\n  fields: {\n    ne: { type: GraphQLID },\n    eq: { type: GraphQLID },\n    le: { type: GraphQLID },\n    lt: { type: GraphQLID },\n    ge: { type: GraphQLID },\n    gt: { type: GraphQLID },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLID)) }\n  }\n})\n\nexport const BooleanScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLBoolean),\n  fields: {\n    ne: { type: GraphQLBoolean },\n    eq: { type: GraphQLBoolean }\n  }\n})\n\nexport const PageRequest = new GraphQLInputObjectType({\n  name: PageRequestTypeName,\n  fields: {\n    limit: {\n      type: GraphQLInt\n    },\n    offset: {\n      type: GraphQLInt\n    }\n  }\n})\n\nexport const SortDirectionEnum = new GraphQLEnumType({\n  name: SortDirectionEnumName,\n  values: {\n    DESC: { value: 'desc' },\n    ASC: { value: 'asc' }\n  }\n})\n\nexport const buildOrderByInputType = (modelName) => {\n  return new GraphQLInputObjectType({\n    name: modelName+ \"OrderByInput\",\n    fields: {\n      field: { type: modelName + \"FieldsEnum\" },\n      order: { type: SortDirectionEnum, defaultValue: 'asc' }\n    }\n  })\n}\n\nexport const OrderByInputType = new GraphQLInputObjectType({\n  name: OrderByInputTypeName,\n  fields: {\n    field: { type: GraphQLNonNull(GraphQLString) },\n    order: { type: SortDirectionEnum, defaultValue: 'asc' }\n  }\n})\n\nfunction getModelInputFields (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType, operationType: GraphbackOperationType): GraphQLInputField[] {\n  const inputFields: GraphQLInputField[] = []\n  const fields: Array<GraphQLField<any, any>> = Object.values(modelType.getFields())\n\n  for (const field of fields) {\n    if (isTransientField(field) || isOneToManyField(field)) {\n      continue\n    }\n\n    const typeName = getInputFieldTypeName(modelType.name, field, operationType)\n\n    if (!typeName) {\n      continue\n    }\n\n    const name = getInputFieldName(field)\n    const type = schemaComposer.getAnyTC(typeName).getType()\n    const wrappedType = copyWrappingType(field.type, type) as GraphQLInputType\n\n    const inputField: GraphQLInputField = {\n      name,\n      type: wrappedType,\n      description: undefined,\n      extensions: [],\n      deprecationReason: field.deprecationReason\n    }\n\n    inputFields.push(inputField)\n  }\n\n  return inputFields\n}\n\nexport function buildFindOneFieldMap (modelType: ModelDefinition, schemaComposer: SchemaComposer<any>): GraphQLInputFieldMap {\n  const { type } = modelType.primaryKey\n\n  return {\n    __id: {\n      name: '__id',\n      type: GraphQLNonNull(schemaComposer.getAnyTC(type).getType()),\n      description: undefined,\n      extensions: undefined,\n      deprecationReason: undefined\n    }\n  }\n}\n\nexport const buildFilterInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.FIND\n\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const inputFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const scalarInputFields: any = {}\n\n  for (const field of inputFields) {\n    const namedType = getNamedType(field.type)\n\n    if (FILTER_SUPPORTED_SCALARS.includes(namedType.name) || isEnumType(namedType)) {\n      const type = getInputName(namedType)\n      scalarInputFields[field.name] = {\n        name: field.name,\n        type\n      }\n    }\n  }\n\n  const filterInput = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: {\n      ...scalarInputFields,\n      and: {\n        type: `[${inputTypeName}!]`\n      },\n      or: {\n        type: `[${inputTypeName}!]`\n      },\n      not: {\n        type: `${inputTypeName}`\n      }\n    }\n  })\n\n  schemaComposer.add(filterInput)\n}\n\nexport const buildCreateMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.CREATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const mutationInputType = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: () => {\n      const fields: any = {}\n      for (const field of allModelFields) {\n        if (field.name === idField.name && isAutoPrimaryKey(field)) {\n          continue\n        }\n\n        fields[field.name] = {\n          name: field.name,\n          type: field.type\n        }\n      }\n\n      return fields\n    }\n  })\n\n  schemaComposer.add(mutationInputType)\n}\n\nexport const buildSubscriptionFilterType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const inputTypeName = getInputTypeName(modelType.name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n  const modelFields = Object.values(modelType.getFields())\n  const subscriptionFilterFields = modelFields.filter((f: GraphQLField<any, any>) => {\n    const namedType = getNamedType(f.type)\n\n    return !isTransientField(f) && (isScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) || isEnumType(namedType)\n  })\n\n  const fields = {\n    and: {\n      type: `[${inputTypeName}!]`\n    },\n    or: {\n      type: `[${inputTypeName}!]`\n    },\n    not: {\n      type: `${inputTypeName}`\n    }\n  }\n  for (const { name, type } of subscriptionFilterFields) {\n    const fieldType: GraphQLNamedType = getNamedType(type)\n    const inputFilterName = getInputName(fieldType)\n\n    fields[name] = {\n      name,\n      type: schemaComposer.get(inputFilterName)\n    }\n  }\n\n  schemaComposer.createInputTC({\n    name: inputTypeName,\n    fields\n  })\n}\n\nexport const buildMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.UPDATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const mutationInputObject = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: () => {\n      const fields: any = {}\n      for (const { name, type } of allModelFields) {\n        let fieldType: GraphQLInputType\n\n        if (name !== idField.name) {\n          fieldType = getNullableType(type)\n        }\n\n        if (isListType(fieldType)) {\n          fieldType = GraphQLList(getNamedType(fieldType))\n        }\n\n        fields[name] = {\n          name,\n          type: fieldType || type\n        }\n      }\n\n      return fields\n    }\n  })\n\n  schemaComposer.add(mutationInputObject)\n}\n\nfunction mapObjectInputFields (schemaComposer: SchemaComposer<any>, fields: Array<GraphQLField<any, any>>, objectName: string): GraphQLInputField[] {\n  return fields.map((field: GraphQLField<any, any>) => {\n    let namedType = getNamedType(field.type) as GraphQLNamedInputType\n    let typeName = namedType.name\n\n    let inputType\n    if (isObjectType(namedType)) {\n      typeName = getInputTypeName(typeName, GraphbackOperationType.CREATE)\n      namedType = schemaComposer.getOrCreateITC(typeName).getType()\n\n      inputType = copyWrappingType(field.type, namedType)\n    }\n\n    return {\n      name: field.name,\n      type: inputType || field.type,\n      extensions: [],\n      deprecationReason: field.deprecationReason\n    }\n  })\n}\n\nexport function addCreateObjectInputType (schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.CREATE\n\n  const inputType = new GraphQLInputObjectType({\n    name: getInputTypeName(objectType.name, operationType),\n    fields: mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n      .reduce((fieldObj: any, { name, type, description }: any) => {\n        fieldObj[name] = { type, description }\n\n        return fieldObj\n      }, {})\n  })\n\n  schemaComposer.add(inputType)\n}\n\nexport function addUpdateObjectInputType (schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.UPDATE\n\n  const inputType = new GraphQLInputObjectType({\n    name: getInputTypeName(objectType.name, operationType),\n    fields: mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n      .reduce((fieldObj: any, { name, type, description }: any) => {\n        fieldObj[name] = { type: getNullableType(type), description }\n\n        return fieldObj\n      }, {})\n  })\n\n  schemaComposer.add(inputType)\n}\n\nexport const createMutationListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}MutationResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      }\n    }\n  })\n}\n\nexport const createModelListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}ResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      },\n      offset: { type: GraphQLInt },\n      limit: { type: GraphQLInt },\n      count: { type: GraphQLInt }\n    }\n  })\n}\n\nexport function createVersionedInputFields (versionedInputType: GraphQLInputObjectType) {\n  return {\n    createdAt: {\n      type: versionedInputType\n    },\n    updatedAt: {\n      type: versionedInputType\n    }\n  }\n}\n\nexport function createVersionedFields (type: GraphQLScalarType) {\n  return {\n    createdAt: {\n      type,\n    },\n    updatedAt: {\n      type,\n    }\n  }\n}\n","import { isWrappingType, GraphQLNonNull, isListType, GraphQLList, GraphQLType, getNamedType, GraphQLInputType, GraphQLOutputType } from 'graphql'\n\ntype WrappingTypeName = 'GraphQLList' | 'GraphQLNonNull'\ntype InputOrOutTypeType = GraphQLInputType | GraphQLOutputType\n\n/**\n * Copies the wrapping type(s) from one GraphQLType to another\n *\n * @param {GraphQLType} copyFromType - Get the wrapping types from this type\n * @param {GraphQLType} copyToType - Add the wrapping types to this type\n */\nexport function copyWrappingType (copyFromType: InputOrOutTypeType, copyToType: InputOrOutTypeType): InputOrOutTypeType {\n  const wrappers: WrappingTypeName[] = []\n\n  let oldTypeCopy = copyFromType\n  while (isWrappingType(oldTypeCopy)) {\n    if (isListType(oldTypeCopy)) {\n      wrappers.push('GraphQLList')\n    } else {\n      wrappers.push('GraphQLNonNull')\n    }\n    oldTypeCopy = oldTypeCopy.ofType\n  }\n\n  let namedNewType: GraphQLType = getNamedType(copyToType)\n  while (wrappers.length > 0) {\n    const wrappingType = wrappers.pop()\n    if (wrappingType === 'GraphQLList') {\n      namedNewType = GraphQLList(namedNewType)\n    } else {\n      namedNewType = GraphQLNonNull(namedNewType)\n    }\n  }\n\n  return namedNewType\n}\n"],"mappings":"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","names":[]}