{"version":3,"sources":["../src/SchemaCRUDPlugin.ts","../src/writer/schemaFormatters.ts","../src/definitions/schemaDefinitions.ts","../src/definitions/copyWrappingType.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { resolve, dirname, join } from 'path'\nimport { existsSync, mkdirSync, writeFileSync } from 'fs'\nimport { SchemaComposer, NamedTypeComposer } from 'graphql-compose'\nimport { IResolvers, IObjectTypeResolver } from '@graphql-tools/utils'\nimport { GraphQLNonNull, GraphQLObjectType, GraphQLSchema, GraphQLInt, GraphQLFloat, isScalarType, isSpecifiedScalarType, GraphQLResolveInfo, isObjectType, GraphQLInputObjectType, GraphQLScalarType } from 'graphql'\nimport { Timestamp, getFieldName, printSchemaWithDirectives, getSubscriptionName, GraphbackCoreMetadata, GraphbackOperationType, GraphbackPlugin, ModelDefinition, getInputTypeName, GraphbackContext, graphbackScalarsTypes, FILTER_SUPPORTED_SCALARS, FindByArgs } from '@graphback/core'\nimport { gqlSchemaFormatter, jsSchemaFormatter, tsSchemaFormatter } from './writer/schemaFormatters'\nimport { buildOrderByInputType, buildFilterInputType, createModelListResultType, StringScalarInputType, BooleanScalarInputType, SortDirectionEnum, buildCreateMutationInputType, buildFindOneFieldMap, buildMutationInputType, buildSubscriptionFilterType, IDScalarInputType, PageRequest, createInputTypeForScalar, createVersionedFields, createVersionedInputFields, addCreateObjectInputType, addUpdateObjectInputType, getInputName, createMutationListResultType } from './definitions/schemaDefinitions'\n\n/**\n * Configuration for Schema generator CRUD plugin\n */\nexport interface SchemaCRUDPluginConfig {\n  /**\n   * RelativePath for the output files created by generator\n   * e.g. /path/to/schema/schema.graphql\n   */\n  outputPath?: string\n}\n\nexport const SCHEMA_CRUD_PLUGIN_NAME = 'SchemaCRUD'\n\n/**\n * Graphback CRUD operations plugin\n *\n * Plugins adds additional Queries, Mutations and Subscriptions into the Schema along\n * with required input types and scalars. Plugin can be used automatically define best\n * patterns for CRUD operations on top of GraphQL Schema\n * Plugin checkes all types annotated with model\n *\n * Used graphql metadata:\n *\n * - model: marks type to be processed by CRUD generator\n * - crud: controls what types of operations can be generated.\n * For example crud.update: false will disable updates for type\n */\nexport class SchemaCRUDPlugin extends GraphbackPlugin {\n  private readonly pluginConfig: SchemaCRUDPluginConfig\n\n  public constructor(pluginConfig?: SchemaCRUDPluginConfig) {\n    super()\n    this.pluginConfig = {\n      ...pluginConfig\n    }\n  }\n\n  public transformSchema(metadata: GraphbackCoreMetadata): GraphQLSchema {\n    const schema = metadata.getSchema()\n\n    const models = metadata.getModelDefinitions()\n    if (models.length === 0) {\n      this.logWarning('Provided schema has no models. Returning original schema without any changes.')\n\n      return schema\n    };\n\n    const schemaComposer = new SchemaComposer(schema)\n    this.createAggregationForModelFields(schemaComposer, models)\n    this.buildSchemaForModels(schemaComposer, models)\n    this.addMetadataFields(schemaComposer, models)\n\n    return schemaComposer.buildSchema()\n  }\n\n  /**\n   * Creates CRUD resolvers\n   *\n   * @param {GraphbackCoreMetadata} metadata - Core metatata containing all model information\n   */\n  public createResolvers(metadata: GraphbackCoreMetadata): IResolvers {\n    const models = metadata.getModelDefinitions()\n\n    if (models.length === 0) {\n      return undefined\n    }\n\n    const resolvers: IResolvers = {}\n\n    // Graphback scalar resolvers\n    const schema = metadata.getSchema()\n    for (const graphbackScalar of graphbackScalarsTypes) {\n      if (schema.getType(graphbackScalar.name)) {\n        resolvers[graphbackScalar.name] = graphbackScalar\n      }\n    }\n\n    const modelNameToModelDefinition = models\n      .reduce((acc: any, model: ModelDefinition) => {\n        return {\n          ...acc,\n          [model.graphqlType.name]: model\n        }\n      }, {})\n\n    for (const model of models) {\n      this.addQueryResolvers(model, resolvers)\n      this.addMutationResolvers(model, resolvers)\n      this.addSubscriptionResolvers(model, resolvers)\n    }\n\n    return resolvers\n  }\n\n  public createResources(metadata: GraphbackCoreMetadata): void {\n    if (!this.pluginConfig.outputPath) {\n      return\n    }\n\n    let schemaPath = resolve(this.pluginConfig.outputPath)\n\n    // check if user path is to directory or full path to schema\n    // assign default file name otherwise\n    if (!schemaPath.includes('.')) {\n      schemaPath = join(schemaPath, 'schema.graphql')\n    }\n\n    // get file extension\n    const fileExtension = schemaPath.split('.').pop()\n\n    const schemaString = this.transformSchemaToString(metadata.getSchema(), fileExtension)\n\n    const outputDir = resolve(dirname(this.pluginConfig.outputPath))\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true })\n    }\n\n    writeFileSync(schemaPath, schemaString)\n  }\n\n  public getPluginName() {\n    return SCHEMA_CRUD_PLUGIN_NAME\n  }\n\n  protected buildSchemaForModels(schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    this.createSchemaCRUDTypes(schemaComposer)\n\n    for (const model of Object.values(models)) {\n      const modelName = model.graphqlType.name\n      schemaComposer.getOTC(modelName).addFields({\n        _id: {\n          type: \"ID\"\n        }\n      })\n      const errorMessage = (field: string) => `${modelName} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if (model.fields.id) {\n        throw new Error(errorMessage(\"id\"))\n      }\n\n      if (model.fields.__unique) {\n        throw new Error(errorMessage(\"__unique\"))\n      }\n\n      this.createQueries(model, schemaComposer)\n      this.createMutations(model, schemaComposer)\n      this.createSubscriptions(model, schemaComposer)\n    }\n  }\n\n  protected createSubscriptions(model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n\n    buildSubscriptionFilterType(schemaComposer, modelType)\n\n    const subscriptionFields = {}\n    let operation = getSubscriptionName(name, GraphbackOperationType.CREATE)\n\n    let filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n    const subCreateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subCreateFilterInputType\n        }\n      }\n    }\n\n    operation = getSubscriptionName(name, GraphbackOperationType.UPDATE)\n\n    filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_UPDATE)\n    const subUpdateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subUpdateFilterInputType\n        }\n      }\n    }\n\n    operation = getSubscriptionName(name, GraphbackOperationType.DELETE)\n\n    filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_DELETE)\n    const subDeleteFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subDeleteFilterInputType\n        }\n      }\n    }\n\n    schemaComposer.Subscription.addFields(subscriptionFields)\n  }\n\n  protected createSchema(queryTypes: any, mutationTypes: any, subscriptionTypes: any) {\n    const queryType = new GraphQLObjectType({\n      name: 'Query',\n      fields: () => (queryTypes)\n    })\n\n    let mutationType\n    if (Object.keys(mutationTypes).length !== 0) {\n      mutationType = new GraphQLObjectType({\n        name: 'Mutation',\n        fields: () => (mutationTypes)\n      })\n    }\n\n    let subscriptionType\n    if (Object.keys(subscriptionTypes).length !== 0) {\n      subscriptionType = new GraphQLObjectType({\n        name: 'Subscription',\n        fields: () => (subscriptionTypes)\n      })\n    }\n\n    return new GraphQLSchema({\n      query: queryType,\n      mutation: mutationType,\n      subscription: subscriptionType\n    })\n  }\n\n  protected createMutations(model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const resultListType = createMutationListResultType(modelType)\n    buildMutationInputType(schemaComposer, modelType)\n\n    const mutationFields = {}\n    let operationType = GraphbackOperationType.CREATE\n\n    buildCreateMutationInputType(schemaComposer, modelType)\n\n    let inputTypeName = getInputTypeName(name, operationType)\n    const createMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n    let operation = getFieldName(name, operationType)\n    mutationFields[operation] = {\n      type: modelType,\n      args: {\n        input: {\n          type: GraphQLNonNull(createMutationInputType)\n        }\n      }\n    }\n    operationType = GraphbackOperationType.UPDATE\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    let updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n    mutationFields[operation] = {\n      type: modelType,\n      args: {\n        input: {\n          type: GraphQLNonNull(updateMutationInputType)\n        }\n      }\n    }\n    operationType = GraphbackOperationType.UPDATE_BY\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n    let filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n\n    mutationFields[operation] = {\n      type: resultListType,\n      args: {\n        filter: {\n          type: filterInputType\n        },\n        input: {\n          type: GraphQLNonNull(updateMutationInputType)\n        }\n      }\n    }\n\n    operationType = GraphbackOperationType.DELETE\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    mutationFields[operation] = {\n      type: modelType,\n      args: buildFindOneFieldMap(model, schemaComposer)\n    }\n\n    operationType = GraphbackOperationType.DELETE_BY\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n    mutationFields[operation] = {\n      type: resultListType,\n      args: {\n        filter: {\n          type: filterInputType\n        }\n      }\n    }\n\n    schemaComposer.Mutation.addFields(mutationFields)\n  }\n\n  protected createQueries(model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const aggFields = {}\n    const aggregations = ['avg', 'max', 'min', 'sum']\n    aggFields.count = {\n      type: 'Int',\n      args: {\n        of: {\n          type: `Of${name}Input`\n        },\n        distinct: {\n          type: \"Boolean\"\n        }\n      },\n      extensions: {\n        directives: {\n          transient: {}\n        }\n      }\n    }\n    if (schemaComposer.has(`Of${name}NumberInput`)) {\n      aggregations.forEach(agg => {\n        aggFields[agg] = {\n          type: 'Int',\n          args: {\n            of: {\n              type: `Of${name}NumberInput`\n            },\n            distinct: {\n              type: \"Boolean\"\n            }\n          },\n          extensions: {\n            directives: {\n              transient: {}\n            }\n          }\n        }\n      })\n    }\n    modelTC.addFields(aggFields)\n\n    buildFilterInputType(schemaComposer, modelType)\n\n    const queryFields = {}\n    let operation = getFieldName(name, GraphbackOperationType.FIND_ONE)\n    queryFields[operation] = {\n      type: model.graphqlType,\n      args: buildFindOneFieldMap(model, schemaComposer)\n    }\n\n    const operationType = GraphbackOperationType.FIND\n    operation = getFieldName(name, operationType)\n\n    const inputTypeName = getInputTypeName(name, operationType)\n    const filterInputType = schemaComposer.getITC(inputTypeName).getType()\n    const resultListType = createModelListResultType(modelType)\n    queryFields[operation] = {\n      type: GraphQLNonNull(resultListType),\n      args: {\n        filter: {\n          type: filterInputType\n        },\n        page: {\n          type: PageRequest\n        },\n        orderBy: {\n          type: [buildOrderByInputType(schemaComposer, name)]\n        }\n      }\n    }\n\n    schemaComposer.Query.addFields(queryFields)\n  }\n\n  protected createAggregationForModelFields(schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    for (const model of models) {\n      const modelName = model.graphqlType.name\n      const enumName = `${modelName}FieldsEnum`\n      const numberEnumName = `${modelName}NumberFieldsEnum`\n      const fieldKeys = Object.keys(model.fields)\n      const relationshipFields = model.relationships.map(r => r.field)\n      const fields = fieldKeys.filter(f => !model.fields[f].transient && !model.fields[f].computed && !relationshipFields.includes(f)).join(' ')\n      const numberTypes = [\"Int\", \"Float\", \"BigInt\", \"NonPositiveFloat\", \"NonPositiveInt\", \"NonNegativeInt\",\n        \"NonNegativeFloat\", \"NegativeFloat\", \"NegativeInt\", \"PositiveInt\", \"PositiveFloat\"]\n      const numberFields = fieldKeys.filter(f => {\n        return !model.fields[f].transient && !model.fields[f].computed && !relationshipFields.includes(f) && numberTypes.includes(model.fields[f].type.replace(\"!\", \"\"))\n      }).join(' ')\n      schemaComposer.createEnumTC(`enum ${enumName} { ${fields} createdAt updatedAt }`)\n      schemaComposer.createInputTC(`input Of${modelName}Input { of: ${enumName}}`)\n      if (numberFields !== '') {\n        schemaComposer.createEnumTC(`enum ${numberEnumName} { ${numberFields} }`)\n        schemaComposer.createInputTC(`input Of${modelName}NumberInput { of: ${numberEnumName}}`)\n      }\n    }\n  }\n\n  protected addMetadataFields(schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    const timeStampInputName = getInputName(Timestamp)\n    let timestampInputType: GraphQLInputObjectType\n    let timestampType: GraphQLScalarType\n    for (const model of models) {\n      const name = model.graphqlType.name\n      const modelTC = schemaComposer.getOTC(name)\n      const updateField = model.fields.updatedAt\n      const createAtField = model.fields.createdAt\n      const errorMessage = (field: string) => `${name} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if (createAtField) {\n        throw new Error(errorMessage(\"createdAt\"))\n      }\n\n      if (updateField) {\n        throw new Error(errorMessage(\"updatedAt\"))\n      }\n\n      if (!timestampInputType) {\n        if (schemaComposer.has(Timestamp.name)) {\n          timestampInputType = schemaComposer.getITC(timeStampInputName).getType()\n        } else {\n          schemaComposer.createScalarTC(Timestamp)\n          timestampInputType = createInputTypeForScalar(Timestamp)\n          schemaComposer.add(timestampInputType)\n        }\n\n        timestampType = schemaComposer.getSTC(Timestamp.name).getType()\n      }\n\n      const metadataFields = createVersionedFields(timestampType)\n\n      modelTC.addFields(metadataFields)\n\n      const inputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND))\n      if (inputType) {\n        const metadataInputFields = createVersionedInputFields(timestampInputType)\n        inputType.addFields(metadataInputFields)\n      }\n    };\n  }\n\n  /**\n   *\n   * Print schema as a string and format in one of the available languages\n   *\n   * @param {GraphQLSchema} schema\n   * @param {string} fileExtension\n   */\n  protected transformSchemaToString(schema: GraphQLSchema, fileExtension: string) {\n    const schemaString = printSchemaWithDirectives(schema)\n    if (this.pluginConfig) {\n      if (fileExtension === 'ts') {\n        return tsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'js') {\n        return jsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'graphql') {\n        return gqlSchemaFormatter.format(schemaString)\n      }\n    }\n    throw Error(`Invalid format '${fileExtension}' specified. \\`options.format\\` supports only \\`ts\\`, \\`js\\` and \\`graphql\\` flags`)\n  }\n\n  /**\n   * Create Query resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addQueryResolvers(model: ModelDefinition, resolvers: IResolvers) {\n    resolvers.Query = (resolvers.Query || {}) as IObjectTypeResolver\n\n    this.addFindOneQueryResolver(model, resolvers.Query)\n    this.addFindQueryResolver(model, resolvers.Query)\n  }\n\n  /**\n   * Create Mutation resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addMutationResolvers(model: ModelDefinition, resolvers: IResolvers) {\n    resolvers.Mutation = (resolvers.Mutation || {}) as IObjectTypeResolver\n    this.addCreateMutationResolver(model, resolvers.Mutation)\n    this.addUpdateMutationResolver(model, resolvers.Mutation)\n    this.addUpdateByMutationResolver(model, resolvers.Mutation)\n    this.addDeleteMutationResolver(model, resolvers.Mutation)\n    this.addDeleteByMutationResolver(model, resolvers.Mutation)\n  }\n\n  /**\n   * Create Subscription resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addSubscriptionResolvers(model: ModelDefinition, resolvers: IResolvers) {\n    const modelType = model.graphqlType\n    resolvers.Subscription = (resolvers.Subscription || {}) as IObjectTypeResolver\n    this.addCreateSubscriptionResolver(modelType, resolvers.Subscription)\n    this.addUpdateSubscriptionResolver(modelType, resolvers.Subscription)\n    this.addDeleteSubscriptionResolver(modelType, resolvers.Subscription)\n  }\n\n  /**\n   * Creates a Create mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateMutationResolver(model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const resolverCreateField = getFieldName(modelName, GraphbackOperationType.CREATE)\n\n    mutationObj[resolverCreateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].create(args.input, context, info)\n    }\n  }\n\n  /**\n   * Creates an Update mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateMutationResolver(model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].update(args.input, context, info)\n    }\n  }\n\n  /**\n   * Creates an UpdateBy mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateByMutationResolver(model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE_BY)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].updateBy(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a Delete Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteMutationResolver(model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].delete(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a DeleteBy Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteByMutationResolver(model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE_BY)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].deleteBy(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a Find Query resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindQueryResolver(model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findField = getFieldName(modelName, GraphbackOperationType.FIND)\n\n    queryObj[findField] = async (_: any, args: FindByArgs, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      return await context.graphback[modelName].findBy(args, context, info, 'items')\n    }\n  }\n\n  /**\n   * Creates a FindOne Query resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindOneQueryResolver(model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findOneField = getFieldName(modelName, GraphbackOperationType.FIND_ONE)\n    const primaryKeyLabel = model.primaryKey.name\n\n    queryObj[findOneField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].findOne({ [primaryKeyLabel]: args.id }, context, info)\n    }\n  }\n\n  /**\n   * Creates a Create Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateSubscriptionResolver(modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.CREATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToCreate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates an Update Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateSubscriptionResolver(modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.UPDATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToUpdate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates a Delete Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteSubscriptionResolver(modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.DELETE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToDelete(args.filter, context)\n      }\n    }\n  }\n\n  private createSchemaCRUDTypes(schemaComposer: SchemaComposer<any>) {\n    schemaComposer.add(PageRequest)\n    schemaComposer.add(IDScalarInputType)\n    schemaComposer.add(SortDirectionEnum)\n    schemaComposer.add(StringScalarInputType)\n    schemaComposer.add(BooleanScalarInputType)\n    schemaComposer.add(createInputTypeForScalar(GraphQLInt))\n    schemaComposer.add(createInputTypeForScalar(GraphQLFloat))\n\n    schemaComposer.forEach((tc: NamedTypeComposer<any>) => {\n      const namedType = tc.getType()\n      if (isScalarType(namedType) && !isSpecifiedScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) {\n        schemaComposer.add(createInputTypeForScalar(namedType))\n\n        return\n      }\n\n      const isRootType = ['Query', 'Subscription', 'Mutation'].includes(namedType.name)\n      if (isObjectType(namedType) && !isRootType) {\n        addCreateObjectInputType(schemaComposer, namedType)\n        addUpdateObjectInputType(schemaComposer, namedType)\n      }\n    })\n  }\n}\n","import { SchemaFormatter } from './SchemaFormatter'\n\nconst noteString = 'NOTE: This schema was generated by Rel and should not be changed manually'\n\n/**\n * Typescript string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const tsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nexport const schemaString = \\`\n${schemaString}\n\\`;\n`\n  }\n}\n\n/**\n * JS string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const jsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nconst schemaString = \\`\n${schemaString}\n\\`;\n\nmodule.exports = { schemaString };\n`\n  }\n}\n\n/**\n * GQL string template that returns schema in original form\n */\nexport const gqlSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `## ${noteString}\\n\\n${schemaString}`\n  }\n}\n","/* eslint-disable max-lines */\nimport { GraphQLInputObjectType, GraphQLNamedInputType, GraphQLList, GraphQLBoolean, GraphQLInt, GraphQLString, GraphQLID, GraphQLEnumType, GraphQLObjectType, GraphQLNonNull, GraphQLField, getNamedType, isScalarType, GraphQLInputFieldMap, GraphQLScalarType, GraphQLNamedType, GraphQLInputField, isEnumType, isObjectType, isInputObjectType, GraphQLInputType, getNullableType, isListType } from 'graphql'\nimport { GraphbackOperationType, getInputTypeName, getInputFieldName, getInputFieldTypeName, getPrimaryKey, ModelDefinition, FILTER_SUPPORTED_SCALARS, isAutoPrimaryKey } from '@graphback/core'\nimport { SchemaComposer } from 'graphql-compose'\nimport { copyWrappingType } from './copyWrappingType'\n\nconst PageRequestTypeName = 'PageRequest'\nconst SortDirectionEnumName = 'SortDirectionEnum'\nconst OrderByInputTypeName = 'OrderByInput'\nconst aggFields = [\"count\", \"sum\", \"max\", \"avg\", \"min\"]\n\nexport const getInputName = (type: GraphQLNamedType): string => {\n  if (isEnumType(type)) {\n    return 'StringInput'\n  }\n\n  if (isInputObjectType(type)) {\n    return type.name\n  }\n\n  return `${type.name}Input`\n}\n\nexport const createInputTypeForScalar = (scalarType: GraphQLScalarType): GraphQLInputObjectType => {\n  const newInput = new GraphQLInputObjectType({\n    name: getInputName(scalarType),\n    fields: {\n      ne: { type: scalarType },\n      eq: { type: scalarType },\n      le: { type: scalarType },\n      lt: { type: scalarType },\n      ge: { type: scalarType },\n      gt: { type: scalarType },\n      in: { type: GraphQLList(GraphQLNonNull(scalarType)) },\n      between: { type: GraphQLList(GraphQLNonNull(scalarType)) }\n    }\n  })\n\n  return newInput\n}\n\nexport const StringScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLString),\n  fields: {\n    ne: { type: GraphQLString },\n    eq: { type: GraphQLString },\n    le: { type: GraphQLString },\n    lt: { type: GraphQLString },\n    ge: { type: GraphQLString },\n    gt: { type: GraphQLString },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLString)) },\n    contains: { type: GraphQLString },\n    startsWith: { type: GraphQLString },\n    endsWith: { type: GraphQLString }\n  }\n})\n\nexport const IDScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLID),\n  fields: {\n    ne: { type: GraphQLID },\n    eq: { type: GraphQLID },\n    le: { type: GraphQLID },\n    lt: { type: GraphQLID },\n    ge: { type: GraphQLID },\n    gt: { type: GraphQLID },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLID)) }\n  }\n})\n\nexport const BooleanScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLBoolean),\n  fields: {\n    ne: { type: GraphQLBoolean },\n    eq: { type: GraphQLBoolean }\n  }\n})\n\nexport const PageRequest = new GraphQLInputObjectType({\n  name: PageRequestTypeName,\n  fields: {\n    limit: {\n      type: GraphQLInt\n    },\n    offset: {\n      type: GraphQLInt\n    }\n  }\n})\n\nexport const SortDirectionEnum = new GraphQLEnumType({\n  name: SortDirectionEnumName,\n  values: {\n    DESC: { value: 'desc' },\n    ASC: { value: 'asc' }\n  }\n})\n\nexport const buildOrderByInputType = (schemaComposer, modelName: string): GraphQLInputObjectType => {\n  return new GraphQLInputObjectType({\n    name: modelName + \"OrderByInput\",\n    fields: {\n      field: { type: schemaComposer.getETC(modelName + \"FieldsEnum\").getType() },\n      order: { type: SortDirectionEnum, defaultValue: 'asc' }\n    }\n  })\n}\n\nexport const OrderByInputType = new GraphQLInputObjectType({\n  name: OrderByInputTypeName,\n  fields: {\n    field: { type: GraphQLNonNull(GraphQLString) },\n    order: { type: SortDirectionEnum, defaultValue: 'asc' }\n  }\n})\n\nfunction addITC(schemaComposer, inputTypeName, fields) {\n  let itc\n  try {\n    itc = schemaComposer.getITC(inputTypeName)\n  } catch {\n    itc = null\n  }\n\n  if (!itc) {\n    schemaComposer.createInputTC({\n      name: inputTypeName,\n      fields\n    })\n  } else {\n    itc.removeField(\"foo\").addFields(fields)\n  }\n}\n\nfunction getModelInputFields(schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType, operationType: GraphbackOperationType): GraphQLInputField[] {\n  const inputFields: GraphQLInputField[] = []\n  const fields: Array<GraphQLField<any, any>> = Object.values(modelType.getFields())\n\n  for (const field of fields) {\n    const typeName = getInputFieldTypeName(modelType.name, field, operationType)\n    if (!typeName) {\n      continue\n    }\n    if (field?.extensions?.directives?.some?.(d => [\"computed\", \"transient\"].includes(d.name))) {\n      continue\n    }\n\n    const name = getInputFieldName(field)\n\n    let type\n    try {\n      type = schemaComposer.getAnyTC(typeName).getType()\n    } catch {\n      type = schemaComposer.createInputTC(`input ${typeName} { foo: Int }`).getType()\n    }\n\n    const wrappedType = copyWrappingType(field.type, type) as GraphQLInputType\n\n    const extensions = {\n      directives: []\n    }\n\n    const constraintDirective = field?.extensions?.directives?.find?.(d => d.name === \"constraint\")\n\n    if (constraintDirective) {\n      extensions.directives = [constraintDirective]\n    }\n\n    const inputField: GraphQLInputField = {\n      name,\n      type: wrappedType,\n      description: undefined,\n      extensions,\n      deprecationReason: field.deprecationReason\n    }\n    inputFields.push(inputField)\n  }\n\n  return inputFields\n}\n\nexport function buildFindOneFieldMap(modelType: ModelDefinition, schemaComposer: SchemaComposer<any>): GraphQLInputFieldMap {\n  const { type } = modelType.primaryKey\n\n  return {\n    _id: {\n      name: '_id',\n      type: GraphQLNonNull(schemaComposer.getAnyTC(type).getType()),\n      description: undefined,\n      extensions: undefined,\n      deprecationReason: undefined\n    }\n  }\n}\n\nexport const buildFilterInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.FIND\n\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const inputFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const scalarInputFields: any = {}\n\n  for (const field of inputFields) {\n    const namedType = getNamedType(field.type)\n    if (aggFields.includes(field.name)) {\n      continue\n    }\n    if (FILTER_SUPPORTED_SCALARS.includes(namedType.name) || isEnumType(namedType) || isInputObjectType(namedType)) {\n      const type = getInputName(namedType)\n      scalarInputFields[field.name] = {\n        name: field.name,\n        type\n      }\n    }\n  }\n\n  const fields = {\n    ...scalarInputFields,\n    and: {\n      type: `[${inputTypeName}!]`\n    },\n    or: {\n      type: `[${inputTypeName}!]`\n    },\n    not: {\n      type: `${inputTypeName}`\n    }\n  }\n\n  addITC(schemaComposer, inputTypeName, fields)\n}\n\nexport const buildCreateMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.CREATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const fields: any = {}\n  for (const field of allModelFields) {\n    if ((field.name === idField.name && isAutoPrimaryKey(field)) || aggFields.includes(field.name)) {\n      continue\n    }\n\n    fields[field.name] = {\n      name: field.name,\n      type: field.type,\n      extensions: field.extensions\n    }\n  }\n\n  addITC(schemaComposer, inputTypeName, fields)\n  const relationFields = {}\n  Object.keys(fields).forEach(k => {\n    if (!([\"ID\", \"ID!\"].includes(fields[k].type.toString()) || fields[k].name === \"_id\") && !aggFields.includes(fields[k].name)) {\n      relationFields[k] = fields[k]\n    }\n  })\n  addITC(schemaComposer, `Create${modelType.name}RelationInput`, relationFields)\n}\n\nexport const buildSubscriptionFilterType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const inputTypeName = getInputTypeName(modelType.name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n  const modelFields = Object.values(modelType.getFields())\n  const subscriptionFilterFields = modelFields.filter((f: GraphQLField<any, any>) => {\n    const namedType = getNamedType(f.type)\n    return !f.extensions?.directives?.some?.(d => [\"transient\", \"computed\"].includes(d.name)) && (isScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) || isEnumType(namedType)\n  })\n\n  const fields = {\n    and: {\n      type: `[${inputTypeName}!]`\n    },\n    or: {\n      type: `[${inputTypeName}!]`\n    },\n    not: {\n      type: `${inputTypeName}`\n    }\n  }\n  for (const { name, type } of subscriptionFilterFields) {\n    const fieldType: GraphQLNamedType = getNamedType(type)\n    const inputFilterName = getInputName(fieldType)\n\n    fields[name] = {\n      name,\n      type: schemaComposer.get(inputFilterName)\n    }\n  }\n\n  addITC(schemaComposer, inputTypeName, fields)\n}\n\nexport const buildMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.UPDATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const fields: any = {}\n  for (const { name, type, extensions } of allModelFields) {\n    if (aggFields.includes(name)) {\n      continue\n    }\n    let fieldType: GraphQLInputType\n\n    if (name !== idField.name) {\n      fieldType = getNullableType(type)\n    }\n\n    if (isListType(fieldType)) {\n      fieldType = GraphQLList(getNamedType(fieldType))\n    }\n\n    fields[name] = {\n      name,\n      type: fieldType || type,\n      extensions\n    }\n  }\n\n  addITC(schemaComposer, inputTypeName, fields)\n  const relationFields = {}\n  Object.keys(fields).forEach(k => {\n    if ((fields[k].type.toString() !== \"ID\" || fields[k].name === \"_id\") && !aggFields.includes(fields[k].name)) {\n      relationFields[k] = fields[k]\n    }\n  })\n  addITC(schemaComposer, `Mutate${modelType.name}RelationInput`, relationFields)\n}\n\nfunction mapObjectInputFields(schemaComposer: SchemaComposer<any>, fields: Array<GraphQLField<any, any>>, objectName: string): GraphQLInputField[] {\n  return fields.map((field: GraphQLField<any, any>) => {\n    let namedType = getNamedType(field.type) as GraphQLNamedInputType\n    let typeName = namedType.name\n\n    let inputType\n    if (isObjectType(namedType)) {\n      typeName = getInputTypeName(typeName, GraphbackOperationType.CREATE)\n      namedType = schemaComposer.getOrCreateITC(typeName).getType()\n\n      inputType = copyWrappingType(field.type, namedType)\n    }\n\n    return {\n      name: field.name,\n      type: inputType || field.type,\n      extensions: {},\n      deprecationReason: field.deprecationReason\n    }\n  })\n}\n\nexport function addCreateObjectInputType(schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.CREATE\n  const inputTypeName = getInputTypeName(objectType.name, operationType)\n  const fields = mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n    .reduce((fieldObj: any, { name, type, description }: any) => {\n      fieldObj[name] = { type, description }\n\n      return fieldObj\n    }, {})\n\n  addITC(schemaComposer, inputTypeName, fields)\n}\n\nexport function addUpdateObjectInputType(schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.UPDATE\n  const inputTypeName = getInputTypeName(objectType.name, operationType)\n  const fields = mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n    .reduce((fieldObj: any, { name, type, description }: any) => {\n      fieldObj[name] = { type: getNullableType(type), description }\n\n      return fieldObj\n    }, {})\n\n  addITC(schemaComposer, inputTypeName, fields)\n}\n\nexport const createMutationListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}MutationResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      }\n    }\n  })\n}\n\nexport const createModelListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}ResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      },\n      offset: { type: GraphQLInt },\n      limit: { type: GraphQLInt },\n      count: { type: GraphQLInt }\n    }\n  })\n}\n\nexport function createVersionedInputFields(versionedInputType: GraphQLInputObjectType) {\n  return {\n    createdAt: {\n      type: versionedInputType\n    },\n    updatedAt: {\n      type: versionedInputType\n    }\n  }\n}\n\nexport function createVersionedFields(type: GraphQLScalarType) {\n  return {\n    createdAt: {\n      type,\n    },\n    updatedAt: {\n      type,\n    }\n  }\n}\n","import { isWrappingType, GraphQLNonNull, isListType, GraphQLList, GraphQLType, getNamedType, GraphQLInputType, GraphQLOutputType } from 'graphql'\n\ntype WrappingTypeName = 'GraphQLList' | 'GraphQLNonNull'\ntype InputOrOutTypeType = GraphQLInputType | GraphQLOutputType\n\n/**\n * Copies the wrapping type(s) from one GraphQLType to another\n *\n * @param {GraphQLType} copyFromType - Get the wrapping types from this type\n * @param {GraphQLType} copyToType - Add the wrapping types to this type\n */\nexport function copyWrappingType (copyFromType: InputOrOutTypeType, copyToType: InputOrOutTypeType): InputOrOutTypeType {\n  const wrappers: WrappingTypeName[] = []\n\n  let oldTypeCopy = copyFromType\n  while (isWrappingType(oldTypeCopy)) {\n    if (isListType(oldTypeCopy)) {\n      wrappers.push('GraphQLList')\n    } else {\n      wrappers.push('GraphQLNonNull')\n    }\n    oldTypeCopy = oldTypeCopy.ofType\n  }\n\n  let namedNewType: GraphQLType = getNamedType(copyToType)\n  while (wrappers.length > 0) {\n    const wrappingType = wrappers.pop()\n    if (wrappingType === 'GraphQLList') {\n      namedNewType = GraphQLList(namedNewType)\n    } else {\n      namedNewType = GraphQLNonNull(namedNewType)\n    }\n  }\n\n  return namedNewType\n}\n"],"mappings":"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","names":[]}