{"version":3,"sources":["../src/SchemaCRUDPlugin.ts","../src/writer/schemaFormatters.ts","../src/definitions/schemaDefinitions.ts","../src/definitions/copyWrappingType.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { resolve, dirname, join } from 'path'\nimport { existsSync, mkdirSync, writeFileSync } from 'fs'\nimport { SchemaComposer, NamedTypeComposer } from 'graphql-compose'\nimport { IResolvers, IObjectTypeResolver } from '@graphql-tools/utils'\nimport { GraphQLNonNull, GraphQLObjectType, GraphQLSchema, GraphQLInt, GraphQLFloat, isScalarType, isSpecifiedScalarType, GraphQLResolveInfo, isObjectType, GraphQLInputObjectType, GraphQLScalarType } from 'graphql'\nimport { Timestamp, getFieldName, printSchemaWithDirectives, getSubscriptionName, GraphbackCoreMetadata, GraphbackOperationType, GraphbackPlugin, ModelDefinition, getInputTypeName, GraphbackContext, graphbackScalarsTypes, FILTER_SUPPORTED_SCALARS, FindByArgs } from '@graphback/core'\nimport { gqlSchemaFormatter, jsSchemaFormatter, tsSchemaFormatter } from './writer/schemaFormatters'\nimport { buildOrderByInputType,buildFilterInputType, createModelListResultType, StringScalarInputType, BooleanScalarInputType, SortDirectionEnum, buildCreateMutationInputType, buildFindOneFieldMap, buildMutationInputType, buildSubscriptionFilterType, IDScalarInputType, PageRequest, createInputTypeForScalar, createVersionedFields, createVersionedInputFields, addCreateObjectInputType, addUpdateObjectInputType, getInputName, createMutationListResultType } from './definitions/schemaDefinitions'\n\n/**\n * Configuration for Schema generator CRUD plugin\n */\nexport interface SchemaCRUDPluginConfig {\n  /**\n   * RelativePath for the output files created by generator\n   * e.g. /path/to/schema/schema.graphql\n   */\n  outputPath?: string\n}\n\nexport const SCHEMA_CRUD_PLUGIN_NAME = 'SchemaCRUD'\n\n/**\n * Graphback CRUD operations plugin\n *\n * Plugins adds additional Queries, Mutations and Subscriptions into the Schema along\n * with required input types and scalars. Plugin can be used automatically define best\n * patterns for CRUD operations on top of GraphQL Schema\n * Plugin checkes all types annotated with model\n *\n * Used graphql metadata:\n *\n * - model: marks type to be processed by CRUD generator\n * - crud: controls what types of operations can be generated.\n * For example crud.update: false will disable updates for type\n */\nexport class SchemaCRUDPlugin extends GraphbackPlugin {\n  private readonly pluginConfig: SchemaCRUDPluginConfig\n\n  public constructor (pluginConfig?: SchemaCRUDPluginConfig) {\n    super()\n    this.pluginConfig = {\n      ...pluginConfig\n    }\n  }\n\n  public transformSchema (metadata: GraphbackCoreMetadata): GraphQLSchema {\n    const schema = metadata.getSchema()\n\n    const models = metadata.getModelDefinitions()\n    if (models.length === 0) {\n      this.logWarning('Provided schema has no models. Returning original schema without any changes.')\n\n      return schema\n    };\n\n    const schemaComposer = new SchemaComposer(schema)\n    this.createAggregationForModelFields(schemaComposer, models)\n    this.buildSchemaForModels(schemaComposer, models)\n    this.addMetadataFields(schemaComposer, models)\n    \n    return schemaComposer.buildSchema()\n  }\n\n  /**\n   * Creates CRUD resolvers\n   *\n   * @param {GraphbackCoreMetadata} metadata - Core metatata containing all model information\n   */\n  public createResolvers (metadata: GraphbackCoreMetadata): IResolvers {\n    const models = metadata.getModelDefinitions()\n\n    if (models.length === 0) {\n      return undefined\n    }\n\n    const resolvers: IResolvers = {}\n\n    // Graphback scalar resolvers\n    const schema = metadata.getSchema()\n    for (const graphbackScalar of graphbackScalarsTypes) {\n      if (schema.getType(graphbackScalar.name)) {\n        resolvers[graphbackScalar.name] = graphbackScalar\n      }\n    }\n\n    const modelNameToModelDefinition = models\n      .reduce((acc: any, model: ModelDefinition) => {\n        return {\n          ...acc,\n          [model.graphqlType.name]: model\n        }\n      }, {})\n\n    for (const model of models) {\n      this.addQueryResolvers(model, resolvers)\n      this.addMutationResolvers(model, resolvers)\n      this.addSubscriptionResolvers(model, resolvers)\n    }\n\n    return resolvers\n  }\n\n  public createResources (metadata: GraphbackCoreMetadata): void {\n    if (!this.pluginConfig.outputPath) {\n      return\n    }\n\n    let schemaPath = resolve(this.pluginConfig.outputPath)\n\n    // check if user path is to directory or full path to schema\n    // assign default file name otherwise\n    if (!schemaPath.includes('.')) {\n      schemaPath = join(schemaPath, 'schema.graphql')\n    }\n\n    // get file extension\n    const fileExtension = schemaPath.split('.').pop()\n\n    const schemaString = this.transformSchemaToString(metadata.getSchema(), fileExtension)\n\n    const outputDir = resolve(dirname(this.pluginConfig.outputPath))\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true })\n    }\n\n    writeFileSync(schemaPath, schemaString)\n  }\n\n  public getPluginName () {\n    return SCHEMA_CRUD_PLUGIN_NAME\n  }\n\n  protected buildSchemaForModels (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    this.createSchemaCRUDTypes(schemaComposer)\n\n    for (const model of Object.values(models)) {\n      const modelName = model.graphqlType.name\n      let modifiedType = schemaComposer.getOTC(modelName)\n      const errorMessage = (field: string) => `${modelName} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if(model.fields.id) {\n        throw new Error(errorMessage(\"id\"))\n      }\n\n      if(model.fields.__unique) {\n        throw new Error(errorMessage(\"__unique\"))\n      }\n\n      modifiedType.addFields({\n        _id: {\n          type: \"ID\"\n        }\n      })\n      this.createQueries(model, schemaComposer)\n      this.createMutations(model, schemaComposer)\n      this.createSubscriptions(model, schemaComposer)\n      modifiedType = schemaComposer.getOTC(modelName)\n    }\n  }\n\n  protected createSubscriptions (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n\n    buildSubscriptionFilterType(schemaComposer, modelType)\n\n    const subscriptionFields = {}\n    let operation = getSubscriptionName(name, GraphbackOperationType.CREATE)\n\n    let filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n    const subCreateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subCreateFilterInputType\n        }\n      }\n    }\n  \n    operation = getSubscriptionName(name, GraphbackOperationType.UPDATE)\n\n    filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_UPDATE)\n    const subUpdateFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subUpdateFilterInputType\n        }\n      }\n    }\n  \n    operation = getSubscriptionName(name, GraphbackOperationType.DELETE)\n\n    filterInputName = getInputTypeName(name, GraphbackOperationType.SUBSCRIPTION_DELETE)\n    const subDeleteFilterInputType = schemaComposer.getITC(filterInputName).getType()\n\n    subscriptionFields[operation] = {\n      type: GraphQLNonNull(modelType),\n      args: {\n        filter: {\n          type: subDeleteFilterInputType\n        }\n      }\n    }\n  \n    schemaComposer.Subscription.addFields(subscriptionFields)\n  }\n\n  protected createSchema (queryTypes: any, mutationTypes: any, subscriptionTypes: any) {\n    const queryType = new GraphQLObjectType({\n      name: 'Query',\n      fields: () => (queryTypes)\n    })\n\n    let mutationType\n    if (Object.keys(mutationTypes).length !== 0) {\n      mutationType = new GraphQLObjectType({\n        name: 'Mutation',\n        fields: () => (mutationTypes)\n      })\n    }\n\n    let subscriptionType\n    if (Object.keys(subscriptionTypes).length !== 0) {\n      subscriptionType = new GraphQLObjectType({\n        name: 'Subscription',\n        fields: () => (subscriptionTypes)\n      })\n    }\n\n    return new GraphQLSchema({\n      query: queryType,\n      mutation: mutationType,\n      subscription: subscriptionType\n    })\n  }\n\n  protected createMutations (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const resultListType = createMutationListResultType(modelType)\n    buildMutationInputType(schemaComposer, modelType)\n\n    const mutationFields = {}\n    let operationType = GraphbackOperationType.CREATE\n\n    buildCreateMutationInputType(schemaComposer, modelType)\n\n    let inputTypeName = getInputTypeName(name, operationType)\n    const createMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n    let operation = getFieldName(name, operationType)\n    mutationFields[operation] = {\n      type: modelType,\n      args: {\n        input: {\n          type: GraphQLNonNull(createMutationInputType)\n        }\n      }\n    }\n    operationType = GraphbackOperationType.UPDATE\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    let updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n\n    mutationFields[operation] = {\n      type: modelType,\n      args: {\n        input: {\n          type: GraphQLNonNull(updateMutationInputType)\n        }\n      }\n    }\n    operationType = GraphbackOperationType.UPDATE_BY\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    updateMutationInputType = schemaComposer.getITC(inputTypeName).getType()\n    let filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n\n    mutationFields[operation] = {\n      type: resultListType,\n      args: {\n        filter: {\n          type: filterInputType\n        },\n        input: {\n          type: GraphQLNonNull(updateMutationInputType)\n        }\n      }\n    }\n  \n    operationType = GraphbackOperationType.DELETE\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    mutationFields[operation] = {\n      type: modelType,\n      args: buildFindOneFieldMap(model, schemaComposer)\n    }\n  \n    operationType = GraphbackOperationType.DELETE_BY\n    operation = getFieldName(name, operationType)\n\n    inputTypeName = getInputTypeName(name, operationType)\n    filterInputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND)).getType()\n    mutationFields[operation] = {\n      type: resultListType,\n      args: {\n        filter: {\n          type: filterInputType\n        }\n      }\n    }\n    \n    schemaComposer.Mutation.addFields(mutationFields)\n  }\n\n  protected createQueries (model: ModelDefinition, schemaComposer: SchemaComposer<any>) {\n    const name = model.graphqlType.name\n    const modelTC = schemaComposer.getOTC(name)\n    const modelType = modelTC.getType()\n    const aggFields = {}\n    const aggregations = ['avg', 'max', 'min', 'sum']\n    aggFields.count = {\n      type: 'Int',\n      args: {\n        of: {\n          type: `Of${name}Input`\n        },\n        distinct: {\n          type: \"Boolean\"\n        }\n      },\n      extensions: {\n        directives: {\n          transient: {}\n        }\n      }\n    }\n    if(schemaComposer.has(`Of${name}NumberInput`)) {\n      aggregations.forEach(agg => {\n        aggFields[agg] = {\n          type: 'Int',\n          args: {\n            of: {\n              type: `Of${name}NumberInput`\n            },\n            distinct: {\n              type: \"Boolean\"\n            }\n          },\n          extensions: {\n            directives: {\n              transient: {}\n            }\n          }\n        }\n      })\n    }\n    modelTC.addFields(aggFields)\n\n    buildFilterInputType(schemaComposer, modelType)\n\n    const queryFields = {}\n    let operation = getFieldName(name, GraphbackOperationType.FIND_ONE)\n    queryFields[operation] = {\n      type: model.graphqlType,\n      args: buildFindOneFieldMap(model, schemaComposer)\n    }\n    \n    const operationType = GraphbackOperationType.FIND\n    operation = getFieldName(name, operationType)\n\n    const inputTypeName = getInputTypeName(name, operationType)\n    const filterInputType = schemaComposer.getITC(inputTypeName).getType()\n    const resultListType = createModelListResultType(modelType)\n    queryFields[operation] = {\n      type: GraphQLNonNull(resultListType),\n      args: {\n        filter: {\n          type: filterInputType\n        },\n        page: {\n          type: PageRequest\n        },\n        orderBy: {\n          type: [buildOrderByInputType(name)]\n        }\n      }\n    }\n\n    schemaComposer.Query.addFields(queryFields)\n  }\n\n  protected createAggregationForModelFields (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    for (const model of models) {\n      const modelName = model.graphqlType.name\n      const enumName = `${modelName}FieldsEnum`\n      const numberEnumName = `${modelName}NumberFieldsEnum`\n      const fieldKeys = Object.keys(model.fields)\n      const fields = fieldKeys.filter(f => !model.fields[f].transient && !model.fields[f].computed).join(' ')\n      const numberTypes = [\"Int\", \"Float\",\"BigInt\", \"NonPositiveFloat\", \"NonPositiveInt\", \"NonNegativeInt\", \n      \"NonNegativeFloat\", \"NegativeFloat\", \"NegativeInt\", \"PositiveInt\", \"PositiveFloat\"]\n      const numberFields = fieldKeys.filter(f => {\n        return !model.fields[f].transient && !model.fields[f].computed && numberTypes.includes(model.fields[f].type.replace(\"!\", \"\"))\n      }).join(' ')\n      schemaComposer.createEnumTC(`enum ${enumName} { ${fields} createdAt updatedAt }`)\n      schemaComposer.createInputTC(`input Of${modelName}Input { of: ${enumName}}`)\n      if(numberFields !== '') {\n        schemaComposer.createEnumTC(`enum ${numberEnumName} { ${numberFields} }`)\n        schemaComposer.createInputTC(`input Of${modelName}NumberInput { of: ${numberEnumName}}`)\n      }\n    }\n  }\n\n  protected addMetadataFields (schemaComposer: SchemaComposer<any>, models: ModelDefinition[]) {\n    const timeStampInputName = getInputName(Timestamp)\n    let timestampInputType: GraphQLInputObjectType\n    let timestampType: GraphQLScalarType\n    for (const model of models) {\n      const name = model.graphqlType.name\n      const modelTC = schemaComposer.getOTC(name)\n      const updateField = model.fields.updatedAt\n      const createAtField = model.fields.createdAt\n      const errorMessage = (field: string) => `${name} cannot contain custom \"${field}\" field since it is generated automatically.`\n\n      if (createAtField) {\n        throw new Error(errorMessage(\"createdAt\"))\n      }\n\n      if (updateField) {\n        throw new Error(errorMessage(\"updatedAt\"))\n      }\n\n      if (!timestampInputType) {\n        if (schemaComposer.has(Timestamp.name)) {\n          timestampInputType = schemaComposer.getITC(timeStampInputName).getType()\n        } else {\n          schemaComposer.createScalarTC(Timestamp)\n          timestampInputType = createInputTypeForScalar(Timestamp)\n          schemaComposer.add(timestampInputType)\n        }\n\n        timestampType = schemaComposer.getSTC(Timestamp.name).getType()\n      }\n\n      const metadataFields = createVersionedFields(timestampType)\n     \n      modelTC.addFields(metadataFields)\n\n      const inputType = schemaComposer.getITC(getInputTypeName(name, GraphbackOperationType.FIND))\n      if (inputType) {\n        const metadataInputFields = createVersionedInputFields(timestampInputType)\n        inputType.addFields(metadataInputFields)\n      }\n    };\n  }\n\n  /**\n   *\n   * Print schema as a string and format in one of the available languages\n   *\n   * @param {GraphQLSchema} schema\n   * @param {string} fileExtension\n   */\n  protected transformSchemaToString (schema: GraphQLSchema, fileExtension: string) {\n    const schemaString = printSchemaWithDirectives(schema)\n    if (this.pluginConfig) {\n      if (fileExtension === 'ts') {\n        return tsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'js') {\n        return jsSchemaFormatter.format(schemaString)\n      }\n      if (fileExtension === 'graphql') {\n        return gqlSchemaFormatter.format(schemaString)\n      }\n    }\n    throw Error(`Invalid format '${fileExtension}' specified. \\`options.format\\` supports only \\`ts\\`, \\`js\\` and \\`graphql\\` flags`)\n  }\n\n  /**\n   * Create Query resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addQueryResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    resolvers.Query = (resolvers.Query || {}) as IObjectTypeResolver\n\n    this.addFindOneQueryResolver(model, resolvers.Query)\n    this.addFindQueryResolver(model, resolvers.Query)\n  }\n\n  /**\n   * Create Mutation resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addMutationResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    resolvers.Mutation = (resolvers.Mutation || {}) as IObjectTypeResolver\n    this.addCreateMutationResolver(model, resolvers.Mutation)\n    this.addUpdateMutationResolver(model, resolvers.Mutation)\n    this.addUpdateByMutationResolver(model, resolvers.Mutation)\n    this.addDeleteMutationResolver(model, resolvers.Mutation)\n    this.addDeleteByMutationResolver(model, resolvers.Mutation)\n  }\n\n  /**\n   * Create Subscription resolver fields\n   *\n   * @param {ModelDefinition} model - The model definition with CRUD config and GraphQL typr\n   * @param {IResolvers} resolvers - root resolver object\n   */\n  protected addSubscriptionResolvers (model: ModelDefinition, resolvers: IResolvers) {\n    const modelType = model.graphqlType\n    resolvers.Subscription = (resolvers.Subscription || {}) as IObjectTypeResolver\n    this.addCreateSubscriptionResolver(modelType, resolvers.Subscription)\n    this.addUpdateSubscriptionResolver(modelType, resolvers.Subscription)\n    this.addDeleteSubscriptionResolver(modelType, resolvers.Subscription)\n  }\n\n  /**\n   * Creates a Create mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const resolverCreateField = getFieldName(modelName, GraphbackOperationType.CREATE)\n\n    mutationObj[resolverCreateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].create(args.input, context, info)\n    }\n  }\n\n  /**\n   * Creates an Update mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].update(args.input, context, info)\n    }\n  }\n\n  /**\n   * Creates an UpdateBy mutation resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateByMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const updateField = getFieldName(modelName, GraphbackOperationType.UPDATE_BY)\n\n    mutationObj[updateField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].updateBy(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a Delete Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].delete(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a DeleteBy Mutation resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteByMutationResolver (model: ModelDefinition, mutationObj: IObjectTypeResolver) {\n    const modelName = model.graphqlType.name\n    const deleteField = getFieldName(modelName, GraphbackOperationType.DELETE_BY)\n\n    mutationObj[deleteField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].deleteBy(args, context, info)\n    }\n  }\n\n  /**\n   * Creates a Find Query resolver field\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindQueryResolver (model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findField = getFieldName(modelName, GraphbackOperationType.FIND)\n\n    queryObj[findField] = async (_: any, args: FindByArgs, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      return await context.graphback[modelName].findBy(args, context, info, 'items')\n    }\n  }\n\n  /**\n   * Creates a FindOne Query resolver\n   *\n   * @param {ModelDefinition} model - Model definition object\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addFindOneQueryResolver (model: ModelDefinition, queryObj: IObjectTypeResolver) {\n    const modelType = model.graphqlType\n    const modelName = modelType.name\n    const findOneField = getFieldName(modelName, GraphbackOperationType.FIND_ONE)\n    const primaryKeyLabel = model.primaryKey.name\n\n    queryObj[findOneField] = (_: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      if (!context.graphback || !context.graphback[modelName]) {\n        throw new Error(`Missing service for ${modelName}`)\n      }\n\n      return context.graphback[modelName].findOne({ [primaryKeyLabel]: args.id }, context, info)\n    }\n  }\n\n  /**\n   * Creates a Create Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addCreateSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.CREATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToCreate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates an Update Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addUpdateSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.UPDATE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToUpdate(args.filter, context)\n      }\n    }\n  }\n\n  /**\n   * Creates a Delete Subscription resolver field\n   *\n   * @param {GraphQLObjectType} modelType - Model GraphQL object type\n   * @param {IFieldResolver} mutationObj - Mutation resolver object\n   */\n  protected addDeleteSubscriptionResolver (modelType: GraphQLObjectType, subscriptionObj: IObjectTypeResolver) {\n    const modelName = modelType.name\n    const operation = getSubscriptionName(modelName, GraphbackOperationType.DELETE)\n\n    subscriptionObj[operation] = {\n      subscribe: (_: any, args: any, context: GraphbackContext) => {\n        if (!context.graphback || !context.graphback[modelName]) {\n          throw new Error(`Missing service for ${modelName}`)\n        }\n\n        return context.graphback[modelName].subscribeToDelete(args.filter, context)\n      }\n    }\n  }\n\n  private createSchemaCRUDTypes (schemaComposer: SchemaComposer<any>) {\n    schemaComposer.add(PageRequest)\n    schemaComposer.add(IDScalarInputType)\n    schemaComposer.add(SortDirectionEnum)\n    schemaComposer.add(StringScalarInputType)\n    schemaComposer.add(BooleanScalarInputType)\n    schemaComposer.add(createInputTypeForScalar(GraphQLInt))\n    schemaComposer.add(createInputTypeForScalar(GraphQLFloat))\n\n    schemaComposer.forEach((tc: NamedTypeComposer<any>) => {\n      const namedType = tc.getType()\n      if (isScalarType(namedType) && !isSpecifiedScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) {\n        schemaComposer.add(createInputTypeForScalar(namedType))\n\n        return\n      }\n\n      const isRootType = ['Query', 'Subscription', 'Mutation'].includes(namedType.name)\n      if (isObjectType(namedType) && !isRootType) {\n        addCreateObjectInputType(schemaComposer, namedType)\n        addUpdateObjectInputType(schemaComposer, namedType)\n      }\n    })\n  }\n}\n","import { SchemaFormatter } from './SchemaFormatter'\n\nconst noteString = 'NOTE: This schema was generated by Rel and should not be changed manually'\n\n/**\n * Typescript string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const tsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nexport const schemaString = \\`\n${schemaString}\n\\`;\n`\n  }\n}\n\n/**\n * JS string template that formats schema into common js module that can be imported\n * easily in server side application\n */\nexport const jsSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `\n// ${noteString}\nconst schemaString = \\`\n${schemaString}\n\\`;\n\nmodule.exports = { schemaString };\n`\n  }\n}\n\n/**\n * GQL string template that returns schema in original form\n */\nexport const gqlSchemaFormatter: SchemaFormatter = {\n  format: (schemaString: string) => {\n    return `## ${noteString}\\n\\n${schemaString}`\n  }\n}\n","/* eslint-disable max-lines */\nimport { GraphQLInputObjectType, GraphQLNamedInputType, GraphQLList, GraphQLBoolean, GraphQLInt, GraphQLString, GraphQLID, GraphQLEnumType, GraphQLObjectType, GraphQLNonNull, GraphQLField, getNamedType, isScalarType, GraphQLInputFieldMap, GraphQLScalarType, GraphQLNamedType, GraphQLInputField, isEnumType, isObjectType, isInputObjectType, GraphQLInputType, getNullableType, isListType } from 'graphql'\nimport { GraphbackOperationType, getInputTypeName, getInputFieldName, getInputFieldTypeName, getPrimaryKey, ModelDefinition, FILTER_SUPPORTED_SCALARS, isAutoPrimaryKey } from '@graphback/core'\nimport { SchemaComposer } from 'graphql-compose'\nimport { copyWrappingType } from './copyWrappingType'\n\nconst PageRequestTypeName = 'PageRequest'\nconst SortDirectionEnumName = 'SortDirectionEnum'\nconst OrderByInputTypeName = 'OrderByInput'\n\nexport const getInputName = (type: GraphQLNamedType) => {\n  if (isEnumType(type)) {\n    return 'StringInput'\n  }\n\n  if (isInputObjectType(type)) {\n    return type.name\n  }\n\n  return `${type.name}Input`\n}\n\nexport const createInputTypeForScalar = (scalarType: GraphQLScalarType) => {\n  const newInput = new GraphQLInputObjectType({\n    name: getInputName(scalarType),\n    fields: {\n      ne: { type: scalarType },\n      eq: { type: scalarType },\n      le: { type: scalarType },\n      lt: { type: scalarType },\n      ge: { type: scalarType },\n      gt: { type: scalarType },\n      in: { type: GraphQLList(GraphQLNonNull(scalarType)) },\n      between: { type: GraphQLList(GraphQLNonNull(scalarType)) }\n    }\n  })\n\n  return newInput\n}\n\nexport const StringScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLString),\n  fields: {\n    ne: { type: GraphQLString },\n    eq: { type: GraphQLString },\n    le: { type: GraphQLString },\n    lt: { type: GraphQLString },\n    ge: { type: GraphQLString },\n    gt: { type: GraphQLString },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLString)) },\n    contains: { type: GraphQLString },\n    startsWith: { type: GraphQLString },\n    endsWith: { type: GraphQLString }\n  }\n})\n\nexport const IDScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLID),\n  fields: {\n    ne: { type: GraphQLID },\n    eq: { type: GraphQLID },\n    le: { type: GraphQLID },\n    lt: { type: GraphQLID },\n    ge: { type: GraphQLID },\n    gt: { type: GraphQLID },\n    in: { type: GraphQLList(GraphQLNonNull(GraphQLID)) }\n  }\n})\n\nexport const BooleanScalarInputType = new GraphQLInputObjectType({\n  name: getInputName(GraphQLBoolean),\n  fields: {\n    ne: { type: GraphQLBoolean },\n    eq: { type: GraphQLBoolean }\n  }\n})\n\nexport const PageRequest = new GraphQLInputObjectType({\n  name: PageRequestTypeName,\n  fields: {\n    limit: {\n      type: GraphQLInt\n    },\n    offset: {\n      type: GraphQLInt\n    }\n  }\n})\n\nexport const SortDirectionEnum = new GraphQLEnumType({\n  name: SortDirectionEnumName,\n  values: {\n    DESC: { value: 'desc' },\n    ASC: { value: 'asc' }\n  }\n})\n\nexport const buildOrderByInputType = (modelName) => {\n  return new GraphQLInputObjectType({\n    name: modelName+ \"OrderByInput\",\n    fields: {\n      field: { type: modelName + \"FieldsEnum\" },\n      order: { type: SortDirectionEnum, defaultValue: 'asc' }\n    }\n  })\n}\n\nexport const OrderByInputType = new GraphQLInputObjectType({\n  name: OrderByInputTypeName,\n  fields: {\n    field: { type: GraphQLNonNull(GraphQLString) },\n    order: { type: SortDirectionEnum, defaultValue: 'asc' }\n  }\n})\n\nfunction getModelInputFields (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType, operationType: GraphbackOperationType): GraphQLInputField[] {\n  const inputFields: GraphQLInputField[] = []\n  const fields: Array<GraphQLField<any, any>> = Object.values(modelType.getFields())\n\n  for (const field of fields) {\n    const typeName = getInputFieldTypeName(modelType.name, field, operationType)\n    if (!typeName) {\n      continue\n    }\n    if(field?.extensions?.directives?.some?.(d => [\"computed\",\"transient\"].includes(d.name))) {\n      continue\n    }\n\n    const name = getInputFieldName(field)\n    const type = schemaComposer.getAnyTC(typeName).getType()\n    const wrappedType = copyWrappingType(field.type, type) as GraphQLInputType\n\n    const extensions = {}\n\n    const constraintDirective = field?.extensions?.directives?.find?.(d => d.name === \"constraint\")\n\n    if(constraintDirective) {\n      extensions.directives = [constraintDirective]\n    }\n\n    const inputField: GraphQLInputField = {\n      name,\n      type: wrappedType,\n      description: undefined,\n      extensions,\n      deprecationReason: field.deprecationReason\n    }\n    inputFields.push(inputField)\n  }\n\n  return inputFields\n}\n\nexport function buildFindOneFieldMap (modelType: ModelDefinition, schemaComposer: SchemaComposer<any>): GraphQLInputFieldMap {\n  const { type } = modelType.primaryKey\n\n  return {\n    _id: {\n      name: '_id',\n      type: GraphQLNonNull(schemaComposer.getAnyTC(type).getType()),\n      description: undefined,\n      extensions: undefined,\n      deprecationReason: undefined\n    }\n  }\n}\n\nexport const buildFilterInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.FIND\n\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const inputFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const scalarInputFields: any = {}\n\n  for (const field of inputFields) {\n    const namedType = getNamedType(field.type)\n\n    if (FILTER_SUPPORTED_SCALARS.includes(namedType.name) || isEnumType(namedType)) {\n      const type = getInputName(namedType)\n      scalarInputFields[field.name] = {\n        name: field.name,\n        type\n      }\n    }\n  }\n\n  const filterInput = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: {\n      ...scalarInputFields,\n      and: {\n        type: `[${inputTypeName}!]`\n      },\n      or: {\n        type: `[${inputTypeName}!]`\n      },\n      not: {\n        type: `${inputTypeName}`\n      }\n    }\n  })\n\n  schemaComposer.add(filterInput)\n}\n\nexport const buildCreateMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.CREATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const mutationInputType = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: () => {\n      const fields: any = {}\n      for (const field of allModelFields) {\n        if (field.name === idField.name && isAutoPrimaryKey(field)) {\n          continue\n        }\n\n        fields[field.name] = {\n          name: field.name,\n          type: field.type,\n          extensions: field.extensions\n        }\n      }\n\n      return fields\n    }\n  })\n\n  schemaComposer.add(mutationInputType)\n}\n\nexport const buildSubscriptionFilterType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const inputTypeName = getInputTypeName(modelType.name, GraphbackOperationType.SUBSCRIPTION_CREATE)\n  const modelFields = Object.values(modelType.getFields())\n  const subscriptionFilterFields = modelFields.filter((f: GraphQLField<any, any>) => {\n    const namedType = getNamedType(f.type)\n    return !f.extensions?.directives?.some?.(d => [\"transient\", \"computed\"].includes(d.name)) && (isScalarType(namedType) && FILTER_SUPPORTED_SCALARS.includes(namedType.name)) || isEnumType(namedType)\n  })\n\n  const fields = {\n    and: {\n      type: `[${inputTypeName}!]`\n    },\n    or: {\n      type: `[${inputTypeName}!]`\n    },\n    not: {\n      type: `${inputTypeName}`\n    }\n  }\n  for (const { name, type } of subscriptionFilterFields) {\n    const fieldType: GraphQLNamedType = getNamedType(type)\n    const inputFilterName = getInputName(fieldType)\n\n    fields[name] = {\n      name,\n      type: schemaComposer.get(inputFilterName)\n    }\n  }\n\n  schemaComposer.createInputTC({\n    name: inputTypeName,\n    fields\n  })\n}\n\nexport const buildMutationInputType = (schemaComposer: SchemaComposer<any>, modelType: GraphQLObjectType) => {\n  const operationType = GraphbackOperationType.UPDATE\n  const inputTypeName = getInputTypeName(modelType.name, operationType)\n\n  const idField = getPrimaryKey(modelType)\n  const allModelFields = getModelInputFields(schemaComposer, modelType, operationType)\n\n  const mutationInputObject = new GraphQLInputObjectType({\n    name: inputTypeName,\n    fields: () => {\n      const fields: any = {}\n      for (const { name, type,extensions } of allModelFields) {\n        let fieldType: GraphQLInputType\n\n        if (name !== idField.name) {\n          fieldType = getNullableType(type)\n        }\n\n        if (isListType(fieldType)) {\n          fieldType = GraphQLList(getNamedType(fieldType))\n        }\n\n        fields[name] = {\n          name,\n          type: fieldType || type,\n          extensions\n        }\n      }\n\n      return fields\n    }\n  })\n\n  schemaComposer.add(mutationInputObject)\n}\n\nfunction mapObjectInputFields (schemaComposer: SchemaComposer<any>, fields: Array<GraphQLField<any, any>>, objectName: string): GraphQLInputField[] {\n  return fields.map((field: GraphQLField<any, any>) => {\n    let namedType = getNamedType(field.type) as GraphQLNamedInputType\n    let typeName = namedType.name\n\n    let inputType\n    if (isObjectType(namedType)) {\n      typeName = getInputTypeName(typeName, GraphbackOperationType.CREATE)\n      namedType = schemaComposer.getOrCreateITC(typeName).getType()\n\n      inputType = copyWrappingType(field.type, namedType)\n    }\n\n    return {\n      name: field.name,\n      type: inputType || field.type,\n      extensions: {},\n      deprecationReason: field.deprecationReason\n    }\n  })\n}\n\nexport function addCreateObjectInputType (schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.CREATE\n\n  const inputType = new GraphQLInputObjectType({\n    name: getInputTypeName(objectType.name, operationType),\n    fields: mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n      .reduce((fieldObj: any, { name, type, description }: any) => {\n        fieldObj[name] = { type, description }\n\n        return fieldObj\n      }, {})\n  })\n\n  schemaComposer.add(inputType)\n}\n\nexport function addUpdateObjectInputType (schemaComposer: SchemaComposer<any>, objectType: GraphQLObjectType) {\n  const objectFields = Object.values(objectType.getFields())\n  const operationType = GraphbackOperationType.UPDATE\n\n  const inputType = new GraphQLInputObjectType({\n    name: getInputTypeName(objectType.name, operationType),\n    fields: mapObjectInputFields(schemaComposer, objectFields, objectType.name)\n      .reduce((fieldObj: any, { name, type, description }: any) => {\n        fieldObj[name] = { type: getNullableType(type), description }\n\n        return fieldObj\n      }, {})\n  })\n\n  schemaComposer.add(inputType)\n}\n\nexport const createMutationListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}MutationResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      }\n    }\n  })\n}\n\nexport const createModelListResultType = (modelType: GraphQLObjectType) => {\n  return new GraphQLObjectType({\n    name: `${modelType.name}ResultList`,\n    fields: {\n      items: {\n        type: GraphQLNonNull(GraphQLList(modelType))\n      },\n      offset: { type: GraphQLInt },\n      limit: { type: GraphQLInt },\n      count: { type: GraphQLInt }\n    }\n  })\n}\n\nexport function createVersionedInputFields (versionedInputType: GraphQLInputObjectType) {\n  return {\n    createdAt: {\n      type: versionedInputType\n    },\n    updatedAt: {\n      type: versionedInputType\n    }\n  }\n}\n\nexport function createVersionedFields (type: GraphQLScalarType) {\n  return {\n    createdAt: {\n      type,\n    },\n    updatedAt: {\n      type,\n    }\n  }\n}\n","import { isWrappingType, GraphQLNonNull, isListType, GraphQLList, GraphQLType, getNamedType, GraphQLInputType, GraphQLOutputType } from 'graphql'\n\ntype WrappingTypeName = 'GraphQLList' | 'GraphQLNonNull'\ntype InputOrOutTypeType = GraphQLInputType | GraphQLOutputType\n\n/**\n * Copies the wrapping type(s) from one GraphQLType to another\n *\n * @param {GraphQLType} copyFromType - Get the wrapping types from this type\n * @param {GraphQLType} copyToType - Add the wrapping types to this type\n */\nexport function copyWrappingType (copyFromType: InputOrOutTypeType, copyToType: InputOrOutTypeType): InputOrOutTypeType {\n  const wrappers: WrappingTypeName[] = []\n\n  let oldTypeCopy = copyFromType\n  while (isWrappingType(oldTypeCopy)) {\n    if (isListType(oldTypeCopy)) {\n      wrappers.push('GraphQLList')\n    } else {\n      wrappers.push('GraphQLNonNull')\n    }\n    oldTypeCopy = oldTypeCopy.ofType\n  }\n\n  let namedNewType: GraphQLType = getNamedType(copyToType)\n  while (wrappers.length > 0) {\n    const wrappingType = wrappers.pop()\n    if (wrappingType === 'GraphQLList') {\n      namedNewType = GraphQLList(namedNewType)\n    } else {\n      namedNewType = GraphQLNonNull(namedNewType)\n    }\n  }\n\n  return namedNewType\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;;;ACJA,IAAM,aAAa;AAMZ,IAAM,oBAAqC;AAAA,EAChD,QAAQ,CAAC,iBAAyB;AAChC,WAAO;AAAA,KACN;AAAA;AAAA,EAEH;AAAA;AAAA;AAAA;AAAA;AAUK,IAAM,oBAAqC;AAAA,EAChD,QAAQ,CAAC,iBAAyB;AAChC,WAAO;AAAA,KACN;AAAA;AAAA,EAEH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWK,IAAM,qBAAsC;AAAA,EACjD,QAAQ,CAAC,iBAAyB;AAChC,WAAO,MAAM;AAAA;AAAA,EAAiB;AAAA;AAAA;;;ACxClC;AACA;;;ACFA;AAWO,0BAA2B,cAAkC,YAAoD;AACtH,QAAM,WAA+B;AAErC,MAAI,cAAc;AAClB,SAAO,eAAe,cAAc;AAClC,QAAI,WAAW,cAAc;AAC3B,eAAS,KAAK;AAAA,WACT;AACL,eAAS,KAAK;AAAA;AAEhB,kBAAc,YAAY;AAAA;AAG5B,MAAI,eAA4B,aAAa;AAC7C,SAAO,SAAS,SAAS,GAAG;AAC1B,UAAM,eAAe,SAAS;AAC9B,QAAI,iBAAiB,eAAe;AAClC,qBAAe,YAAY;AAAA,WACtB;AACL,qBAAe,eAAe;AAAA;AAAA;AAIlC,SAAO;AAAA;;;AD5BT,IAAM,sBAAsB;AAC5B,IAAM,wBAAwB;AAC9B,IAAM,uBAAuB;AAEtB,IAAM,eAAe,CAAC,SAA2B;AACtD,MAAI,WAAW,OAAO;AACpB,WAAO;AAAA;AAGT,MAAI,kBAAkB,OAAO;AAC3B,WAAO,KAAK;AAAA;AAGd,SAAO,GAAG,KAAK;AAAA;AAGV,IAAM,2BAA2B,CAAC,eAAkC;AACzE,QAAM,WAAW,IAAI,uBAAuB;AAAA,IAC1C,MAAM,aAAa;AAAA,IACnB,QAAQ;AAAA,MACN,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM;AAAA,MACZ,IAAI,EAAE,MAAM,aAAY,gBAAe;AAAA,MACvC,SAAS,EAAE,MAAM,aAAY,gBAAe;AAAA;AAAA;AAIhD,SAAO;AAAA;AAGF,IAAM,wBAAwB,IAAI,uBAAuB;AAAA,EAC9D,MAAM,aAAa;AAAA,EACnB,QAAQ;AAAA,IACN,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM,aAAY,gBAAe;AAAA,IACvC,UAAU,EAAE,MAAM;AAAA,IAClB,YAAY,EAAE,MAAM;AAAA,IACpB,UAAU,EAAE,MAAM;AAAA;AAAA;AAIf,IAAM,oBAAoB,IAAI,uBAAuB;AAAA,EAC1D,MAAM,aAAa;AAAA,EACnB,QAAQ;AAAA,IACN,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM,aAAY,gBAAe;AAAA;AAAA;AAIpC,IAAM,yBAAyB,IAAI,uBAAuB;AAAA,EAC/D,MAAM,aAAa;AAAA,EACnB,QAAQ;AAAA,IACN,IAAI,EAAE,MAAM;AAAA,IACZ,IAAI,EAAE,MAAM;AAAA;AAAA;AAIT,IAAM,cAAc,IAAI,uBAAuB;AAAA,EACpD,MAAM;AAAA,EACN,QAAQ;AAAA,IACN,OAAO;AAAA,MACL,MAAM;AAAA;AAAA,IAER,QAAQ;AAAA,MACN,MAAM;AAAA;AAAA;AAAA;AAKL,IAAM,oBAAoB,IAAI,gBAAgB;AAAA,EACnD,MAAM;AAAA,EACN,QAAQ;AAAA,IACN,MAAM,EAAE,OAAO;AAAA,IACf,KAAK,EAAE,OAAO;AAAA;AAAA;AAIX,IAAM,wBAAwB,CAAC,cAAc;AAClD,SAAO,IAAI,uBAAuB;AAAA,IAChC,MAAM,YAAW;AAAA,IACjB,QAAQ;AAAA,MACN,OAAO,EAAE,MAAM,YAAY;AAAA,MAC3B,OAAO,EAAE,MAAM,mBAAmB,cAAc;AAAA;AAAA;AAAA;AAK/C,IAAM,mBAAmB,IAAI,uBAAuB;AAAA,EACzD,MAAM;AAAA,EACN,QAAQ;AAAA,IACN,OAAO,EAAE,MAAM,gBAAe;AAAA,IAC9B,OAAO,EAAE,MAAM,mBAAmB,cAAc;AAAA;AAAA;AAIpD,6BAA8B,gBAAqC,WAA8B,eAA4D;AAnH7J;AAoHE,QAAM,cAAmC;AACzC,QAAM,SAAwC,OAAO,OAAO,UAAU;AAEtE,aAAW,SAAS,QAAQ;AAC1B,UAAM,WAAW,sBAAsB,UAAU,MAAM,OAAO;AAC9D,QAAI,CAAC,UAAU;AACb;AAAA;AAEF,QAAG,iDAAO,eAAP,mBAAmB,eAAnB,mBAA+B,SAA/B,4BAAsC,OAAK,CAAC,YAAW,aAAa,SAAS,EAAE,QAAQ;AACxF;AAAA;AAGF,UAAM,OAAO,kBAAkB;AAC/B,UAAM,OAAO,eAAe,SAAS,UAAU;AAC/C,UAAM,cAAc,iBAAiB,MAAM,MAAM;AAEjD,UAAM,aAAa;AAEnB,UAAM,sBAAsB,iDAAO,eAAP,mBAAmB,eAAnB,mBAA+B,SAA/B,4BAAsC,OAAK,EAAE,SAAS;AAElF,QAAG,qBAAqB;AACtB,iBAAW,aAAa,CAAC;AAAA;AAG3B,UAAM,aAAgC;AAAA,MACpC;AAAA,MACA,MAAM;AAAA,MACN,aAAa;AAAA,MACb;AAAA,MACA,mBAAmB,MAAM;AAAA;AAE3B,gBAAY,KAAK;AAAA;AAGnB,SAAO;AAAA;AAGF,8BAA+B,WAA4B,gBAA2D;AAC3H,QAAM,EAAE,SAAS,UAAU;AAE3B,SAAO;AAAA,IACL,KAAK;AAAA,MACH,MAAM;AAAA,MACN,MAAM,gBAAe,eAAe,SAAS,MAAM;AAAA,MACnD,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,mBAAmB;AAAA;AAAA;AAAA;AAKlB,IAAM,uBAAuB,CAAC,gBAAqC,cAAiC;AACzG,QAAM,gBAAgB,uBAAuB;AAE7C,QAAM,gBAAgB,iBAAiB,UAAU,MAAM;AAEvD,QAAM,cAAc,oBAAoB,gBAAgB,WAAW;AAEnE,QAAM,oBAAyB;AAE/B,aAAW,SAAS,aAAa;AAC/B,UAAM,YAAY,cAAa,MAAM;AAErC,QAAI,yBAAyB,SAAS,UAAU,SAAS,WAAW,YAAY;AAC9E,YAAM,OAAO,aAAa;AAC1B,wBAAkB,MAAM,QAAQ;AAAA,QAC9B,MAAM,MAAM;AAAA,QACZ;AAAA;AAAA;AAAA;AAKN,QAAM,cAAc,IAAI,uBAAuB;AAAA,IAC7C,MAAM;AAAA,IACN,QAAQ,iCACH,oBADG;AAAA,MAEN,KAAK;AAAA,QACH,MAAM,IAAI;AAAA;AAAA,MAEZ,IAAI;AAAA,QACF,MAAM,IAAI;AAAA;AAAA,MAEZ,KAAK;AAAA,QACH,MAAM,GAAG;AAAA;AAAA;AAAA;AAKf,iBAAe,IAAI;AAAA;AAGd,IAAM,+BAA+B,CAAC,gBAAqC,cAAiC;AACjH,QAAM,gBAAgB,uBAAuB;AAC7C,QAAM,gBAAgB,iBAAiB,UAAU,MAAM;AAEvD,QAAM,UAAU,cAAc;AAC9B,QAAM,iBAAiB,oBAAoB,gBAAgB,WAAW;AAEtE,QAAM,oBAAoB,IAAI,uBAAuB;AAAA,IACnD,MAAM;AAAA,IACN,QAAQ,MAAM;AACZ,YAAM,SAAc;AACpB,iBAAW,SAAS,gBAAgB;AAClC,YAAI,MAAM,SAAS,QAAQ,QAAQ,iBAAiB,QAAQ;AAC1D;AAAA;AAGF,eAAO,MAAM,QAAQ;AAAA,UACnB,MAAM,MAAM;AAAA,UACZ,MAAM,MAAM;AAAA,UACZ,YAAY,MAAM;AAAA;AAAA;AAItB,aAAO;AAAA;AAAA;AAIX,iBAAe,IAAI;AAAA;AAGd,IAAM,8BAA8B,CAAC,gBAAqC,cAAiC;AAChH,QAAM,gBAAgB,iBAAiB,UAAU,MAAM,uBAAuB;AAC9E,QAAM,cAAc,OAAO,OAAO,UAAU;AAC5C,QAAM,2BAA2B,YAAY,OAAO,CAAC,MAA8B;AAhPrF;AAiPI,UAAM,YAAY,cAAa,EAAE;AACjC,WAAO,CAAC,qBAAE,eAAF,mBAAc,eAAd,mBAA0B,SAA1B,4BAAiC,OAAK,CAAC,aAAa,YAAY,SAAS,EAAE,WAAW,cAAa,cAAc,yBAAyB,SAAS,UAAU,UAAU,WAAW;AAAA;AAG5L,QAAM,SAAS;AAAA,IACb,KAAK;AAAA,MACH,MAAM,IAAI;AAAA;AAAA,IAEZ,IAAI;AAAA,MACF,MAAM,IAAI;AAAA;AAAA,IAEZ,KAAK;AAAA,MACH,MAAM,GAAG;AAAA;AAAA;AAGb,aAAW,EAAE,MAAM,UAAU,0BAA0B;AACrD,UAAM,YAA8B,cAAa;AACjD,UAAM,kBAAkB,aAAa;AAErC,WAAO,QAAQ;AAAA,MACb;AAAA,MACA,MAAM,eAAe,IAAI;AAAA;AAAA;AAI7B,iBAAe,cAAc;AAAA,IAC3B,MAAM;AAAA,IACN;AAAA;AAAA;AAIG,IAAM,yBAAyB,CAAC,gBAAqC,cAAiC;AAC3G,QAAM,gBAAgB,uBAAuB;AAC7C,QAAM,gBAAgB,iBAAiB,UAAU,MAAM;AAEvD,QAAM,UAAU,cAAc;AAC9B,QAAM,iBAAiB,oBAAoB,gBAAgB,WAAW;AAEtE,QAAM,sBAAsB,IAAI,uBAAuB;AAAA,IACrD,MAAM;AAAA,IACN,QAAQ,MAAM;AACZ,YAAM,SAAc;AACpB,iBAAW,EAAE,MAAM,MAAK,gBAAgB,gBAAgB;AACtD,YAAI;AAEJ,YAAI,SAAS,QAAQ,MAAM;AACzB,sBAAY,gBAAgB;AAAA;AAG9B,YAAI,YAAW,YAAY;AACzB,sBAAY,aAAY,cAAa;AAAA;AAGvC,eAAO,QAAQ;AAAA,UACb;AAAA,UACA,MAAM,aAAa;AAAA,UACnB;AAAA;AAAA;AAIJ,aAAO;AAAA;AAAA;AAIX,iBAAe,IAAI;AAAA;AAGrB,8BAA+B,gBAAqC,QAAuC,YAAyC;AAClJ,SAAO,OAAO,IAAI,CAAC,UAAkC;AACnD,QAAI,YAAY,cAAa,MAAM;AACnC,QAAI,WAAW,UAAU;AAEzB,QAAI;AACJ,QAAI,aAAa,YAAY;AAC3B,iBAAW,iBAAiB,UAAU,uBAAuB;AAC7D,kBAAY,eAAe,eAAe,UAAU;AAEpD,kBAAY,iBAAiB,MAAM,MAAM;AAAA;AAG3C,WAAO;AAAA,MACL,MAAM,MAAM;AAAA,MACZ,MAAM,aAAa,MAAM;AAAA,MACzB,YAAY;AAAA,MACZ,mBAAmB,MAAM;AAAA;AAAA;AAAA;AAKxB,kCAAmC,gBAAqC,YAA+B;AAC5G,QAAM,eAAe,OAAO,OAAO,WAAW;AAC9C,QAAM,gBAAgB,uBAAuB;AAE7C,QAAM,YAAY,IAAI,uBAAuB;AAAA,IAC3C,MAAM,iBAAiB,WAAW,MAAM;AAAA,IACxC,QAAQ,qBAAqB,gBAAgB,cAAc,WAAW,MACnE,OAAO,CAAC,UAAe,EAAE,MAAM,MAAM,kBAAuB;AAC3D,eAAS,QAAQ,EAAE,MAAM;AAEzB,aAAO;AAAA,OACN;AAAA;AAGP,iBAAe,IAAI;AAAA;AAGd,kCAAmC,gBAAqC,YAA+B;AAC5G,QAAM,eAAe,OAAO,OAAO,WAAW;AAC9C,QAAM,gBAAgB,uBAAuB;AAE7C,QAAM,YAAY,IAAI,uBAAuB;AAAA,IAC3C,MAAM,iBAAiB,WAAW,MAAM;AAAA,IACxC,QAAQ,qBAAqB,gBAAgB,cAAc,WAAW,MACnE,OAAO,CAAC,UAAe,EAAE,MAAM,MAAM,kBAAuB;AAC3D,eAAS,QAAQ,EAAE,MAAM,gBAAgB,OAAO;AAEhD,aAAO;AAAA,OACN;AAAA;AAGP,iBAAe,IAAI;AAAA;AAGd,IAAM,+BAA+B,CAAC,cAAiC;AAC5E,SAAO,IAAI,kBAAkB;AAAA,IAC3B,MAAM,GAAG,UAAU;AAAA,IACnB,QAAQ;AAAA,MACN,OAAO;AAAA,QACL,MAAM,gBAAe,aAAY;AAAA;AAAA;AAAA;AAAA;AAMlC,IAAM,4BAA4B,CAAC,cAAiC;AACzE,SAAO,IAAI,kBAAkB;AAAA,IAC3B,MAAM,GAAG,UAAU;AAAA,IACnB,QAAQ;AAAA,MACN,OAAO;AAAA,QACL,MAAM,gBAAe,aAAY;AAAA;AAAA,MAEnC,QAAQ,EAAE,MAAM;AAAA,MAChB,OAAO,EAAE,MAAM;AAAA,MACf,OAAO,EAAE,MAAM;AAAA;AAAA;AAAA;AAKd,oCAAqC,oBAA4C;AACtF,SAAO;AAAA,IACL,WAAW;AAAA,MACT,MAAM;AAAA;AAAA,IAER,WAAW;AAAA,MACT,MAAM;AAAA;AAAA;AAAA;AAKL,+BAAgC,MAAyB;AAC9D,SAAO;AAAA,IACL,WAAW;AAAA,MACT;AAAA;AAAA,IAEF,WAAW;AAAA,MACT;AAAA;AAAA;AAAA;;;AFjYC,IAAM,0BAA0B;AAgBhC,qCAA+B,gBAAgB;AAAA,EACnC;AAAA,EAEV,YAAa,cAAuC;AACzD;AACA,SAAK,eAAe,mBACf;AAAA;AAAA,EAIA,gBAAiB,UAAgD;AACtE,UAAM,SAAS,SAAS;AAExB,UAAM,SAAS,SAAS;AACxB,QAAI,OAAO,WAAW,GAAG;AACvB,WAAK,WAAW;AAEhB,aAAO;AAAA;AACR;AAED,UAAM,iBAAiB,IAAI,eAAe;AAC1C,SAAK,gCAAgC,gBAAgB;AACrD,SAAK,qBAAqB,gBAAgB;AAC1C,SAAK,kBAAkB,gBAAgB;AAEvC,WAAO,eAAe;AAAA;AAAA,EAQjB,gBAAiB,UAA6C;AACnE,UAAM,SAAS,SAAS;AAExB,QAAI,OAAO,WAAW,GAAG;AACvB,aAAO;AAAA;AAGT,UAAM,YAAwB;AAG9B,UAAM,SAAS,SAAS;AACxB,eAAW,mBAAmB,uBAAuB;AACnD,UAAI,OAAO,QAAQ,gBAAgB,OAAO;AACxC,kBAAU,gBAAgB,QAAQ;AAAA;AAAA;AAItC,UAAM,6BAA6B,OAChC,OAAO,CAAC,KAAU,UAA2B;AAC5C,aAAO,iCACF,MADE;AAAA,SAEJ,MAAM,YAAY,OAAO;AAAA;AAAA,OAE3B;AAEL,eAAW,SAAS,QAAQ;AAC1B,WAAK,kBAAkB,OAAO;AAC9B,WAAK,qBAAqB,OAAO;AACjC,WAAK,yBAAyB,OAAO;AAAA;AAGvC,WAAO;AAAA;AAAA,EAGF,gBAAiB,UAAuC;AAC7D,QAAI,CAAC,KAAK,aAAa,YAAY;AACjC;AAAA;AAGF,QAAI,aAAa,QAAQ,KAAK,aAAa;AAI3C,QAAI,CAAC,WAAW,SAAS,MAAM;AAC7B,mBAAa,KAAK,YAAY;AAAA;AAIhC,UAAM,gBAAgB,WAAW,MAAM,KAAK;AAE5C,UAAM,eAAe,KAAK,wBAAwB,SAAS,aAAa;AAExE,UAAM,YAAY,QAAQ,QAAQ,KAAK,aAAa;AAEpD,QAAI,CAAC,WAAW,YAAY;AAC1B,gBAAU,WAAW,EAAE,WAAW;AAAA;AAGpC,kBAAc,YAAY;AAAA;AAAA,EAGrB,gBAAiB;AACtB,WAAO;AAAA;AAAA,EAGC,qBAAsB,gBAAqC,QAA2B;AAC9F,SAAK,sBAAsB;AAE3B,eAAW,SAAS,OAAO,OAAO,SAAS;AACzC,YAAM,YAAY,MAAM,YAAY;AACpC,UAAI,eAAe,eAAe,OAAO;AACzC,YAAM,eAAe,CAAC,UAAkB,GAAG,oCAAoC;AAE/E,UAAG,MAAM,OAAO,IAAI;AAClB,cAAM,IAAI,MAAM,aAAa;AAAA;AAG/B,UAAG,MAAM,OAAO,UAAU;AACxB,cAAM,IAAI,MAAM,aAAa;AAAA;AAG/B,mBAAa,UAAU;AAAA,QACrB,KAAK;AAAA,UACH,MAAM;AAAA;AAAA;AAGV,WAAK,cAAc,OAAO;AAC1B,WAAK,gBAAgB,OAAO;AAC5B,WAAK,oBAAoB,OAAO;AAChC,qBAAe,eAAe,OAAO;AAAA;AAAA;AAAA,EAI/B,oBAAqB,OAAwB,gBAAqC;AAC1F,UAAM,OAAO,MAAM,YAAY;AAC/B,UAAM,UAAU,eAAe,OAAO;AACtC,UAAM,YAAY,QAAQ;AAE1B,gCAA4B,gBAAgB;AAE5C,UAAM,qBAAqB;AAC3B,QAAI,YAAY,oBAAoB,MAAM,wBAAuB;AAEjE,QAAI,kBAAkB,kBAAiB,MAAM,wBAAuB;AACpE,UAAM,2BAA2B,eAAe,OAAO,iBAAiB;AAExE,uBAAmB,aAAa;AAAA,MAC9B,MAAM,gBAAe;AAAA,MACrB,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA;AAAA;AAKZ,gBAAY,oBAAoB,MAAM,wBAAuB;AAE7D,sBAAkB,kBAAiB,MAAM,wBAAuB;AAChE,UAAM,2BAA2B,eAAe,OAAO,iBAAiB;AAExE,uBAAmB,aAAa;AAAA,MAC9B,MAAM,gBAAe;AAAA,MACrB,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA;AAAA;AAKZ,gBAAY,oBAAoB,MAAM,wBAAuB;AAE7D,sBAAkB,kBAAiB,MAAM,wBAAuB;AAChE,UAAM,2BAA2B,eAAe,OAAO,iBAAiB;AAExE,uBAAmB,aAAa;AAAA,MAC9B,MAAM,gBAAe;AAAA,MACrB,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA;AAAA;AAKZ,mBAAe,aAAa,UAAU;AAAA;AAAA,EAG9B,aAAc,YAAiB,eAAoB,mBAAwB;AACnF,UAAM,YAAY,IAAI,mBAAkB;AAAA,MACtC,MAAM;AAAA,MACN,QAAQ,MAAO;AAAA;AAGjB,QAAI;AACJ,QAAI,OAAO,KAAK,eAAe,WAAW,GAAG;AAC3C,qBAAe,IAAI,mBAAkB;AAAA,QACnC,MAAM;AAAA,QACN,QAAQ,MAAO;AAAA;AAAA;AAInB,QAAI;AACJ,QAAI,OAAO,KAAK,mBAAmB,WAAW,GAAG;AAC/C,yBAAmB,IAAI,mBAAkB;AAAA,QACvC,MAAM;AAAA,QACN,QAAQ,MAAO;AAAA;AAAA;AAInB,WAAO,IAAI,cAAc;AAAA,MACvB,OAAO;AAAA,MACP,UAAU;AAAA,MACV,cAAc;AAAA;AAAA;AAAA,EAIR,gBAAiB,OAAwB,gBAAqC;AACtF,UAAM,OAAO,MAAM,YAAY;AAC/B,UAAM,UAAU,eAAe,OAAO;AACtC,UAAM,YAAY,QAAQ;AAC1B,UAAM,iBAAiB,6BAA6B;AACpD,2BAAuB,gBAAgB;AAEvC,UAAM,iBAAiB;AACvB,QAAI,gBAAgB,wBAAuB;AAE3C,iCAA6B,gBAAgB;AAE7C,QAAI,gBAAgB,kBAAiB,MAAM;AAC3C,UAAM,0BAA0B,eAAe,OAAO,eAAe;AAErE,QAAI,YAAY,aAAa,MAAM;AACnC,mBAAe,aAAa;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,OAAO;AAAA,UACL,MAAM,gBAAe;AAAA;AAAA;AAAA;AAI3B,oBAAgB,wBAAuB;AACvC,gBAAY,aAAa,MAAM;AAE/B,oBAAgB,kBAAiB,MAAM;AACvC,QAAI,0BAA0B,eAAe,OAAO,eAAe;AAEnE,mBAAe,aAAa;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,OAAO;AAAA,UACL,MAAM,gBAAe;AAAA;AAAA;AAAA;AAI3B,oBAAgB,wBAAuB;AACvC,gBAAY,aAAa,MAAM;AAE/B,oBAAgB,kBAAiB,MAAM;AACvC,8BAA0B,eAAe,OAAO,eAAe;AAC/D,QAAI,kBAAkB,eAAe,OAAO,kBAAiB,MAAM,wBAAuB,OAAO;AAEjG,mBAAe,aAAa;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA,QAER,OAAO;AAAA,UACL,MAAM,gBAAe;AAAA;AAAA;AAAA;AAK3B,oBAAgB,wBAAuB;AACvC,gBAAY,aAAa,MAAM;AAE/B,oBAAgB,kBAAiB,MAAM;AACvC,mBAAe,aAAa;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM,qBAAqB,OAAO;AAAA;AAGpC,oBAAgB,wBAAuB;AACvC,gBAAY,aAAa,MAAM;AAE/B,oBAAgB,kBAAiB,MAAM;AACvC,sBAAkB,eAAe,OAAO,kBAAiB,MAAM,wBAAuB,OAAO;AAC7F,mBAAe,aAAa;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA;AAAA;AAKZ,mBAAe,SAAS,UAAU;AAAA;AAAA,EAG1B,cAAe,OAAwB,gBAAqC;AACpF,UAAM,OAAO,MAAM,YAAY;AAC/B,UAAM,UAAU,eAAe,OAAO;AACtC,UAAM,YAAY,QAAQ;AAC1B,UAAM,YAAY;AAClB,UAAM,eAAe,CAAC,OAAO,OAAO,OAAO;AAC3C,cAAU,QAAQ;AAAA,MAChB,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,IAAI;AAAA,UACF,MAAM,KAAK;AAAA;AAAA,QAEb,UAAU;AAAA,UACR,MAAM;AAAA;AAAA;AAAA,MAGV,YAAY;AAAA,QACV,YAAY;AAAA,UACV,WAAW;AAAA;AAAA;AAAA;AAIjB,QAAG,eAAe,IAAI,KAAK,oBAAoB;AAC7C,mBAAa,QAAQ,SAAO;AAC1B,kBAAU,OAAO;AAAA,UACf,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,IAAI;AAAA,cACF,MAAM,KAAK;AAAA;AAAA,YAEb,UAAU;AAAA,cACR,MAAM;AAAA;AAAA;AAAA,UAGV,YAAY;AAAA,YACV,YAAY;AAAA,cACV,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAMrB,YAAQ,UAAU;AAElB,yBAAqB,gBAAgB;AAErC,UAAM,cAAc;AACpB,QAAI,YAAY,aAAa,MAAM,wBAAuB;AAC1D,gBAAY,aAAa;AAAA,MACvB,MAAM,MAAM;AAAA,MACZ,MAAM,qBAAqB,OAAO;AAAA;AAGpC,UAAM,gBAAgB,wBAAuB;AAC7C,gBAAY,aAAa,MAAM;AAE/B,UAAM,gBAAgB,kBAAiB,MAAM;AAC7C,UAAM,kBAAkB,eAAe,OAAO,eAAe;AAC7D,UAAM,iBAAiB,0BAA0B;AACjD,gBAAY,aAAa;AAAA,MACvB,MAAM,gBAAe;AAAA,MACrB,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA;AAAA,QAER,MAAM;AAAA,UACJ,MAAM;AAAA;AAAA,QAER,SAAS;AAAA,UACP,MAAM,CAAC,sBAAsB;AAAA;AAAA;AAAA;AAKnC,mBAAe,MAAM,UAAU;AAAA;AAAA,EAGvB,gCAAiC,gBAAqC,QAA2B;AACzG,eAAW,SAAS,QAAQ;AAC1B,YAAM,YAAY,MAAM,YAAY;AACpC,YAAM,WAAW,GAAG;AACpB,YAAM,iBAAiB,GAAG;AAC1B,YAAM,YAAY,OAAO,KAAK,MAAM;AACpC,YAAM,SAAS,UAAU,OAAO,OAAK,CAAC,MAAM,OAAO,GAAG,aAAa,CAAC,MAAM,OAAO,GAAG,UAAU,KAAK;AACnG,YAAM,cAAc;AAAA,QAAC;AAAA,QAAO;AAAA,QAAQ;AAAA,QAAU;AAAA,QAAoB;AAAA,QAAkB;AAAA,QACpF;AAAA,QAAoB;AAAA,QAAiB;AAAA,QAAe;AAAA,QAAe;AAAA;AACnE,YAAM,eAAe,UAAU,OAAO,OAAK;AACzC,eAAO,CAAC,MAAM,OAAO,GAAG,aAAa,CAAC,MAAM,OAAO,GAAG,YAAY,YAAY,SAAS,MAAM,OAAO,GAAG,KAAK,QAAQ,KAAK;AAAA,SACxH,KAAK;AACR,qBAAe,aAAa,QAAQ,cAAc;AAClD,qBAAe,cAAc,WAAW,wBAAwB;AAChE,UAAG,iBAAiB,IAAI;AACtB,uBAAe,aAAa,QAAQ,oBAAoB;AACxD,uBAAe,cAAc,WAAW,8BAA8B;AAAA;AAAA;AAAA;AAAA,EAKlE,kBAAmB,gBAAqC,QAA2B;AAC3F,UAAM,qBAAqB,aAAa;AACxC,QAAI;AACJ,QAAI;AACJ,eAAW,SAAS,QAAQ;AAC1B,YAAM,OAAO,MAAM,YAAY;AAC/B,YAAM,UAAU,eAAe,OAAO;AACtC,YAAM,cAAc,MAAM,OAAO;AACjC,YAAM,gBAAgB,MAAM,OAAO;AACnC,YAAM,eAAe,CAAC,UAAkB,GAAG,+BAA+B;AAE1E,UAAI,eAAe;AACjB,cAAM,IAAI,MAAM,aAAa;AAAA;AAG/B,UAAI,aAAa;AACf,cAAM,IAAI,MAAM,aAAa;AAAA;AAG/B,UAAI,CAAC,oBAAoB;AACvB,YAAI,eAAe,IAAI,UAAU,OAAO;AACtC,+BAAqB,eAAe,OAAO,oBAAoB;AAAA,eAC1D;AACL,yBAAe,eAAe;AAC9B,+BAAqB,yBAAyB;AAC9C,yBAAe,IAAI;AAAA;AAGrB,wBAAgB,eAAe,OAAO,UAAU,MAAM;AAAA;AAGxD,YAAM,iBAAiB,sBAAsB;AAE7C,cAAQ,UAAU;AAElB,YAAM,YAAY,eAAe,OAAO,kBAAiB,MAAM,wBAAuB;AACtF,UAAI,WAAW;AACb,cAAM,sBAAsB,2BAA2B;AACvD,kBAAU,UAAU;AAAA;AAAA;AAEvB;AAAA;AAAA,EAUO,wBAAyB,QAAuB,eAAuB;AAC/E,UAAM,eAAe,0BAA0B;AAC/C,QAAI,KAAK,cAAc;AACrB,UAAI,kBAAkB,MAAM;AAC1B,eAAO,kBAAkB,OAAO;AAAA;AAElC,UAAI,kBAAkB,MAAM;AAC1B,eAAO,kBAAkB,OAAO;AAAA;AAElC,UAAI,kBAAkB,WAAW;AAC/B,eAAO,mBAAmB,OAAO;AAAA;AAAA;AAGrC,UAAM,MAAM,mBAAmB;AAAA;AAAA,EASvB,kBAAmB,OAAwB,WAAuB;AAC1E,cAAU,QAAS,UAAU,SAAS;AAEtC,SAAK,wBAAwB,OAAO,UAAU;AAC9C,SAAK,qBAAqB,OAAO,UAAU;AAAA;AAAA,EASnC,qBAAsB,OAAwB,WAAuB;AAC7E,cAAU,WAAY,UAAU,YAAY;AAC5C,SAAK,0BAA0B,OAAO,UAAU;AAChD,SAAK,0BAA0B,OAAO,UAAU;AAChD,SAAK,4BAA4B,OAAO,UAAU;AAClD,SAAK,0BAA0B,OAAO,UAAU;AAChD,SAAK,4BAA4B,OAAO,UAAU;AAAA;AAAA,EAS1C,yBAA0B,OAAwB,WAAuB;AACjF,UAAM,YAAY,MAAM;AACxB,cAAU,eAAgB,UAAU,gBAAgB;AACpD,SAAK,8BAA8B,WAAW,UAAU;AACxD,SAAK,8BAA8B,WAAW,UAAU;AACxD,SAAK,8BAA8B,WAAW,UAAU;AAAA;AAAA,EAShD,0BAA2B,OAAwB,aAAkC;AAC7F,UAAM,YAAY,MAAM;AACxB,UAAM,YAAY,UAAU;AAC5B,UAAM,sBAAsB,aAAa,WAAW,wBAAuB;AAE3E,gBAAY,uBAAuB,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AAC7G,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,OAAO,KAAK,OAAO,SAAS;AAAA;AAAA;AAAA,EAU1D,0BAA2B,OAAwB,aAAkC;AAC7F,UAAM,YAAY,MAAM,YAAY;AACpC,UAAM,cAAc,aAAa,WAAW,wBAAuB;AAEnE,gBAAY,eAAe,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AACrG,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,OAAO,KAAK,OAAO,SAAS;AAAA;AAAA;AAAA,EAU1D,4BAA6B,OAAwB,aAAkC;AAC/F,UAAM,YAAY,MAAM,YAAY;AACpC,UAAM,cAAc,aAAa,WAAW,wBAAuB;AAEnE,gBAAY,eAAe,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AACrG,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,SAAS,MAAM,SAAS;AAAA;AAAA;AAAA,EAUtD,0BAA2B,OAAwB,aAAkC;AAC7F,UAAM,YAAY,MAAM,YAAY;AACpC,UAAM,cAAc,aAAa,WAAW,wBAAuB;AAEnE,gBAAY,eAAe,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AACrG,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,OAAO,MAAM,SAAS;AAAA;AAAA;AAAA,EAUpD,4BAA6B,OAAwB,aAAkC;AAC/F,UAAM,YAAY,MAAM,YAAY;AACpC,UAAM,cAAc,aAAa,WAAW,wBAAuB;AAEnE,gBAAY,eAAe,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AACrG,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,SAAS,MAAM,SAAS;AAAA;AAAA;AAAA,EAUtD,qBAAsB,OAAwB,UAA+B;AACrF,UAAM,YAAY,MAAM;AACxB,UAAM,YAAY,UAAU;AAC5B,UAAM,YAAY,aAAa,WAAW,wBAAuB;AAEjE,aAAS,aAAa,OAAO,GAAQ,MAAkB,SAA2B,SAA6B;AAC7G,aAAO,MAAM,QAAQ,UAAU,WAAW,OAAO,MAAM,SAAS,MAAM;AAAA;AAAA;AAAA,EAUhE,wBAAyB,OAAwB,UAA+B;AACxF,UAAM,YAAY,MAAM;AACxB,UAAM,YAAY,UAAU;AAC5B,UAAM,eAAe,aAAa,WAAW,wBAAuB;AACpE,UAAM,kBAAkB,MAAM,WAAW;AAEzC,aAAS,gBAAgB,CAAC,GAAQ,MAAW,SAA2B,SAA6B;AACnG,UAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,cAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,aAAO,QAAQ,UAAU,WAAW,QAAQ,GAAG,kBAAkB,KAAK,MAAM,SAAS;AAAA;AAAA;AAAA,EAU/E,8BAA+B,WAA8B,iBAAsC;AAC3G,UAAM,YAAY,UAAU;AAC5B,UAAM,YAAY,oBAAoB,WAAW,wBAAuB;AAExE,oBAAgB,aAAa;AAAA,MAC3B,WAAW,CAAC,GAAQ,MAAW,YAA8B;AAC3D,YAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,gBAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,eAAO,QAAQ,UAAU,WAAW,kBAAkB,KAAK,QAAQ;AAAA;AAAA;AAAA;AAAA,EAW/D,8BAA+B,WAA8B,iBAAsC;AAC3G,UAAM,YAAY,UAAU;AAC5B,UAAM,YAAY,oBAAoB,WAAW,wBAAuB;AAExE,oBAAgB,aAAa;AAAA,MAC3B,WAAW,CAAC,GAAQ,MAAW,YAA8B;AAC3D,YAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,gBAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,eAAO,QAAQ,UAAU,WAAW,kBAAkB,KAAK,QAAQ;AAAA;AAAA;AAAA;AAAA,EAW/D,8BAA+B,WAA8B,iBAAsC;AAC3G,UAAM,YAAY,UAAU;AAC5B,UAAM,YAAY,oBAAoB,WAAW,wBAAuB;AAExE,oBAAgB,aAAa;AAAA,MAC3B,WAAW,CAAC,GAAQ,MAAW,YAA8B;AAC3D,YAAI,CAAC,QAAQ,aAAa,CAAC,QAAQ,UAAU,YAAY;AACvD,gBAAM,IAAI,MAAM,uBAAuB;AAAA;AAGzC,eAAO,QAAQ,UAAU,WAAW,kBAAkB,KAAK,QAAQ;AAAA;AAAA;AAAA;AAAA,EAKjE,sBAAuB,gBAAqC;AAClE,mBAAe,IAAI;AACnB,mBAAe,IAAI;AACnB,mBAAe,IAAI;AACnB,mBAAe,IAAI;AACnB,mBAAe,IAAI;AACnB,mBAAe,IAAI,yBAAyB;AAC5C,mBAAe,IAAI,yBAAyB;AAE5C,mBAAe,QAAQ,CAAC,OAA+B;AACrD,YAAM,YAAY,GAAG;AACrB,UAAI,cAAa,cAAc,CAAC,sBAAsB,cAAc,0BAAyB,SAAS,UAAU,OAAO;AACrH,uBAAe,IAAI,yBAAyB;AAE5C;AAAA;AAGF,YAAM,aAAa,CAAC,SAAS,gBAAgB,YAAY,SAAS,UAAU;AAC5E,UAAI,cAAa,cAAc,CAAC,YAAY;AAC1C,iCAAyB,gBAAgB;AACzC,iCAAyB,gBAAgB;AAAA;AAAA;AAAA;AAAA;","names":[]}