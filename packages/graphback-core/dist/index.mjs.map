{"version":3,"sources":["../src/crud/mappingHelpers.ts","../src/crud/GraphbackOperationType.ts","../src/plugin/GraphbackPlugin.ts","../src/plugin/GraphbackPluginEngine.ts","../src/plugin/GraphbackCoreMetadata.ts","../src/db/defaultNameTransforms.ts","../src/db/getPrimaryKey.ts","../src/db/buildModelTableMap.ts","../src/relationships/RelationshipMetadataBuilder.ts","../src/utils/hasListType.ts","../src/relationships/relationshipHelpers.ts","../src/utils/isTransientField.ts","../src/plugin/ModelDefinition.ts","../src/plugin/getSelectedFieldsFromResolverInfo.ts","../src/utils/printSchemaWithDirectives.ts","../src/utils/metadataAnnotations.ts","../src/utils/fieldTransformHelpers.ts","../src/runtime/CRUDService.ts","../src/utils/convertType.ts","../src/runtime/createInMemoryFilterPredicate.ts","../src/runtime/createCRUDService.ts","../src/runtime/NoDataError.ts","../src/runtime/QueryFilter.ts","../src/scalars/index.ts"],"sourcesContent":["import { GraphQLObjectType, GraphQLSchema, GraphQLField, getNamedType, isObjectType, isScalarType, isEnumType } from 'graphql'\nimport { parseMetadata } from 'graphql-metadata'\nimport pluralize from 'pluralize'\nimport { getUserTypesFromSchema } from '@graphql-tools/utils'\nimport { parseRelationshipAnnotation, transformForeignKeyName, getPrimaryKey } from '..'\nimport { GraphbackOperationType } from './GraphbackOperationType'\n\n// TODO it is esential to document this element\n\n/**\n * Graphback CRUD Mapping helpers\n */\n\nexport function lowerCaseFirstChar (text: string) {\n  return `${text.charAt(0).toLowerCase()}${text.slice(1)}`\n}\n\nexport function upperCaseFirstChar (text: string) {\n  return `${text.charAt(0).toUpperCase()}${text.slice(1)}`\n}\n\n/**\n * Get name of the field for query and mutation using our crud model.\n * Method trasform specific CRUD operation into compatible name\n *\n * Example:\n * ```\n * type Query {\n *   getUser()\n * }\n * ```\n * This method is compatible with Graphback CRUD specification\n *\n * @param typeName\n * @param action\n */\nexport const getFieldName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n\n  switch (action) {\n    case GraphbackOperationType.FIND_ONE:\n      return `get${finalName}`\n    case GraphbackOperationType.FIND:\n      return `find${pluralize(finalName)}`\n    case GraphbackOperationType.DELETE_BY:\n      return `delete${pluralize(finalName)}`\n    case GraphbackOperationType.UPDATE_BY:\n      return `update${pluralize(finalName)}`\n    default:\n      return `${action}${finalName}`\n  }\n}\n\n/**\n * Returns the input type assocatiated with a CRUD operation\n * @param typeName\n * @param action\n */\nexport const getInputTypeName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n  switch (action) {\n    case GraphbackOperationType.FIND:\n      return `${finalName}Filter`\n    case GraphbackOperationType.CREATE:\n      return `Create${finalName}Input`\n    case GraphbackOperationType.UPDATE:\n    case GraphbackOperationType.DELETE:\n    case GraphbackOperationType.UPDATE_BY:\n    case GraphbackOperationType.DELETE_BY:\n      return `Mutate${finalName}Input`\n    case GraphbackOperationType.SUBSCRIPTION_CREATE:\n    case GraphbackOperationType.SUBSCRIPTION_UPDATE:\n    case GraphbackOperationType.SUBSCRIPTION_DELETE:\n      return `${finalName}SubscriptionFilter`\n    default:\n      return ''\n  }\n}\n\n/**\n * Provides naming patterns for CRUD subscriptions\n */\nexport const getSubscriptionName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n  if (action === GraphbackOperationType.CREATE) {\n    return `new${finalName}`\n  }\n\n  if (action === GraphbackOperationType.UPDATE) {\n    return `updated${finalName}`\n  }\n\n  if (action === GraphbackOperationType.DELETE) {\n    return `deleted${finalName}`\n  }\n\n  return ''\n}\n\nexport function isModelType (graphqlType: GraphQLObjectType): boolean {\n  return !!parseMetadata('model', graphqlType.description)\n}\n\n/**\n * Get only user types annotated by ```@model```\n *\n * @param schema\n */\nexport function filterModelTypes (schema: GraphQLSchema): GraphQLObjectType[] {\n  return getUserTypesFromSchema(schema).filter(isModelType)\n}\n\n/**\n * Get only user types not annotated by ```@model```\n *\n * @param schema\n */\nexport function filterNonModelTypes (schema: GraphQLSchema): GraphQLObjectType[] {\n  return getUserTypesFromSchema(schema).filter((t: GraphQLObjectType) => !isModelType(t))\n}\n\nexport function getUserModels (modelTypes: GraphQLObjectType[]): GraphQLObjectType[] {\n  return modelTypes.filter(isModelType)\n}\n\nexport function isInputField (field: GraphQLField<any, any>): boolean {\n  const relationshipAnnotation = parseRelationshipAnnotation(field.description)\n\n  return (relationshipAnnotation == null) || relationshipAnnotation.kind !== 'oneToMany'\n}\n\n// tslint:disable-next-line: no-reserved-keywords\nexport function getRelationFieldName (field: any, type: any) {\n  let fieldName: string\n  if (field.annotations.OneToOne) {\n    fieldName = field.annotations.OneToOne.field\n  } else if (field.annotations.ManyToOne) {\n    fieldName = field.annotations.ManyToOne.field\n  } else if (field.annotations.OneToMany) {\n    fieldName = field.annotations.OneToMany.field\n  } else {\n    fieldName = type.name\n  }\n\n  return fieldName\n}\n\nexport function getInputFieldName (field: GraphQLField<any, any>): string {\n  const relationshipAnnotation = parseRelationshipAnnotation(field.description)\n\n  if (relationshipAnnotation == null) {\n    return field.name\n  }\n\n  if (relationshipAnnotation.kind === 'oneToMany') {\n    throw new Error('Not inputtable field!')\n  }\n\n  return relationshipAnnotation.key || transformForeignKeyName(field.name)\n}\n\nexport function getInputFieldTypeName (modelName: string, field: GraphQLField<any, any>, operation: GraphbackOperationType): string {\n  const fieldType = getNamedType(field.type)\n\n  if (isObjectType(fieldType) && isModelType(fieldType)) {\n    const relationshipAnnotation = parseRelationshipAnnotation(field.description)\n\n    if (relationshipAnnotation == null) {\n      throw new Error(`Missing relationship definition on: \"${modelName}.${field.name}\". Visit https://graphback.dev/docs/model/datamodel#relationships to see how you can define relationship in your business model.`)\n    }\n\n    const idField = getPrimaryKey(fieldType)\n\n    return getNamedType(idField.type).name\n  }\n\n  if (isScalarType(fieldType) || isEnumType(fieldType)) {\n    return fieldType.name\n  }\n\n  if (isObjectType(fieldType) && !isModelType(fieldType)) {\n    // TODO: Filtering on JSON fields\n    if (operation === GraphbackOperationType.FIND) {\n      return undefined\n      // return GraphQLJSON\n    }\n\n    return getInputTypeName(fieldType.name, operation)\n  }\n\n  return undefined\n}\n","\n/**\n * Enum with list of possible resolvers that can be created\n */\n/* eslint-disable no-shadow */\nexport enum GraphbackOperationType {\n  CREATE = 'create',\n  UPDATE = 'update',\n  UPDATE_BY = 'updateBy',\n  FIND = 'find',\n  FIND_ONE = 'findOne',\n  DELETE = 'delete',\n  DELETE_BY = 'deleteBy',\n  SUBSCRIPTION_CREATE = 'subCreate',\n  SUBSCRIPTION_UPDATE = 'subUpdate',\n  SUBSCRIPTION_DELETE = 'subDelete'\n}\n/* eslint-enable no-shadow */\n","import { GraphQLSchema } from 'graphql'\nimport { IResolvers } from '@graphql-tools/utils'\nimport { GraphbackCoreMetadata } from './GraphbackCoreMetadata'\n\n/**\n * Graphback plugin interface\n * Plugins are base for every graphback generator and schema transformers.\n * See documentation for the complete list of the plugins.\n *\n * Plugins can:\n *\n * - Modify the schema\n * - Create resources like files, db tables etc.\n * - Perform some in memory operations based on configuration\n */\nexport abstract class GraphbackPlugin {\n  /**\n   * Performs transformation on the schema and returns target schema\n   * Implementations should extend this method if they wish to apply some changes\n   * to schema. Otherwise unchanged schema should be returned\n   *\n   * @param metadata - metadata object containing schema\n   */\n  public transformSchema (metadata: GraphbackCoreMetadata): GraphQLSchema {\n    return metadata.getSchema()\n  }\n\n  /**\n   * Create resources like files etc. for this plugin.\n   * This method should write resouces to filesystem\n   */\n  public createResources (metadata: GraphbackCoreMetadata): void {\n    return undefined\n  }\n\n  /**\n   * Method to create in-memory resolvers which will be\n   * added to a list of resolvers output by Graphback\n   *\n   * @param metadata - metadata object with model metadata\n   */\n  public createResolvers (metadata: GraphbackCoreMetadata): IResolvers {\n    return undefined\n  }\n\n  protected logWarning (message: string): void {\n    // eslint-disable-next-line no-console\n    console.log(`Warning - ${this.getPluginName()}: ${message}`)\n  }\n\n  protected logError (message: string): void {\n    // eslint-disable-next-line no-console\n    console.error(`Error - ${this.getPluginName()}: ${message}`)\n  }\n\n  /**\n   * @returns Unique name of the plugin\n   */\n  public abstract getPluginName (): string\n};\n","import { buildSchema, GraphQLSchema } from 'graphql'\nimport { GraphbackCoreMetadata } from './GraphbackCoreMetadata'\nimport { GraphbackGlobalConfig } from './GraphbackGlobalConfig'\nimport { GraphbackPlugin } from './GraphbackPlugin'\n\n/**\n * options for the GraphbackPluginEngine\n */\nexport interface GraphBackPluginEngineOptions {\n  schema: GraphQLSchema | string\n  config?: GraphbackGlobalConfig\n  plugins?: GraphbackPlugin[]\n}\n/**\n * Allows to execute chain of plugins that create resources.\n * Common use case is to decorate GraphQL schema with additional\n * actions and generate files like resolvers and database access logic\n *\n * Usage:\n * ```js\n * const engine = GraphbackPluginEngine({ schema });\n * engine.registerPlugin(plugin);\n * printSchema(engine.createResources());\n * ```\n */\nexport class GraphbackPluginEngine {\n  private readonly plugins: GraphbackPlugin[]\n  private readonly metadata: GraphbackCoreMetadata\n\n  public constructor ({ schema, config, plugins = [] }: GraphBackPluginEngineOptions) {\n    this.plugins = plugins\n    if (!schema) {\n      throw new Error('Plugin engine requires schema')\n    }\n    let graphQLSchema: GraphQLSchema\n    if (typeof schema === 'string') {\n      graphQLSchema = buildSchema(schema)\n    } else {\n      graphQLSchema = schema\n    }\n    this.metadata = new GraphbackCoreMetadata(config, graphQLSchema)\n  }\n\n  public registerPlugin (...plugins: GraphbackPlugin[]): void {\n    this.plugins.push(...plugins)\n  }\n\n  /**\n   * Allows the transformation of schema by applying transformation logic for each plugin\n   * Creation of resolvers, which has to come after all the changes in schema have been applied\n   * Saving of the transformed schema and related files\n   */\n  public createResources (): GraphbackCoreMetadata {\n    if (this.plugins.length === 0) {\n      console.warn('GraphbackEngine: No Graphback plugins registered')\n    }\n\n    this.createSchema()\n\n    this.createResolvers()\n\n    // Save schema and all files\n    for (const plugin of this.plugins) {\n      plugin.createResources(this.metadata)\n    }\n\n    return this.metadata\n  }\n\n  private createSchema () {\n    // We need to apply all required changes to the schema we need\n    // This is to ensure that every plugin can add changes to the schema\n    for (const plugin of this.plugins) {\n      const newSchema = plugin.transformSchema(this.metadata)\n      this.metadata.setSchema(newSchema)\n    }\n  }\n\n  private createResolvers () {\n    for (const plugin of this.plugins) {\n      const resolvers = plugin.createResolvers(this.metadata)\n      this.metadata.addResolvers(resolvers)\n    }\n  }\n}\n","import { parseMetadata } from 'graphql-metadata'\nimport { mergeResolvers } from '@graphql-tools/merge'\nimport { GraphQLObjectType, GraphQLSchema, getNamedType } from 'graphql'\nimport { getUserTypesFromSchema, IResolvers } from '@graphql-tools/utils'\nimport { getPrimaryKey } from '../db'\nimport { RelationshipMetadataBuilder, FieldRelationshipMetadata } from '../relationships/RelationshipMetadataBuilder'\nimport { isTransientField } from '../utils/isTransientField'\nimport { GraphbackCRUDGeneratorConfig } from './GraphbackCRUDGeneratorConfig'\nimport { ModelDefinition, ModelFieldMap } from './ModelDefinition'\nimport { GraphbackGlobalConfig } from './GraphbackGlobalConfig'\n\nconst defaultCRUDGeneratorConfig = {\n  create: true,\n  update: true,\n  updateBy: true,\n  findOne: true,\n  find: true,\n  delete: true,\n  deleteBy: true,\n  subCreate: true,\n  subUpdate: true,\n  subDelete: true\n}\n\n/**\n * Contains Graphback Core Models\n */\nexport class GraphbackCoreMetadata {\n  private readonly supportedCrudMethods: GraphbackCRUDGeneratorConfig\n  private schema: GraphQLSchema\n  private resolvers: IResolvers\n  private models: ModelDefinition[]\n\n  public constructor (globalConfig: GraphbackGlobalConfig, schema: GraphQLSchema) {\n    this.schema = schema\n    this.supportedCrudMethods = Object.assign({}, defaultCRUDGeneratorConfig, globalConfig?.crudMethods)\n  }\n\n  public getSchema () {\n    return this.schema\n  }\n\n  public setSchema (newSchema: GraphQLSchema) {\n    this.schema = newSchema\n  }\n\n  public addResolvers (resolvers: IResolvers) {\n    if (resolvers) {\n      const mergedResolvers = [\n        this.resolvers,\n        resolvers\n      ]\n      this.resolvers = mergeResolvers(mergedResolvers)\n    }\n  }\n\n  public getResolvers (): IResolvers {\n    return this.resolvers\n  }\n\n  /**\n   * Get Graphback Models - GraphQL Types with additional CRUD configuration\n   */\n  public getModelDefinitions () {\n    // Contains map of the models with their underlying CRUD configuration\n    this.models = []\n    // Get actual user types\n    const modelTypes = this.getGraphQLTypesWithModel()\n\n    const relationshipBuilder = new RelationshipMetadataBuilder(modelTypes)\n    relationshipBuilder.build()\n\n    for (const modelType of modelTypes) {\n      const model = this.buildModel(modelType, relationshipBuilder.getModelRelationships(modelType.name))\n      this.models.push(model)\n    }\n\n    return this.models\n  }\n\n  /**\n   * Helper for plugins to fetch all types that should be processed by Graphback plugins.\n   * To mark type as enabled for graphback generators we need to add `model` annotations over the type.\n   *\n   * Returns all user types that have @model in description\n   * @param schema\n   */\n  public getGraphQLTypesWithModel (): GraphQLObjectType[] {\n    const types = getUserTypesFromSchema(this.schema)\n\n    return types.filter((modelType: GraphQLObjectType) => parseMetadata('model', modelType))\n  }\n\n  private buildModel (modelType: GraphQLObjectType, relationships: FieldRelationshipMetadata[]): ModelDefinition {\n    let crudOptions = parseMetadata('model', modelType)\n    // Merge CRUD options from type with global ones\n    crudOptions = Object.assign({}, this.supportedCrudMethods, crudOptions)\n    const uniqueFields = Array.isArray(crudOptions.unique) ? crudOptions.unique : []\n    const { type: primaryKeyType, name } = getPrimaryKey(modelType)\n    const primaryKey = {\n      name,\n      type: getNamedType(primaryKeyType).name\n    }\n    // parse fields\n    const modelFields = modelType.getFields()\n    const fields: ModelFieldMap = {}\n\n    for (const field of Object.keys(modelFields)) {\n      let fieldName = field\n      let type: string = ''\n\n      const graphqlField = modelFields[field]\n\n      if (isTransientField(graphqlField)) {\n        fields[field] = {\n          name: field,\n          transient: true,\n          type: getNamedType(graphqlField.type).name\n        }\n        continue\n      }\n\n      const foundRelationship = relationships.find((relationship: FieldRelationshipMetadata) => relationship.ownerField.name === field)\n\n      if (foundRelationship != null) {\n        if (foundRelationship.kind !== 'oneToMany') {\n          fieldName = foundRelationship.relationForeignKey\n          type = getNamedType(foundRelationship.relationType).name // TODO properly retrieve field type for foreign key\n        } else {\n          fieldName = primaryKey.name\n          type = primaryKey.type\n        }\n      } else {\n        type = getNamedType(modelFields[field].type).name\n      }\n\n      fields[field] = {\n        name: fieldName,\n        type,\n        transient: false\n      }\n    }\n\n    return {\n      fields,\n      primaryKey,\n      crudOptions,\n      relationships,\n      uniqueFields,\n      graphqlType: modelType\n    }\n  }\n}\n","export type DatabaseNameTransformDirection = 'from-db' | 'to-db'\n\n/**\n * Transform to/from database table or column name\n */\nexport type DatabaseNameTransform = (\n  name: string,\n  direction: DatabaseNameTransformDirection,\n) => string\n\n/**\n * Transform to/from database table name\n *\n * @param name - model name\n * @param direction - transform to or from database\n */\nexport function defaultTableNameTransform (name: string, direction: DatabaseNameTransformDirection) {\n  if (direction === 'to-db') {\n    return name.toLowerCase()\n  }\n\n  return name\n}\n\nexport function transformForeignKeyName (name: string, direction: DatabaseNameTransformDirection = 'to-db') {\n  if (direction === 'to-db') {\n    return `${name}Id`\n  }\n\n  return name\n}\n","import { GraphQLField, GraphQLObjectType, getNamedType, isScalarType, GraphQLInputField } from 'graphql'\nimport { parseMetadata } from 'graphql-metadata'\n\n/**\n * Returns the primary key field of a GraphQL object.\n * First looks for the existence of a `@id` field annotation,\n * otherwise tries to find an `id: ID` field.\n *\n * @param graphqlType\n */\nexport function getPrimaryKey (graphqlType: GraphQLObjectType): GraphQLField<any, any> {\n  const fields = Object.values(graphqlType.getFields())\n\n  const autoPrimaryKeyFromScalar: Array<GraphQLField<any, any>> = []\n  let primaryKey: GraphQLField<any, any>\n  let primariesCount = 0\n  for (const field of fields) {\n    const hasIdMarker = parseMetadata('id', field)\n    if (hasIdMarker) {\n      primaryKey = field\n      primariesCount += 1\n    } else if (isAutoPrimaryKey(field)) {\n      autoPrimaryKeyFromScalar.push(field)\n    }\n  }\n\n  if (primariesCount > 1) {\n    throw new Error(`${graphqlType.name} type should not have multiple '@id' annotations.`)\n  }\n\n  if (primaryKey) {\n    return primaryKey\n  }\n\n  if (autoPrimaryKeyFromScalar.length > 1) {\n    throw new Error(`${graphqlType.name} type should not have two potential primary keys: \"_id\" and \"id\". Use '@id' annotations to indicate which one is to be used.`)\n  }\n\n  primaryKey = autoPrimaryKeyFromScalar.shift()\n\n  if (!primaryKey) {\n    throw new Error(`${graphqlType.name} type has no primary field.`)\n  }\n\n  return primaryKey\n}\n\n/**\n * Check if a GraphQLField can be inferred as a primary key, specific for each database:\n * A field is a potential primary key if:\n * - is named \"id\" and has type \"ID\", auto increment primary key for relational database\n * - is named \"_id\" and has scalar type \"GraphbackObectID\", a BSON primary key for MongoDB\n * @param field\n */\nexport function isAutoPrimaryKey (field: GraphQLField<any, any> | GraphQLInputField): boolean {\n  const { type, name: fieldName } = field\n  const baseType = getNamedType(type)\n  const name = baseType.name\n\n  return fieldName === 'id' && name === 'ID' && isScalarType(baseType)\n}\n","import { GraphQLField, GraphQLFieldMap, GraphQLObjectType } from 'graphql'\nimport { parseMetadata } from 'graphql-metadata'\nimport { defaultTableNameTransform } from './defaultNameTransforms'\nimport { getPrimaryKey } from './getPrimaryKey'\n\n/**\n * Contains mapping information between GraphQL Model type and database table\n *\n * - typeName: Original GraphQLObjectType name\n * - tableName: Name of datase table\n * - id: Indicates the primary key field\n * - fieldMap: Object of key-value mapping between GraphQL fields and database columns.\n */\nexport interface ModelTableMap {\n  typeName: string\n  tableName: string\n  idField: string\n  fieldMap?: { [key: string]: string }\n}\n\n/**\n * Gets the datase column name for a GraphQL type.\n * Checks for the `@db(name)` annotation for a customised name\n *\n * @param field\n */\nexport function getTableName (model: GraphQLObjectType): string {\n  let tableName = defaultTableNameTransform(model.name, 'to-db')\n\n  const dbAnnotations = parseMetadata('db', model)\n  if (dbAnnotations && dbAnnotations.name) {\n    tableName = dbAnnotations.name\n  }\n\n  return tableName\n}\n\n/**\n * Gets the datase column name for a GraphQL field.\n * Checks for the `@db(name)` annotation for a customised name\n *\n * @param field\n */\nexport function getColumnName (field: GraphQLField<any, any>): string {\n  let columnName = field.name\n\n  const dbAnnotations = parseMetadata('db', field)\n  if (dbAnnotations && dbAnnotations.name) {\n    columnName = dbAnnotations.name\n  }\n\n  return columnName\n}\n\nfunction mapFieldsToColumns (fieldMap: GraphQLFieldMap<any, any>): any {\n  return Object.values(fieldMap).reduce((obj: any, field: GraphQLField<any, any>) => {\n    const columnName = getColumnName(field)\n\n    if (field.name !== columnName) {\n      obj[field.name] = columnName\n    }\n\n    // TODO: Map relationship fields\n\n    return obj\n  }, {})\n}\n\n/**\n * Builds a database mapping model of a GraphQLObject type.\n * @param model - The GraphQL object data model representation\n *\n * @returns {ModelTableMap} A model containing the table name, any field customisations and a mapping of the primary key field.\n */\nexport const buildModelTableMap = (model: GraphQLObjectType): ModelTableMap => {\n  const primaryKeyField = getPrimaryKey(model)\n  const tableName = getTableName(model)\n  const fieldMap = mapFieldsToColumns(model.getFields())\n\n  return {\n    idField: getColumnName(primaryKeyField),\n    typeName: model.name,\n    tableName,\n    fieldMap\n  }\n}\n","/* eslint-disable max-lines */\nimport { GraphQLObjectType, GraphQLField, isObjectType, GraphQLScalarType, GraphQLOutputType, GraphQLNonNull, GraphQLList, getNamedType } from 'graphql'\nimport { parseMetadata } from 'graphql-metadata'\nimport { isModelType } from '../crud'\nimport { transformForeignKeyName } from '../db'\nimport { hasListType } from '../utils/hasListType'\nimport { parseRelationshipAnnotation, relationshipFieldDescriptionTemplate, relationshipOneToOneFieldDescriptionTemplate } from './relationshipHelpers'\n\nexport interface FieldRelationshipMetadata {\n  kind: 'oneToMany' | 'oneToOne' | 'manyToOne'\n  owner: GraphQLObjectType\n  ownerField: GraphQLField<any, any>\n  relationType: GraphQLObjectType\n  relationFieldName: string\n  relationFieldType?: GraphQLScalarType\n  relationForeignKey?: string\n}\n\nexport interface RelationshipAnnotation {\n  kind: 'oneToMany' | 'oneToOne' | 'manyToOne'\n  field?: string\n  key?: string\n}\n\n/**\n * Builds relationship context for entire data model.\n * Performs validation on relationship fields and metadata\n * Dynamically creates relationship fields and maps values to data layer.\n */\nexport class RelationshipMetadataBuilder {\n  private readonly modelTypes: GraphQLObjectType[]\n  private readonly relationships: FieldRelationshipMetadata[]\n  public constructor (modelTypes: GraphQLObjectType[]) {\n    this.relationships = []\n    this.modelTypes = modelTypes\n  }\n\n  /**\n   * Builds relationship context for entire data model\n   * Generates fields and anotations\n   */\n  public build () {\n    for (const modelType of this.modelTypes) {\n      this.buildModelRelationshipContext(modelType)\n    }\n  }\n\n  /**\n   * Get all relationships\n   */\n  public getRelationships () {\n    return this.relationships\n  }\n\n  /**\n   * Get all relationships where the model is the parent.\n   * @param modelName\n   */\n  public getModelRelationships (modelName: string): FieldRelationshipMetadata[] {\n    return this.relationships.filter((relationship: FieldRelationshipMetadata) => relationship.owner.name === modelName)\n  }\n\n  /**\n   * Collects relationship information for a model based on relationship field annotations\n   * and pushes to list of all relationships in data model.\n   *\n   * @param modelType\n   */\n  private buildModelRelationshipContext (modelType: GraphQLObjectType) {\n    const fields = Object.values(modelType.getFields())\n\n    for (let field of fields) {\n      const annotation = parseRelationshipAnnotation(field.description)\n      if (annotation == null) {\n        continue\n      }\n\n      this.validateRelationshipField(modelType.name, field, annotation)\n\n      const relationType = getNamedType(field.type) as GraphQLObjectType\n\n      let relationField = relationType.getFields()[annotation.field]\n\n      if (annotation.kind === 'oneToMany') {\n        field = this.updateOneToManyField(field, annotation.field, annotation.key)\n\n        if (!relationField) {\n          relationField = this.createManyToOneField(annotation.field, modelType, field.name, annotation.key)\n        } else {\n          relationField = this.updateManyToOneField(relationField, field.name, annotation.key)\n        }\n\n        // Avoid reparsing if annotation key defined\n        const oneToManyAnnotation = annotation.key ? annotation : parseRelationshipAnnotation(field.description)\n\n        const manyToOneAnnotation = parseRelationshipAnnotation(relationField.description)\n\n        this.addOneToMany(modelType, field, oneToManyAnnotation, manyToOneAnnotation)\n        this.addManyToOne(relationType, relationField, manyToOneAnnotation)\n      } else if (annotation.kind === 'manyToOne') {\n        if (!relationField) {\n          relationField = this.createOneToManyField(annotation.field, modelType, field.name, annotation.key)\n        }\n\n        const oneToManyAnnotation = parseRelationshipAnnotation(relationField.description)\n\n        this.addManyToOne(modelType, field, annotation)\n        this.addOneToMany(relationType, relationField, oneToManyAnnotation, annotation)\n      } else if (annotation.kind === 'oneToOne') {\n        field = this.updateOneToOneField(field, annotation.key)\n\n        // avoid reparsing if annotation key defined\n        const oneToOneAnnotation = annotation.key ? annotation : parseRelationshipAnnotation(field.description)\n        this.addOneToOne(modelType, field, oneToOneAnnotation)\n      }\n    }\n  }\n\n  private createOneToManyField (fieldName: string, baseType: GraphQLOutputType, relationFieldName: string, columnName?: string): GraphQLField<any, any> {\n    const columnField = columnName || transformForeignKeyName(relationFieldName)\n    const fieldDescription = relationshipFieldDescriptionTemplate('oneToMany', relationFieldName, columnField)\n\n    const fieldType = GraphQLNonNull(GraphQLList(baseType))\n\n    return {\n      name: fieldName,\n      description: fieldDescription,\n      type: fieldType,\n      args: [],\n      extensions: [],\n      isDeprecated: false,\n      deprecationReason: undefined\n    }\n  }\n\n  private createManyToOneField (fieldName: string, baseType: GraphQLOutputType, relationFieldName: string, columnName?: string): GraphQLField<any, any> {\n    const columnField = columnName || transformForeignKeyName(fieldName)\n    const fieldDescription = relationshipFieldDescriptionTemplate('manyToOne', relationFieldName, columnField)\n\n    return {\n      name: fieldName,\n      description: fieldDescription,\n      type: baseType,\n      args: [],\n      extensions: [],\n      isDeprecated: false,\n      deprecationReason: undefined\n    }\n  }\n\n  private updateOneToManyField (field: GraphQLField<any, any>, relationFieldName: string, columnName?: string): GraphQLField<any, any> {\n    if (!columnName) {\n      const columnField = transformForeignKeyName(relationFieldName)\n      const fieldDescription = relationshipFieldDescriptionTemplate('oneToMany', relationFieldName, columnField)\n      const oldDescription = field.description ? `\\n${field.description}` : ''\n\n      return {\n        ...field,\n        description: `${fieldDescription}${oldDescription}`\n      }\n    }\n\n    return field\n  }\n\n  private updateManyToOneField (field: GraphQLField<any, any>, relationFieldName: string, columnName?: string): GraphQLField<any, any> {\n    const manyToOneMetadata = parseMetadata('manyToOne', field.description)\n\n    if (!manyToOneMetadata || !manyToOneMetadata.key) {\n      const columnField = columnName || transformForeignKeyName(field.name)\n      const fieldDescription = relationshipFieldDescriptionTemplate('manyToOne', relationFieldName, columnField)\n      const oldDescription = field.description ? `\\n${field.description}` : ''\n\n      return {\n        ...field,\n        description: `${fieldDescription}${oldDescription}`\n      }\n    }\n\n    return field\n  }\n\n  private updateOneToOneField (field: GraphQLField<any, any>, columnName?: string): GraphQLField<any, any> {\n    if (!columnName) {\n      const columnField = transformForeignKeyName(field.name)\n      const fieldDescription = relationshipOneToOneFieldDescriptionTemplate('oneToOne', columnField)\n      const oldDescription = field.description ? `\\n${field.description}` : ''\n\n      return {\n        ...field,\n        description: `${fieldDescription}${oldDescription}`\n      }\n    }\n\n    return field\n  }\n\n  private addOneToMany (ownerType: GraphQLObjectType, field: GraphQLField<any, any>, oneToManyAnnotation: RelationshipAnnotation, corresspondingManyToOneMetadata: RelationshipAnnotation) {\n    this.validateOneToManyRelationship(ownerType.name, field, oneToManyAnnotation, corresspondingManyToOneMetadata)\n\n    // skip - relationship with key annotation will be generated at later stage\n    if (!oneToManyAnnotation.key) {\n      return\n    }\n\n    const relationType = getNamedType(field.type) as GraphQLObjectType\n\n    const oneToMany: FieldRelationshipMetadata = {\n      kind: 'oneToMany',\n      owner: ownerType,\n      ownerField: field,\n      relationType,\n      relationFieldName: oneToManyAnnotation.field,\n      relationForeignKey: oneToManyAnnotation.key\n    }\n\n    this.relationships.push(oneToMany)\n  }\n\n  private addManyToOne (ownerType: GraphQLObjectType, field: GraphQLField<any, any>, manyToOneAnnotation: RelationshipAnnotation) {\n    this.validateManyToOneField(ownerType.name, field, manyToOneAnnotation)\n\n    // skip - relationship with key annotation will be generated at later stage\n    if (!manyToOneAnnotation.key) {\n      return\n    }\n\n    const relationType = getNamedType(field.type) as GraphQLObjectType\n\n    const manyToOne: FieldRelationshipMetadata = {\n      kind: 'manyToOne',\n      owner: ownerType,\n      ownerField: field,\n      relationType,\n      relationFieldName: manyToOneAnnotation.field,\n      relationForeignKey: manyToOneAnnotation.key\n    }\n\n    this.relationships.push(manyToOne)\n  }\n\n  private addOneToOne (ownerType: GraphQLObjectType, field: GraphQLField<any, any>, oneToOneAnnotation: RelationshipAnnotation) {\n    this.validateOneToOneRelationship(ownerType.name, field, oneToOneAnnotation)\n\n    // skip - relationship with key mapping will be generated at a later stage\n    if (!oneToOneAnnotation.key) {\n      return\n    }\n\n    const relationType = getNamedType(field.type) as GraphQLObjectType\n\n    const oneToOne: FieldRelationshipMetadata = {\n      kind: 'oneToOne',\n      owner: ownerType,\n      ownerField: field,\n      relationType,\n      relationFieldName: oneToOneAnnotation.field,\n      relationForeignKey: oneToOneAnnotation.key\n    }\n\n    this.relationships.push(oneToOne)\n  }\n\n  private validateOneToManyRelationship (modelName: string, field: GraphQLField<any, any>, oneToManyMetadata: RelationshipAnnotation, corresspondingManyToOneMetadata: RelationshipAnnotation) {\n    this.validateRelationshipField(modelName, field, oneToManyMetadata)\n\n    if (oneToManyMetadata.kind !== 'oneToMany') {\n      throw new Error(`${modelName}.${field.name} should be a @oneToMany field, but has a @${oneToManyMetadata.kind} annotation`)\n    }\n\n    const relationModelType = getNamedType(field.type) as GraphQLObjectType\n    const relationField = relationModelType.getFields()[oneToManyMetadata.field]\n\n    // field will be generated, no need to validate\n    if (!relationField) {\n      return\n    }\n\n    if (hasListType(relationField.type)) {\n      throw new Error(`${relationModelType.name}.${relationField.name} is a list type, but should be '${relationField.name}: ${modelName}'.`)\n    }\n\n    const relationFieldBaseType = getNamedType(relationField.type)\n\n    if (!isObjectType(relationFieldBaseType) || relationFieldBaseType.name !== modelName) {\n      throw new Error(`${modelName}.${field.name} relationship field maps to ${relationModelType.name}.${relationField.name} (${relationFieldBaseType.name} type) which should be ${modelName} type.`)\n    }\n\n    if (oneToManyMetadata?.key !== corresspondingManyToOneMetadata?.key) {\n      throw new Error(`${modelName}.${field.name} and ${relationModelType.name}.${relationField.name} 'key' annotations are different. Ensure both are the same, or remove one so that it can be generated.`)\n    }\n  }\n\n  private validateManyToOneField (modelName: string, field: GraphQLField<any, any>, manyToOneAnnotation: RelationshipAnnotation) {\n    this.validateRelationshipField(modelName, field, manyToOneAnnotation)\n\n    if (manyToOneAnnotation.kind !== 'manyToOne') {\n      throw new Error(`${modelName}.${field.name} should be a @manyToOne field, but has a @${manyToOneAnnotation.kind} annotation`)\n    }\n  }\n\n  private validateOneToOneRelationship (modelName: string, field: GraphQLField<any, any>, oneToOneAnnotation: RelationshipAnnotation) {\n    this.validateRelationshipField(modelName, field, oneToOneAnnotation)\n\n    if (oneToOneAnnotation.kind !== 'oneToOne') {\n      throw new Error(`${modelName}.${field.name} should be a @oneToOne field, but has a ${oneToOneAnnotation.kind} annotation`)\n    }\n\n    if (hasListType(field.type)) {\n      throw new Error(`${modelName}.${field.name} is a list type, but should be an object.`)\n    }\n  }\n\n  private validateRelationshipField (modelName: string, field: GraphQLField<any, any>, relationshipAnnotation: RelationshipAnnotation) {\n    if (!relationshipAnnotation) {\n      throw new Error(`${modelName}.${field.name} is missing a relationship annotation.`)\n    }\n\n    const fieldBaseType = getNamedType(field.type)\n\n    if (!isObjectType(fieldBaseType)) {\n      throw new Error(`${modelName}.${field.name} is marked as a relationship field, but has type ${fieldBaseType.name}. Relationship fields must be object types.`)\n    }\n\n    if (!isModelType(fieldBaseType)) {\n      throw new Error(`${modelName}.${field.name} is marked as a relationship field, but type ${fieldBaseType.name} is missing the @model annotation.`)\n    }\n  }\n}\n","import { GraphQLOutputType, isWrappingType, isListType } from 'graphql'\n\nexport function hasListType (outputType: GraphQLOutputType): boolean {\n  if (isListType(outputType)) {\n    return true\n  } else if (isWrappingType(outputType)) {\n    return hasListType(outputType.ofType)\n  }\n\n  return false\n}\n","import { parseMetadata } from 'graphql-metadata'\nimport { GraphQLObjectType, getNamedType, GraphQLField } from 'graphql'\nimport { ObjectTypeComposerFieldConfigAsObjectDefinition, ObjectTypeComposer, ObjectTypeComposerFieldConfigMapDefinition } from 'graphql-compose'\nimport { ModelDefinition } from '../plugin/ModelDefinition'\nimport { getInputTypeName, GraphbackOperationType } from '../crud'\nimport { RelationshipAnnotation } from './RelationshipMetadataBuilder'\n\n/**\n * Parse relationship metadata string to strongly-typed interface\n *\n * @param description field description\n */\nexport function parseRelationshipAnnotation (description: string = ''): RelationshipAnnotation | undefined {\n  const relationshipKinds = ['oneToMany', 'oneToOne', 'manyToOne']\n\n  for (const kind of relationshipKinds) {\n    const annotation: any = parseMetadata(kind, description)\n\n    if (!annotation) {\n      continue\n    }\n\n    // TODO: Should not throw error here\n    if (!annotation.field && kind !== 'oneToOne') {\n      throw new Error(`'field' is required on \"${kind}\" relationship annotations`)\n    }\n\n    return {\n      kind,\n      ...annotation\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Helper to check if a field is a oneToMany\n * @param fieldName\n * @param relationships\n */\nexport function isOneToManyField (field: GraphQLField<any, any>): boolean {\n  const oneToManyAnnotation: any = parseMetadata('oneToMany', field.description)\n\n  return !!oneToManyAnnotation\n}\n\n/**\n * Generic template for relationship annotations\n *\n * @param relationshipKind\n * @param fieldName\n * @param columnKey\n */\nexport const relationshipFieldDescriptionTemplate = (relationshipKind: 'oneToOne' | 'oneToMany' | 'manyToOne', fieldName: string, columnKey: string): string => {\n  return `@${relationshipKind}(field: '${fieldName}', key: '${columnKey}')`\n}\n\n/**\n * Template for one-to-one relationship annotations\n *\n * @param relationshipKind\n * @param fieldName\n * @param columnKey\n */\nexport const relationshipOneToOneFieldDescriptionTemplate = (relationshipKind: 'oneToOne' | 'oneToMany' | 'manyToOne', columnKey: string): string => {\n  return `@${relationshipKind}(key: '${columnKey}')`\n}\n\n/**\n * Generate relationship fields inferred from metadata\n * and add to the model type\n *\n * @param {ModelDefinition} model - Graphback model definition\n * @param {ObjectTypeComposer} typeComposer - GraphQL Compose Type composer for the model\n */\nexport function addRelationshipFields (model: ModelDefinition, typeComposer: ObjectTypeComposer): void {\n  const modelType = model.graphqlType\n  const modelFields = modelType.getFields()\n\n  const fieldsObj: ObjectTypeComposerFieldConfigMapDefinition<any, any> = {}\n  for (const current of model.relationships) {\n    if (!modelFields[current.ownerField.name]) {\n      fieldsObj[current.ownerField.name] = {\n        type: current.ownerField.type,\n        description: current.ownerField.description\n      }\n    }\n  }\n\n  typeComposer.addFields(fieldsObj)\n}\n\n/**\n * Extends an existing relationship field by adding metadata such as annotations\n *\n * @param {ModelDefinition} model - Graphback model definition\n * @param {ObjectTypeComposer} typeComposer - GraphQL Compose Type composer for the model\n */\nexport function extendRelationshipFields (model: ModelDefinition, typeComposer: ObjectTypeComposer): void {\n  const modelType = model.graphqlType\n\n  const modelFields = modelType.getFields()\n\n  for (const fieldRelationship of model.relationships) {\n    if (modelFields[fieldRelationship.ownerField.name]) {\n      const modelField = modelFields[fieldRelationship.ownerField.name]\n\n      const partialConfig: Partial<ObjectTypeComposerFieldConfigAsObjectDefinition<any, any>> = {\n        type: modelField.type,\n        description: fieldRelationship.ownerField.description\n      }\n\n      typeComposer.extendField(fieldRelationship.ownerField.name, partialConfig)\n    }\n  }\n}\n\n/**\n * Extend one-to-many field by adding filter arguments\n *\n * @param {ModelDefinition} model - Graphback model definition\n * @param {ObjectTypeComposer} typeComposer - GraphQL Compose Type composer for the model\n */\nexport function extendOneToManyFieldArguments (model: ModelDefinition, typeComposer: ObjectTypeComposer): void {\n  const modelType = model.graphqlType\n  const modelFields = modelType.getFields()\n\n  for (const current of model.relationships) {\n    if (modelFields[current.ownerField.name]) {\n      const fieldNamedType = getNamedType(current.ownerField.type) as GraphQLObjectType\n\n      if (current.kind !== 'oneToMany') {\n        continue\n      }\n\n      const partialConfig: Partial<ObjectTypeComposerFieldConfigAsObjectDefinition<any, any>> = {\n        args: {\n          filter: getInputTypeName(fieldNamedType.name, GraphbackOperationType.FIND)\n        }\n      }\n\n      typeComposer.extendField(current.ownerField.name, partialConfig)\n    }\n  }\n}\n","import { GraphQLField } from 'graphql'\nimport { parseMetadata } from 'graphql-metadata'\n\n/**\n *  Return true if the GraphQL field has a @transient annotation\n *\n * @param {GraphQLField} field\n */\nexport function isTransientField (field: GraphQLField<any, any>): boolean {\n  return parseMetadata('transient', field)\n}\n","import { GraphQLObjectType } from 'graphql'\nimport { FieldRelationshipMetadata } from '../relationships/RelationshipMetadataBuilder'\nimport { GraphbackCRUDGeneratorConfig } from './GraphbackCRUDGeneratorConfig'\n\n/**\n * Describe the name and type of primary key\n */\nexport interface FieldDescriptor {\n  name: string\n  type: string\n  transient?: boolean | undefined\n}\n\nexport interface ModelFieldMap {\n  [key: string]: FieldDescriptor\n}\n\n/**\n * Used to encapsulate configuration for the type\n */\nexport interface ModelDefinition {\n  primaryKey: FieldDescriptor\n  fields: ModelFieldMap\n  graphqlType: GraphQLObjectType\n  relationships: FieldRelationshipMetadata[]\n  crudOptions: GraphbackCRUDGeneratorConfig\n  uniqueFields: string[]\n}\n\nexport function getModelByName (name: string, models: ModelDefinition[]): ModelDefinition | undefined {\n  if (!models) {\n    return undefined\n  }\n\n  return models.find((m: ModelDefinition) => m.graphqlType.name === name)\n}\n","import { GraphQLResolveInfo } from 'graphql'\nimport graphqlFields from 'graphql-fields'\nimport { ModelDefinition } from './ModelDefinition'\n\n/**\n * Find selectable fields from resolve info for a given model starting on a given path\n * @param info - the resolver info object\n * @param model - the model to find the fields from\n * @param path - the root path to start field resolution from.\n */\nexport const getSelectedFieldsFromResolverInfo = (info: GraphQLResolveInfo, model: ModelDefinition, isMutation = false, path?: string): string[] => {\n  let projectionObj = graphqlFields(info, {}, { processArguments: true })\n  if (path) {\n    projectionObj = projectionObj[path]\n  }\n  const resolverFields = Object.keys(projectionObj)\n  const fieldArgs = {}\n  if (!isMutation) {\n    resolverFields.forEach(k => {\n      if (projectionObj[k].__arguments) {\n        fieldArgs[k] = projectionObj[k].__arguments\n      }\n    })\n  }\n\n  return getModelFieldsFromResolverFields(resolverFields, fieldArgs, model)\n}\n\n/**\n * Get the model specific-fields from a full list of fields\n *\n * @param {string[]} resolverFields - resolver field names\n * @param {ModelDefinition} model - Graphback model\n */\nexport const getModelFieldsFromResolverFields = (resolverFields: string[], fieldArgs: any, model: ModelDefinition): string[] => {\n  const selectedFields = new Set<string>()\n\n  for (const key of resolverFields) {\n    const correspondingFieldInDatabase = model.fields[key]\n    if (correspondingFieldInDatabase && !correspondingFieldInDatabase.transient) {\n      selectedFields.add(correspondingFieldInDatabase.name)\n    }\n  }\n\n  return [[...selectedFields], fieldArgs]\n}\n\n/**\n * Find fields list of resolver info starting at a given path.\n * If path is undefined, return top level fields information.\n * @param info - the resolver info object\n * @param path - the root path to start field resolution from\n */\nexport const getResolverInfoFieldsList = (info: GraphQLResolveInfo, path?: string) => fieldsList(info, { path })\n","import { GraphQLSchema } from 'graphql'\nimport { SchemaComposer } from 'graphql-compose'\n\nexport function printSchemaWithDirectives (schemaOrSDL: GraphQLSchema | string): string {\n  const schemaComposer = new SchemaComposer(schemaOrSDL)\n\n  return schemaComposer.toSDL({ exclude: ['String', 'ID', 'Boolean', 'Float', 'Int'] })\n}\n","export const metadataMap = {\n  markers: {\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt',\n    versioned: 'versioned'\n  },\n  fieldNames: {\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt'\n  }\n}\n","import { parseMetadata } from 'graphql-metadata'\nimport { GraphQLObjectType } from 'graphql'\n\nexport type FieldTransformer = (value?: any) => any\n\nexport interface FieldTransform {\n  fieldName: string\n  transform: FieldTransformer\n}\n\n/* eslint-disable no-shadow */\nexport enum TransformType {\n  UPDATE = 'onUpdateFieldTransform',\n  CREATE = 'onCreateFieldTransform',\n}\n/* eslint-enable no-shadow */\n\nexport interface FieldTransformMap {\n  [TransformType.CREATE]: FieldTransform[]\n  [TransformType.UPDATE]: FieldTransform[]\n}\n\nexport function getFieldTransformations (\n  baseType: GraphQLObjectType\n): FieldTransformMap {\n  const fieldMap = baseType.getFields()\n  const fieldTransformMap: FieldTransformMap = {\n    [TransformType.CREATE]: [],\n    [TransformType.UPDATE]: []\n  }\n  for (const field of Object.values(fieldMap)) {\n    if (parseMetadata('updatedAt', field.description)) {\n      fieldTransformMap[TransformType.UPDATE].push({\n        fieldName: field.name,\n        transform: () => {\n          return new Date().getTime()\n        }\n      })\n      fieldTransformMap[TransformType.CREATE].push({\n        fieldName: field.name,\n        transform: () => {\n          return new Date().getTime()\n        }\n      })\n    }\n    if (parseMetadata('createdAt', field.description)) {\n      fieldTransformMap[TransformType.CREATE].push({\n        fieldName: field.name,\n        transform: () => {\n          return new Date().getTime()\n        }\n      })\n    }\n  }\n\n  return fieldTransformMap\n}\n","import DataLoader from 'dataloader'\nimport { PubSubEngine, withFilter } from 'graphql-subscriptions'\nimport { GraphQLResolveInfo } from 'graphql'\nimport { GraphbackCRUDGeneratorConfig, GraphbackOperationType, upperCaseFirstChar, getSubscriptionName } from '..'\nimport { ModelDefinition } from '../plugin/ModelDefinition'\nimport { getSelectedFieldsFromResolverInfo, getResolverInfoFieldsList } from '../plugin/getSelectedFieldsFromResolverInfo'\nimport { createInMemoryFilterPredicate } from './createInMemoryFilterPredicate'\nimport { FindByArgs } from './interfaces'\nimport { QueryFilter } from './QueryFilter'\nimport { GraphbackCRUDService, GraphbackDataProvider, GraphbackContext, ResultList } from '.'\n\n/**\n * Configurations necessary to create a CRUDService\n */\nexport interface CRUDServiceConfig {\n  /**\n   * PubSub implementation for creating subscriptions\n   */\n  pubSub?: PubSubEngine\n\n  /**\n   * Model-specific CRUD configuration\n   */\n  crudOptions: GraphbackCRUDGeneratorConfig\n}\n/**\n * Default implementation of the CRUD service offering following capabilities:\n *\n * - Subscriptions: using default publish subscribe method\n * - Logging: using logging abstraction\n */\n// tslint:disable-next-line: no-any\nexport class CRUDService<Type = any> implements GraphbackCRUDService<Type> {\n  protected db: GraphbackDataProvider\n  protected model: ModelDefinition\n  protected pubSub: PubSubEngine\n  protected crudOptions: GraphbackCRUDGeneratorConfig\n\n  public constructor (model: ModelDefinition, db: GraphbackDataProvider, config: CRUDServiceConfig) {\n    this.model = model\n    this.crudOptions = config.crudOptions\n    this.db = db\n    this.pubSub = config.pubSub\n  }\n\n  public async initializeUniqueIndex() {\n    return await this.db.initializeUniqueIndex(this.model.uniqueFields)\n  }\n\n  public async create (data: Type, context?: GraphbackContext, info?: GraphQLResolveInfo, uniqueFields: string[]): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n\n    const result = await this.db.create(data, selectedFields, uniqueFields)\n\n    if (this.pubSub && this.crudOptions.subCreate) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.CREATE, this.model.graphqlType.name)\n      // TODO use subscription name mapping\n      const payload = this.buildEventPayload('new', result)\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        // eslint-disable-next-line no-console\n        console.error(`Publishing of new \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async update (data: Type, context?: GraphbackContext, info?: GraphQLResolveInfo, uniqueFields: string[]): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n\n    const result = await this.db.update(data, selectedFields, uniqueFields)\n\n    if (this.pubSub && this.crudOptions.subUpdate) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.UPDATE, this.model.graphqlType.name)\n      // TODO use subscription name mapping\n      const payload = this.buildEventPayload('updated', result)\n\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        console.error(`Publishing of updates of \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async updateBy (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo, uniqueFields: string[]): Promise<ResultList<Type>> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.mode, true)\n    const result = await this.db.updateBy(args, selectedFields, uniqueFields)\n\n    return {\n      items: result\n    }\n  }\n\n  public async delete (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo, uniqueFields: string[]): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n    const result = await this.db.delete(data, selectedFields, uniqueFields)\n\n    if (this.pubSub && this.crudOptions.subDelete) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.DELETE, this.model.graphqlType.name)\n      const payload = this.buildEventPayload('deleted', result)\n\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        // eslint-disable-next-line no-console\n        console.error(`Publishing of deletion of \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async deleteBy (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo, uniqueFields: string[]): Promise<ResultList<Type>> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n    const result = await this.db.deleteBy(args, selectedFields, uniqueFields)\n\n    return {\n      items: result\n    }\n  }\n\n  public async findOne (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model)\n    return await this.db.findOne(args, selectedFields)\n  }\n\n  public async findBy (args?: FindByArgs, context?: GraphbackContext, info?: GraphQLResolveInfo, path?: string): Promise<ResultList<Type>> {\n    let requestedCount = false\n    const [selectedFields, fieldArgs] = getSelectedFieldsFromResolverInfo(info, this.model, false, path)\n    requestedCount = path === 'items' && getResolverInfoFieldsList(info).some((field: string) => field === 'count')\n    const items: Type[] = await this.db.findBy(args, selectedFields, fieldArgs)\n\n    // set page values for returned object\n    const resultPageInfo = {\n      offset: 0,\n      ...args?.page\n    }\n\n    let count: number\n    if (requestedCount) {\n      count = await this.db.count(args.filter)\n    }\n\n    return {\n      items,\n      count,\n      offset: 0,\n      ...resultPageInfo\n    }\n  }\n\n  public subscribeToCreate (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.CREATE\n    const createSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(createSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  public subscribeToUpdate (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.UPDATE\n    const updateSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(updateSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  public subscribeToDelete (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.DELETE\n    const deleteSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(deleteSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  public batchLoadData (relationField: string, id: string | number, filter: QueryFilter, context: GraphbackContext, info?: GraphQLResolveInfo) {\n    const selectedFields = []\n    const [selectedFieldsFromInfo, fieldArgs] = getSelectedFieldsFromResolverInfo(info, this.model)\n    selectedFields.push(...selectedFieldsFromInfo)\n\n    // only push the relation field if there are fields selected\n    // because all fields will be selected otherwise\n    if (selectedFields.length > 0) {\n      selectedFields.push(relationField)\n    }\n\n    const fetchedKeys = selectedFields.join('-')\n    const keyName = `${this.model.graphqlType.name}-${upperCaseFirstChar(relationField)}-${fetchedKeys}-${JSON.stringify(filter)}-DataLoader`\n    if (!context[keyName]) {\n      context[keyName] = new DataLoader<string, any>(async (keys: string[]) => {\n        return await this.db.batchRead(relationField, keys, filter, selectedFields, fieldArgs)\n      })\n    }\n\n    // eslint-disable-next-line no-null/no-null\n    if (id === undefined || id === null) {\n      return []\n    }\n\n    return context[keyName].load(id)\n  }\n\n  /**\n   * Provides way to map runtime topics for subscriptions for specific types and object names\n   */\n  protected subscriptionTopicMapping (triggerType: GraphbackOperationType, objectName: string) {\n    return `${triggerType}_${objectName}`.toUpperCase()\n  }\n\n  private buildEventPayload (action: string, result: any) {\n    const payload = {}\n    payload[`${action}${this.model.graphqlType.name}`] = result\n\n    return payload\n  }\n}\n","/**\n * Helper function to convert a value to another type\n *\n * @param {any} value - Value to convert\n * @param {any} toType - convert value to this type\n */\nexport function convertType (value: any, toType: any): string | number | boolean | BigInt {\n  if (!value) {\n    return undefined\n  }\n\n  switch (typeof toType) {\n    case 'string':\n      return String(value)\n    case 'number':\n      return Number(value)\n    case 'bigint':\n      return BigInt(value)\n    case 'boolean':\n      return Boolean(value)\n    case 'object':\n      if (isDateObject(value)) {\n        return new Date(value).getTime()\n      }\n\n      return value\n    default:\n      return String(value)\n  }\n}\n\n/**\n * Check if value is a Date object\n *\n * @param {any} value\n */\nexport const isDateObject = (value: any): boolean => Object.prototype.toString.call(value) === '[object Date]'\n","import { convertType, isDateObject } from '../utils/convertType'\nimport { QueryFilter } from './QueryFilter'\n\ntype PredicateFn = (input: any) => boolean\ntype InputType = number | string | boolean | Date\n\ninterface IPredicate {\n  eq: (filterValue: InputType) => PredicateFn\n  ne: (filterValue: InputType) => PredicateFn\n  gt: (filterValue: InputType) => PredicateFn\n  ge: (filterValue: InputType) => PredicateFn\n  le: (filterValue: InputType) => PredicateFn\n  lt: (filterValue: InputType) => PredicateFn\n  in: (filterValue: InputType[]) => PredicateFn\n  between: (filterValue: InputType[]) => PredicateFn\n  contains: (filterValue: InputType) => PredicateFn\n  startsWith: (filterValue: string) => PredicateFn\n  endsWith: (filterValue: string) => PredicateFn\n}\n\nconst predicateMap: IPredicate = {\n  eq: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue?.toString() === parsedFilterValue?.toString()\n  },\n  ne: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFilterValue?.toString() !== parsedFieldValue?.toString()\n  },\n  gt: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue > parsedFilterValue\n  },\n  ge: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue >= parsedFilterValue\n  },\n  le: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue <= parsedFilterValue\n  },\n  lt: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue < parsedFilterValue\n  },\n  in: (filterValue: InputType[]) => (fieldValue: InputType) => {\n    return filterValue.map((f: InputType) => f?.toString()).includes(fieldValue?.toString())\n  },\n  between: ([fromVal, toVal]: InputType[]) => (fieldValue: InputType) => {\n    if (isDateObject(fieldValue)) {\n      const fieldValDate = convertType(fieldValue, fieldValue)\n      const fromValDate = convertType(fromVal, fieldValue)\n      const toValDate = convertType(toVal, fieldValue)\n\n      return fieldValDate >= fromValDate && fieldValDate <= toValDate\n    }\n\n    const parsedFieldValue = Number(fieldValue)\n\n    return parsedFieldValue >= Number(fromVal) && parsedFieldValue <= Number(toVal)\n  },\n  contains: (filterValue: InputType = '') => (fieldValue: InputType = '') => {\n    return fieldValue?.toString().includes(filterValue?.toString())\n  },\n  startsWith: (filterValue: string = '') => (fieldValue: string = '') => {\n    return fieldValue?.toString().startsWith(filterValue?.toString())\n  },\n  endsWith: (filterValue: string = '') => (fieldValue: string = '') => {\n    return fieldValue?.toString().endsWith(filterValue?.toString())\n  }\n}\n\n/**\n * Dynamically creates a subscription filter predicate using the filter object values\n *\n * @param {QueryFilter} filter - subscription filter input object\n */\nexport function createInMemoryFilterPredicate<T = any> (filter: QueryFilter): (input: Partial<T>) => boolean {\n  filter = filter || {}\n  const andFilter = filter.and\n  const orFilter = filter.or\n  const notFilter = filter.not\n\n  const filterFields = Object.keys(filter).filter((key: string) => !['and', 'or', 'not'].includes(key))\n\n  return (payload: Partial<T>): boolean => {\n    let predicateResult = true\n    for (const fieldName of filterFields) {\n      // skip these filter expressions\n      if (['and', 'or', 'not'].includes(fieldName)) {\n        continue\n      }\n\n      const fieldFilter = filter[fieldName]\n\n      for (const [expr, exprVal] of Object.entries(fieldFilter)) {\n        const predicateFn: PredicateFn = predicateMap[expr](exprVal)\n\n        if (!predicateFn(payload[fieldName])) {\n          predicateResult = false\n          break\n        }\n      }\n    }\n\n    if (orFilter != null) {\n      const orPredicateResult = getOrPredicateResult<T>(orFilter, payload)\n      predicateResult = predicateResult && orPredicateResult\n      if (!predicateResult) {\n        return false\n      }\n    }\n    if (andFilter != null) {\n      const andPredicateResult = getAndPredicateResult(andFilter, payload)\n      predicateResult = predicateResult && andPredicateResult\n    }\n    if (notFilter != null) {\n      const notPredicateResult = createInMemoryFilterPredicate<T>(notFilter)(payload)\n      predicateResult = predicateResult && !notPredicateResult\n    }\n\n    return predicateResult\n  }\n}\n\n/**\n * Get the predicate result of an `and` filter expression\n *\n * @param {QueryFilter[]} and - And filter\n * @param {Partial<T>} payload - Subscription payload\n */\nfunction getAndPredicateResult<T> (and: QueryFilter[], payload: Partial<T>): boolean {\n  let andResult = true\n\n  for (const andItem of and) {\n    andResult = createInMemoryFilterPredicate<T>(andItem)(payload)\n\n    if (!andResult) {\n      break\n    }\n  }\n\n  return andResult\n}\n\n/**\n * Get the boolean result of an `or` filter expression\n *\n * @param {QueryFilter[]} or - Or query filter\n * @param {Partial<T>} payload - Subscription payload\n */\nfunction getOrPredicateResult<T> (or: QueryFilter[], payload: Partial<T>): boolean {\n  let orResult = true\n\n  for (const orItem of or) {\n    orResult = createInMemoryFilterPredicate<T>(orItem)(payload)\n\n    if (orResult) {\n      break\n    }\n  }\n\n  return orResult\n}\n","import { PubSubEngine, PubSub } from 'graphql-subscriptions'\nimport { ModelDefinition } from '..'\nimport { CRUDServiceConfig, CRUDService } from './CRUDService'\nimport { GraphbackDataProvider, GraphbackCRUDService, ServiceCreator } from '.'\n\nexport interface CreateCRUDServiceOptions {\n  /**\n   * PubSub implementation for creating subscriptions\n   */\n  pubSub?: PubSubEngine\n}\n\nexport function createCRUDService (config?: CreateCRUDServiceOptions): ServiceCreator {\n  return async (model: ModelDefinition, dataProvider: GraphbackDataProvider): GraphbackCRUDService => {\n    const serviceConfig: CRUDServiceConfig = {\n      pubSub: new PubSub(),\n      ...config,\n      crudOptions: model.crudOptions\n    }\n\n    const crudService = new CRUDService(model, dataProvider, serviceConfig)\n\n    await crudService.initializeUniqueIndex()\n\n    return crudService\n  }\n}","/**\n * Error thrown when database query succeded without any data\n * which is not handled by GraphQL specification\n */\nexport class NoDataError extends Error {\n  public constructor (message: string) {\n    super(`No result from database: ${message}`)\n  }\n}\n","/**\n * Filter mapping for scalars that exit\n */\nexport interface Scalars {\n  ID: string\n  String: string\n  Boolean: boolean\n  Int: number\n  Float: number\n  JSON: any\n  JSONObject: { [key: string]: any }\n  BigInt: number\n  Byte: string\n  Currency: string\n  DID: string\n  Duration: string\n  EmailAddress: string\n  GUID: string\n  HSL: string\n  HSLA: string\n  HexColorCode: string\n  Hexadecimal: string\n  IBAN: string\n  IPv4: string\n  IPv6: string\n  ISBN: string\n  ISO8601Duration: string\n  JWT: any\n  Latitude: number\n  LocalDate: string\n  LocalEndTime: string\n  LocalTime: string\n  Longitude: number\n  MAC: string\n  NegativeFloat: number\n  NegativeInt: number\n  NonEmptyString: string\n  NonNegativeFloat: number\n  NonNegativeInt: number\n  NonPositiveFloat: number\n  NonPositiveInt: number\n  PhoneNumber: string\n  Port: number\n  PositiveFloat: number\n  PositiveInt: number\n  PostalCode: string\n  RGB: string\n  RGBA: string\n  URL: string\n  USCurrency: string\n  UUID: string\n  UtcOffset: string\n  Timestamp: number\n  Time: string\n  Date: Date\n  DateTime: Date\n}\n\n// Names of the scalars that support Graphback filter type generation\nexport const FILTER_SUPPORTED_SCALARS = [\n  'ID', 'String', 'Boolean', 'Int', 'Float', 'Timestamp',\n  'Time', 'Date', 'DateTime', 'BigInt', 'Byte', 'Currency', 'DID', 'Duration', 'EmailAddress',\n  'GUID', 'HSL', 'HSLA', 'HexColorCode', 'Hexadecimal', 'IBAN', 'IPv4', 'IPv6', 'ISBN',\n  'ISO8601Duration', 'Latitude', 'LocalDate', 'LocalEndTime', 'LocalTime',\n  'Longitude', 'MAC', 'NegativeFloat', 'NegativeInt', 'NonEmptyString', 'NonNegativeFloat',\n  'NonNegativeInt', 'NonPositiveFloat', 'NonPositiveInt', 'PhoneNumber', 'Port', 'PositiveFloat',\n  'PositiveInt', 'PostalCode', 'RGB', 'RGBA', 'URL', 'USCurrency', 'UUID', 'UtcOffset'\n]\n\nexport type Maybe<T> = T | null\n\nexport interface BooleanInput {\n  ne?: Maybe<Scalars['Boolean']>\n  eq?: Maybe<Scalars['Boolean']>\n}\n\nexport interface FloatInput {\n  ne?: Maybe<Scalars['Float']>\n  eq?: Maybe<Scalars['Float']>\n  le?: Maybe<Scalars['Float']>\n  lt?: Maybe<Scalars['Float']>\n  ge?: Maybe<Scalars['Float']>\n  gt?: Maybe<Scalars['Float']>\n  in?: Maybe<Array<Scalars['Float']>>\n  between?: Maybe<Array<Scalars['Float']>>\n}\n\nexport interface IdInput {\n  ne?: Maybe<Scalars['ID']>\n  eq?: Maybe<Scalars['ID']>\n  le?: Maybe<Scalars['ID']>\n  lt?: Maybe<Scalars['ID']>\n  ge?: Maybe<Scalars['ID']>\n  gt?: Maybe<Scalars['ID']>\n  in?: Maybe<Array<Scalars['ID']>>\n}\n\nexport interface IntInput {\n  ne?: Maybe<Scalars['Int']>\n  eq?: Maybe<Scalars['Int']>\n  le?: Maybe<Scalars['Int']>\n  lt?: Maybe<Scalars['Int']>\n  ge?: Maybe<Scalars['Int']>\n  gt?: Maybe<Scalars['Int']>\n  in?: Maybe<Scalars['Int']>\n  between?: Maybe<Array<Scalars['Int']>>\n}\n\nexport interface StringInput {\n  ne?: Maybe<Scalars['String']>\n  eq?: Maybe<Scalars['String']>\n  le?: Maybe<Scalars['String']>\n  lt?: Maybe<Scalars['String']>\n  ge?: Maybe<Scalars['String']>\n  gt?: Maybe<Scalars['String']>\n  in?: Maybe<Array<Scalars['String']>>\n  contains?: Maybe<Scalars['String']>\n  startsWith?: Maybe<Scalars['String']>\n  endsWith?: Maybe<Scalars['String']>\n}\n\nexport interface DateInput {\n  ne?: Maybe<Scalars['Date']>\n  eq?: Maybe<Scalars['Date']>\n  le?: Maybe<Scalars['Date']>\n  lt?: Maybe<Scalars['Date']>\n  ge?: Maybe<Scalars['Date']>\n  gt?: Maybe<Scalars['Date']>\n  in?: Maybe<Array<Scalars['Date']>>\n  between?: Maybe<Array<Scalars['Date']>>\n}\n\nexport interface DateTimeInput {\n  ne?: Maybe<Scalars['DateTime']>\n  eq?: Maybe<Scalars['DateTime']>\n  le?: Maybe<Scalars['DateTime']>\n  lt?: Maybe<Scalars['DateTime']>\n  ge?: Maybe<Scalars['DateTime']>\n  gt?: Maybe<Scalars['DateTime']>\n  in?: Maybe<Array<Scalars['DateTime']>>\n  between?: Maybe<Array<Scalars['DateTime']>>\n}\n\nexport interface TimeInput {\n  ne?: Maybe<Scalars['Time']>\n  eq?: Maybe<Scalars['Time']>\n  le?: Maybe<Scalars['Time']>\n  lt?: Maybe<Scalars['Time']>\n  ge?: Maybe<Scalars['Time']>\n  gt?: Maybe<Scalars['Time']>\n  in?: Maybe<Array<Scalars['Time']>>\n  between?: Maybe<Array<Scalars['Time']>>\n}\n\nexport interface TimestampInput {\n  ne?: Maybe<Scalars['Timestamp']>\n  eq?: Maybe<Scalars['Timestamp']>\n  le?: Maybe<Scalars['Timestamp']>\n  lt?: Maybe<Scalars['Timestamp']>\n  ge?: Maybe<Scalars['Timestamp']>\n  gt?: Maybe<Scalars['Timestamp']>\n  in?: Maybe<Array<Scalars['Timestamp']>>\n  between?: Maybe<Array<Scalars['Timestamp']>>\n}\n\nexport interface BigIntInput {\n  ne?: Maybe<Scalars['BigInt']>\n  eq?: Maybe<Scalars['BigInt']>\n  le?: Maybe<Scalars['BigInt']>\n  lt?: Maybe<Scalars['BigInt']>\n  ge?: Maybe<Scalars['BigInt']>\n  gt?: Maybe<Scalars['BigInt']>\n  in?: Maybe<Scalars['BigInt']>\n  between?: Maybe<Array<Scalars['BigInt']>>\n}\nexport interface ByteInput {\n  ne?: Maybe<Scalars['Byte']>\n  eq?: Maybe<Scalars['Byte']>\n  le?: Maybe<Scalars['Byte']>\n  lt?: Maybe<Scalars['Byte']>\n  ge?: Maybe<Scalars['Byte']>\n  gt?: Maybe<Scalars['Byte']>\n  in?: Maybe<Array<Scalars['Byte']>>\n  contains?: Maybe<Scalars['Byte']>\n  startsWith?: Maybe<Scalars['Byte']>\n  endsWith?: Maybe<Scalars['Byte']>\n}\nexport interface CurrencyInput {\n  ne?: Maybe<Scalars['Currency']>\n  eq?: Maybe<Scalars['Currency']>\n  le?: Maybe<Scalars['Currency']>\n  lt?: Maybe<Scalars['Currency']>\n  ge?: Maybe<Scalars['Currency']>\n  gt?: Maybe<Scalars['Currency']>\n  in?: Maybe<Array<Scalars['Currency']>>\n  contains?: Maybe<Scalars['Currency']>\n  startsWith?: Maybe<Scalars['Currency']>\n  endsWith?: Maybe<Scalars['Currency']>\n}\nexport interface DIDInput {\n  ne?: Maybe<Scalars['DID']>\n  eq?: Maybe<Scalars['DID']>\n  le?: Maybe<Scalars['DID']>\n  lt?: Maybe<Scalars['DID']>\n  ge?: Maybe<Scalars['DID']>\n  gt?: Maybe<Scalars['DID']>\n  in?: Maybe<Array<Scalars['DID']>>\n  contains?: Maybe<Scalars['DID']>\n  startsWith?: Maybe<Scalars['DID']>\n  endsWith?: Maybe<Scalars['DID']>\n}\nexport interface DurationInput {\n  ne?: Maybe<Scalars['Duration']>\n  eq?: Maybe<Scalars['Duration']>\n  le?: Maybe<Scalars['Duration']>\n  lt?: Maybe<Scalars['Duration']>\n  ge?: Maybe<Scalars['Duration']>\n  gt?: Maybe<Scalars['Duration']>\n  in?: Maybe<Array<Scalars['Duration']>>\n  contains?: Maybe<Scalars['Duration']>\n  startsWith?: Maybe<Scalars['Duration']>\n  endsWith?: Maybe<Scalars['Duration']>\n}\nexport interface EmailAddressInput {\n  ne?: Maybe<Scalars['EmailAddress']>\n  eq?: Maybe<Scalars['EmailAddress']>\n  le?: Maybe<Scalars['EmailAddress']>\n  lt?: Maybe<Scalars['EmailAddress']>\n  ge?: Maybe<Scalars['EmailAddress']>\n  gt?: Maybe<Scalars['EmailAddress']>\n  in?: Maybe<Array<Scalars['EmailAddress']>>\n  contains?: Maybe<Scalars['EmailAddress']>\n  startsWith?: Maybe<Scalars['EmailAddress']>\n  endsWith?: Maybe<Scalars['EmailAddress']>\n}\nexport interface GUIDInput {\n  ne?: Maybe<Scalars['GUID']>\n  eq?: Maybe<Scalars['GUID']>\n  le?: Maybe<Scalars['GUID']>\n  lt?: Maybe<Scalars['GUID']>\n  ge?: Maybe<Scalars['GUID']>\n  gt?: Maybe<Scalars['GUID']>\n  in?: Maybe<Array<Scalars['GUID']>>\n  contains?: Maybe<Scalars['GUID']>\n  startsWith?: Maybe<Scalars['GUID']>\n  endsWith?: Maybe<Scalars['GUID']>\n}\nexport interface HSLInput {\n  ne?: Maybe<Scalars['HSL']>\n  eq?: Maybe<Scalars['HSL']>\n  le?: Maybe<Scalars['HSL']>\n  lt?: Maybe<Scalars['HSL']>\n  ge?: Maybe<Scalars['HSL']>\n  gt?: Maybe<Scalars['HSL']>\n  in?: Maybe<Array<Scalars['HSL']>>\n  contains?: Maybe<Scalars['HSL']>\n  startsWith?: Maybe<Scalars['HSL']>\n  endsWith?: Maybe<Scalars['HSL']>\n}\nexport interface HSLAInput {\n  ne?: Maybe<Scalars['HSLA']>\n  eq?: Maybe<Scalars['HSLA']>\n  le?: Maybe<Scalars['HSLA']>\n  lt?: Maybe<Scalars['HSLA']>\n  ge?: Maybe<Scalars['HSLA']>\n  gt?: Maybe<Scalars['HSLA']>\n  in?: Maybe<Array<Scalars['HSLA']>>\n  contains?: Maybe<Scalars['HSLA']>\n  startsWith?: Maybe<Scalars['HSLA']>\n  endsWith?: Maybe<Scalars['HSLA']>\n}\nexport interface HexColorCodeInput {\n  ne?: Maybe<Scalars['HexColorCode']>\n  eq?: Maybe<Scalars['HexColorCode']>\n  le?: Maybe<Scalars['HexColorCode']>\n  lt?: Maybe<Scalars['HexColorCode']>\n  ge?: Maybe<Scalars['HexColorCode']>\n  gt?: Maybe<Scalars['HexColorCode']>\n  in?: Maybe<Array<Scalars['HexColorCode']>>\n  contains?: Maybe<Scalars['HexColorCode']>\n  startsWith?: Maybe<Scalars['HexColorCode']>\n  endsWith?: Maybe<Scalars['HexColorCode']>\n}\nexport interface HexadecimalInput {\n  ne?: Maybe<Scalars['Hexadecimal']>\n  eq?: Maybe<Scalars['Hexadecimal']>\n  le?: Maybe<Scalars['Hexadecimal']>\n  lt?: Maybe<Scalars['Hexadecimal']>\n  ge?: Maybe<Scalars['Hexadecimal']>\n  gt?: Maybe<Scalars['Hexadecimal']>\n  in?: Maybe<Array<Scalars['Hexadecimal']>>\n  contains?: Maybe<Scalars['Hexadecimal']>\n  startsWith?: Maybe<Scalars['Hexadecimal']>\n  endsWith?: Maybe<Scalars['Hexadecimal']>\n}\nexport interface IBANInput {\n  ne?: Maybe<Scalars['IBAN']>\n  eq?: Maybe<Scalars['IBAN']>\n  le?: Maybe<Scalars['IBAN']>\n  lt?: Maybe<Scalars['IBAN']>\n  ge?: Maybe<Scalars['IBAN']>\n  gt?: Maybe<Scalars['IBAN']>\n  in?: Maybe<Array<Scalars['IBAN']>>\n  contains?: Maybe<Scalars['IBAN']>\n  startsWith?: Maybe<Scalars['IBAN']>\n  endsWith?: Maybe<Scalars['IBAN']>\n}\nexport interface IPv4Input {\n  ne?: Maybe<Scalars['IPv4']>\n  eq?: Maybe<Scalars['IPv4']>\n  le?: Maybe<Scalars['IPv4']>\n  lt?: Maybe<Scalars['IPv4']>\n  ge?: Maybe<Scalars['IPv4']>\n  gt?: Maybe<Scalars['IPv4']>\n  in?: Maybe<Array<Scalars['IPv4']>>\n  contains?: Maybe<Scalars['IPv4']>\n  startsWith?: Maybe<Scalars['IPv4']>\n  endsWith?: Maybe<Scalars['IPv4']>\n}\nexport interface IPv6Input {\n  ne?: Maybe<Scalars['IPv6']>\n  eq?: Maybe<Scalars['IPv6']>\n  le?: Maybe<Scalars['IPv6']>\n  lt?: Maybe<Scalars['IPv6']>\n  ge?: Maybe<Scalars['IPv6']>\n  gt?: Maybe<Scalars['IPv6']>\n  in?: Maybe<Array<Scalars['IPv6']>>\n  contains?: Maybe<Scalars['IPv6']>\n  startsWith?: Maybe<Scalars['IPv6']>\n  endsWith?: Maybe<Scalars['IPv6']>\n}\nexport interface ISBNInput {\n  ne?: Maybe<Scalars['ISBN']>\n  eq?: Maybe<Scalars['ISBN']>\n  le?: Maybe<Scalars['ISBN']>\n  lt?: Maybe<Scalars['ISBN']>\n  ge?: Maybe<Scalars['ISBN']>\n  gt?: Maybe<Scalars['ISBN']>\n  in?: Maybe<Array<Scalars['ISBN']>>\n  contains?: Maybe<Scalars['ISBN']>\n  startsWith?: Maybe<Scalars['ISBN']>\n  endsWith?: Maybe<Scalars['ISBN']>\n}\nexport interface ISO8601DurationInput {\n  ne?: Maybe<Scalars['ISO8601Duration']>\n  eq?: Maybe<Scalars['ISO8601Duration']>\n  le?: Maybe<Scalars['ISO8601Duration']>\n  lt?: Maybe<Scalars['ISO8601Duration']>\n  ge?: Maybe<Scalars['ISO8601Duration']>\n  gt?: Maybe<Scalars['ISO8601Duration']>\n  in?: Maybe<Array<Scalars['ISO8601Duration']>>\n  contains?: Maybe<Scalars['ISO8601Duration']>\n  startsWith?: Maybe<Scalars['ISO8601Duration']>\n  endsWith?: Maybe<Scalars['ISO8601Duration']>\n}\nexport interface LatitudeInput {\n  ne?: Maybe<Scalars['Latitude']>\n  eq?: Maybe<Scalars['Latitude']>\n  le?: Maybe<Scalars['Latitude']>\n  lt?: Maybe<Scalars['Latitude']>\n  ge?: Maybe<Scalars['Latitude']>\n  gt?: Maybe<Scalars['Latitude']>\n  in?: Maybe<Scalars['Latitude']>\n  between?: Maybe<Array<Scalars['Latitude']>>\n}\nexport interface LocalDateInput {\n  ne?: Maybe<Scalars['LocalDate']>\n  eq?: Maybe<Scalars['LocalDate']>\n  le?: Maybe<Scalars['LocalDate']>\n  lt?: Maybe<Scalars['LocalDate']>\n  ge?: Maybe<Scalars['LocalDate']>\n  gt?: Maybe<Scalars['LocalDate']>\n  in?: Maybe<Array<Scalars['LocalDate']>>\n  between?: Maybe<Array<Scalars['LocalDate']>>\n}\nexport interface LocalEndTimeInput {\n  ne?: Maybe<Scalars['LocalEndTime']>\n  eq?: Maybe<Scalars['LocalEndTime']>\n  le?: Maybe<Scalars['LocalEndTime']>\n  lt?: Maybe<Scalars['LocalEndTime']>\n  ge?: Maybe<Scalars['LocalEndTime']>\n  gt?: Maybe<Scalars['LocalEndTime']>\n  in?: Maybe<Array<Scalars['LocalEndTime']>>\n  contains?: Maybe<Scalars['LocalEndTime']>\n  startsWith?: Maybe<Scalars['LocalEndTime']>\n  endsWith?: Maybe<Scalars['LocalEndTime']>\n}\nexport interface LocalTimeInput {\n  ne?: Maybe<Scalars['LocalTime']>\n  eq?: Maybe<Scalars['LocalTime']>\n  le?: Maybe<Scalars['LocalTime']>\n  lt?: Maybe<Scalars['LocalTime']>\n  ge?: Maybe<Scalars['LocalTime']>\n  gt?: Maybe<Scalars['LocalTime']>\n  in?: Maybe<Array<Scalars['LocalTime']>>\n  between?: Maybe<Array<Scalars['LocalTime']>>\n}\nexport interface LongitudeInput {\n  ne?: Maybe<Scalars['Longitude']>\n  eq?: Maybe<Scalars['Longitude']>\n  le?: Maybe<Scalars['Longitude']>\n  lt?: Maybe<Scalars['Longitude']>\n  ge?: Maybe<Scalars['Longitude']>\n  gt?: Maybe<Scalars['Longitude']>\n  in?: Maybe<Scalars['Longitude']>\n  between?: Maybe<Array<Scalars['Longitude']>>\n}\nexport interface MACInput {\n  ne?: Maybe<Scalars['MAC']>\n  eq?: Maybe<Scalars['MAC']>\n  le?: Maybe<Scalars['MAC']>\n  lt?: Maybe<Scalars['MAC']>\n  ge?: Maybe<Scalars['MAC']>\n  gt?: Maybe<Scalars['MAC']>\n  in?: Maybe<Array<Scalars['MAC']>>\n  contains?: Maybe<Scalars['MAC']>\n  startsWith?: Maybe<Scalars['MAC']>\n  endsWith?: Maybe<Scalars['MAC']>\n}\nexport interface NegativeFloatInput {\n  ne?: Maybe<Scalars['NegativeFloat']>\n  eq?: Maybe<Scalars['NegativeFloat']>\n  le?: Maybe<Scalars['NegativeFloat']>\n  lt?: Maybe<Scalars['NegativeFloat']>\n  ge?: Maybe<Scalars['NegativeFloat']>\n  gt?: Maybe<Scalars['NegativeFloat']>\n  in?: Maybe<Array<Scalars['NegativeFloat']>>\n  between?: Maybe<Array<Scalars['NegativeFloat']>>\n}\nexport interface NegativeIntInput {\n  ne?: Maybe<Scalars['NegativeInt']>\n  eq?: Maybe<Scalars['NegativeInt']>\n  le?: Maybe<Scalars['NegativeInt']>\n  lt?: Maybe<Scalars['NegativeInt']>\n  ge?: Maybe<Scalars['NegativeInt']>\n  gt?: Maybe<Scalars['NegativeInt']>\n  in?: Maybe<Scalars['NegativeInt']>\n  between?: Maybe<Array<Scalars['NegativeInt']>>\n}\nexport interface NonEmptyStringInput {\n  ne?: Maybe<Scalars['NonEmptyString']>\n  eq?: Maybe<Scalars['NonEmptyString']>\n  le?: Maybe<Scalars['NonEmptyString']>\n  lt?: Maybe<Scalars['NonEmptyString']>\n  ge?: Maybe<Scalars['NonEmptyString']>\n  gt?: Maybe<Scalars['NonEmptyString']>\n  in?: Maybe<Array<Scalars['NonEmptyString']>>\n  contains?: Maybe<Scalars['NonEmptyString']>\n  startsWith?: Maybe<Scalars['NonEmptyString']>\n  endsWith?: Maybe<Scalars['NonEmptyString']>\n}\nexport interface NonNegativeFloatInput {\n  ne?: Maybe<Scalars['NonNegativeFloat']>\n  eq?: Maybe<Scalars['NonNegativeFloat']>\n  le?: Maybe<Scalars['NonNegativeFloat']>\n  lt?: Maybe<Scalars['NonNegativeFloat']>\n  ge?: Maybe<Scalars['NonNegativeFloat']>\n  gt?: Maybe<Scalars['NonNegativeFloat']>\n  in?: Maybe<Array<Scalars['NonNegativeFloat']>>\n  between?: Maybe<Array<Scalars['NonNegativeFloat']>>\n}\nexport interface NonNegativeIntInput {\n  ne?: Maybe<Scalars['NonNegativeInt']>\n  eq?: Maybe<Scalars['NonNegativeInt']>\n  le?: Maybe<Scalars['NonNegativeInt']>\n  lt?: Maybe<Scalars['NonNegativeInt']>\n  ge?: Maybe<Scalars['NonNegativeInt']>\n  gt?: Maybe<Scalars['NonNegativeInt']>\n  in?: Maybe<Scalars['NonNegativeInt']>\n  between?: Maybe<Array<Scalars['NonNegativeInt']>>\n}\nexport interface NonPositiveFloatInput {\n  ne?: Maybe<Scalars['NonPositiveFloat']>\n  eq?: Maybe<Scalars['NonPositiveFloat']>\n  le?: Maybe<Scalars['NonPositiveFloat']>\n  lt?: Maybe<Scalars['NonPositiveFloat']>\n  ge?: Maybe<Scalars['NonPositiveFloat']>\n  gt?: Maybe<Scalars['NonPositiveFloat']>\n  in?: Maybe<Array<Scalars['NonPositiveFloat']>>\n  between?: Maybe<Array<Scalars['NonPositiveFloat']>>\n}\nexport interface NonPositiveIntInput {\n  ne?: Maybe<Scalars['NonPositiveInt']>\n  eq?: Maybe<Scalars['NonPositiveInt']>\n  le?: Maybe<Scalars['NonPositiveInt']>\n  lt?: Maybe<Scalars['NonPositiveInt']>\n  ge?: Maybe<Scalars['NonPositiveInt']>\n  gt?: Maybe<Scalars['NonPositiveInt']>\n  in?: Maybe<Scalars['NonPositiveInt']>\n  between?: Maybe<Array<Scalars['NonPositiveInt']>>\n}\nexport interface PhoneNumberInput {\n  ne?: Maybe<Scalars['PhoneNumber']>\n  eq?: Maybe<Scalars['PhoneNumber']>\n  le?: Maybe<Scalars['PhoneNumber']>\n  lt?: Maybe<Scalars['PhoneNumber']>\n  ge?: Maybe<Scalars['PhoneNumber']>\n  gt?: Maybe<Scalars['PhoneNumber']>\n  in?: Maybe<Array<Scalars['PhoneNumber']>>\n  contains?: Maybe<Scalars['PhoneNumber']>\n  startsWith?: Maybe<Scalars['PhoneNumber']>\n  endsWith?: Maybe<Scalars['PhoneNumber']>\n}\nexport interface PortInput {\n  ne?: Maybe<Scalars['Port']>\n  eq?: Maybe<Scalars['Port']>\n  le?: Maybe<Scalars['Port']>\n  lt?: Maybe<Scalars['Port']>\n  ge?: Maybe<Scalars['Port']>\n  gt?: Maybe<Scalars['Port']>\n  in?: Maybe<Scalars['Port']>\n  between?: Maybe<Array<Scalars['Port']>>\n}\nexport interface PositiveFloatInput {\n  ne?: Maybe<Scalars['PositiveFloat']>\n  eq?: Maybe<Scalars['PositiveFloat']>\n  le?: Maybe<Scalars['PositiveFloat']>\n  lt?: Maybe<Scalars['PositiveFloat']>\n  ge?: Maybe<Scalars['PositiveFloat']>\n  gt?: Maybe<Scalars['PositiveFloat']>\n  in?: Maybe<Array<Scalars['PositiveFloat']>>\n  between?: Maybe<Array<Scalars['PositiveFloat']>>\n}\nexport interface PositiveIntInput {\n  ne?: Maybe<Scalars['PositiveInt']>\n  eq?: Maybe<Scalars['PositiveInt']>\n  le?: Maybe<Scalars['PositiveInt']>\n  lt?: Maybe<Scalars['PositiveInt']>\n  ge?: Maybe<Scalars['PositiveInt']>\n  gt?: Maybe<Scalars['PositiveInt']>\n  in?: Maybe<Scalars['PositiveInt']>\n  between?: Maybe<Array<Scalars['PositiveInt']>>\n}\nexport interface PostalCodeInput {\n  ne?: Maybe<Scalars['PostalCode']>\n  eq?: Maybe<Scalars['PostalCode']>\n  le?: Maybe<Scalars['PostalCode']>\n  lt?: Maybe<Scalars['PostalCode']>\n  ge?: Maybe<Scalars['PostalCode']>\n  gt?: Maybe<Scalars['PostalCode']>\n  in?: Maybe<Array<Scalars['PostalCode']>>\n  contains?: Maybe<Scalars['PostalCode']>\n  startsWith?: Maybe<Scalars['PostalCode']>\n  endsWith?: Maybe<Scalars['PostalCode']>\n}\nexport interface RGBInput {\n  ne?: Maybe<Scalars['RGB']>\n  eq?: Maybe<Scalars['RGB']>\n  le?: Maybe<Scalars['RGB']>\n  lt?: Maybe<Scalars['RGB']>\n  ge?: Maybe<Scalars['RGB']>\n  gt?: Maybe<Scalars['RGB']>\n  in?: Maybe<Array<Scalars['RGB']>>\n  contains?: Maybe<Scalars['RGB']>\n  startsWith?: Maybe<Scalars['RGB']>\n  endsWith?: Maybe<Scalars['RGB']>\n}\nexport interface RGBAInput {\n  ne?: Maybe<Scalars['RGBA']>\n  eq?: Maybe<Scalars['RGBA']>\n  le?: Maybe<Scalars['RGBA']>\n  lt?: Maybe<Scalars['RGBA']>\n  ge?: Maybe<Scalars['RGBA']>\n  gt?: Maybe<Scalars['RGBA']>\n  in?: Maybe<Array<Scalars['RGBA']>>\n  contains?: Maybe<Scalars['RGBA']>\n  startsWith?: Maybe<Scalars['RGBA']>\n  endsWith?: Maybe<Scalars['RGBA']>\n}\nexport interface URLInput {\n  ne?: Maybe<Scalars['URL']>\n  eq?: Maybe<Scalars['URL']>\n  le?: Maybe<Scalars['URL']>\n  lt?: Maybe<Scalars['URL']>\n  ge?: Maybe<Scalars['URL']>\n  gt?: Maybe<Scalars['URL']>\n  in?: Maybe<Array<Scalars['URL']>>\n  contains?: Maybe<Scalars['URL']>\n  startsWith?: Maybe<Scalars['URL']>\n  endsWith?: Maybe<Scalars['URL']>\n}\nexport interface USCurrencyInput {\n  ne?: Maybe<Scalars['USCurrency']>\n  eq?: Maybe<Scalars['USCurrency']>\n  le?: Maybe<Scalars['USCurrency']>\n  lt?: Maybe<Scalars['USCurrency']>\n  ge?: Maybe<Scalars['USCurrency']>\n  gt?: Maybe<Scalars['USCurrency']>\n  in?: Maybe<Array<Scalars['USCurrency']>>\n  contains?: Maybe<Scalars['USCurrency']>\n  startsWith?: Maybe<Scalars['USCurrency']>\n  endsWith?: Maybe<Scalars['USCurrency']>\n}\nexport interface UUIDInput {\n  ne?: Maybe<Scalars['UUID']>\n  eq?: Maybe<Scalars['UUID']>\n  le?: Maybe<Scalars['UUID']>\n  lt?: Maybe<Scalars['UUID']>\n  ge?: Maybe<Scalars['UUID']>\n  gt?: Maybe<Scalars['UUID']>\n  in?: Maybe<Array<Scalars['UUID']>>\n  contains?: Maybe<Scalars['UUID']>\n  startsWith?: Maybe<Scalars['UUID']>\n  endsWith?: Maybe<Scalars['UUID']>\n}\nexport interface UtcOffsetInput {\n  ne?: Maybe<Scalars['UtcOffset']>\n  eq?: Maybe<Scalars['UtcOffset']>\n  le?: Maybe<Scalars['UtcOffset']>\n  lt?: Maybe<Scalars['UtcOffset']>\n  ge?: Maybe<Scalars['UtcOffset']>\n  gt?: Maybe<Scalars['UtcOffset']>\n  in?: Maybe<Array<Scalars['UtcOffset']>>\n  contains?: Maybe<Scalars['UtcOffset']>\n  startsWith?: Maybe<Scalars['UtcOffset']>\n  endsWith?: Maybe<Scalars['UtcOffset']>\n}\n\ntype GraphbackScalarInput = BigIntInput | ByteInput | CurrencyInput | DIDInput |\nDurationInput | EmailAddressInput | GUIDInput | HSLInput | HSLAInput | HexColorCodeInput |\nHexadecimalInput | IBANInput | IPv4Input | IPv6Input | ISBNInput | ISO8601DurationInput |\nLatitudeInput | LocalDateInput | LocalEndTimeInput | LocalTimeInput | LongitudeInput |\nMACInput | NegativeFloatInput | NegativeIntInput | NonEmptyStringInput | NonNegativeFloatInput |\nNonNegativeIntInput | NonPositiveFloatInput | NonPositiveIntInput | PhoneNumberInput |\nPortInput | PositiveFloatInput | PositiveIntInput | PostalCodeInput | RGBAInput |\nRGBInput | URLInput | USCurrencyInput | UUIDInput | UtcOffsetInput |\nDateInput | DateTimeInput | TimeInput | TimestampInput\n\nexport type QueryFilterOperator = keyof IdInput | keyof BooleanInput | keyof StringInput | keyof FloatInput | keyof IntInput | keyof GraphbackScalarInput\n/**\n * Query filter used in Graphback services and data providers\n */\nexport type QueryFilter<T = any> = {\n  [P in keyof T]: IdInput | BooleanInput | StringInput | FloatInput | IntInput | GraphbackScalarInput | any;\n} & RootQuerySelector<T>\n\ninterface RootQuerySelector<T = any> {\n  and?: Array<QueryFilter<T>>\n  or?: Array<QueryFilter<T>>\n  not?: QueryFilter<T>\n}\n","import { GraphQLNamedType, GraphQLScalarType } from 'graphql'\nimport {\n  BigIntResolver, ByteResolver, CurrencyResolver, DurationResolver,\n  EmailAddressResolver, GUIDResolver, HSLAResolver, HSLResolver,\n  HexColorCodeResolver, HexadecimalResolver, IBANResolver, IPv4Resolver, IPv6Resolver,\n  ISBNResolver, ISO8601DurationResolver, LocalDateResolver, LocalTimeResolver,\n  MACResolver, NegativeFloatResolver, NegativeIntResolver,\n  NonEmptyStringResolver, NonNegativeFloatResolver, NonNegativeIntResolver,\n  PhoneNumberResolver, PortResolver, PositiveFloatResolver, PositiveIntResolver,\n  PostalCodeResolver, RGBAResolver, RGBResolver,\n  URLResolver, USCurrencyResolver, UUIDResolver,\n  UtcOffsetResolver, DIDResolver, LatitudeResolver,\n  JWTResolver, LongitudeResolver, LocalEndTimeResolver,\n  NonPositiveFloatResolver, NonPositiveIntResolver,\n  TimeResolver, TimestampResolver, DateResolver, DateTimeResolver,\n  JSONResolver, JSONObjectResolver\n} from 'graphql-scalars'\n\nexport const BigInt_ = new GraphQLScalarType({\n  ...extractConfig(BigIntResolver),\n  name: 'BigInt'\n}); export const Byte = new GraphQLScalarType({\n  ...extractConfig(ByteResolver),\n  name: 'Byte'\n}); export const Currency = new GraphQLScalarType({\n  ...extractConfig(CurrencyResolver),\n  name: 'Currency'\n}); export const Duration = new GraphQLScalarType({\n  ...extractConfig(DurationResolver),\n  name: 'Duration'\n}); export const EmailAddress = new GraphQLScalarType({\n  ...extractConfig(EmailAddressResolver),\n  name: 'Email'\n}); export const GUID = new GraphQLScalarType({\n  ...extractConfig(GUIDResolver),\n  name: 'GUID'\n}); export const HSLA = new GraphQLScalarType({\n  ...extractConfig(HSLAResolver),\n  name: 'HSLA'\n}); export const HSL = new GraphQLScalarType({\n  ...extractConfig(HSLResolver),\n  name: 'HSL'\n}); export const HexColorCode = new GraphQLScalarType({\n  ...extractConfig(HexColorCodeResolver),\n  name: 'HexColorCode'\n}); export const Hexadecimal = new GraphQLScalarType({\n  ...extractConfig(HexadecimalResolver),\n  name: 'Hexadecimal'\n}); export const IBAN = new GraphQLScalarType({\n  ...extractConfig(IBANResolver),\n  name: 'IBAN'\n}); export const IPv4 = new GraphQLScalarType({\n  ...extractConfig(IPv4Resolver),\n  name: 'IPv4'\n}); export const IPv6 = new GraphQLScalarType({\n  ...extractConfig(IPv6Resolver),\n  name: 'IPv6'\n}); export const ISBN = new GraphQLScalarType({\n  ...extractConfig(ISBNResolver),\n  name: 'ISBN'\n}); export const ISO8601Duration = new GraphQLScalarType({\n  ...extractConfig(ISO8601DurationResolver),\n  name: 'ISO8601Duration'\n}); export const LocalDate = new GraphQLScalarType({\n  ...extractConfig(LocalDateResolver),\n  name: 'LocalDate'\n}); export const LocalTime = new GraphQLScalarType({\n  ...extractConfig(LocalTimeResolver),\n  name: 'LocalTime'\n}); export const MAC = new GraphQLScalarType({\n  ...extractConfig(MACResolver),\n  name: 'MAC'\n}); export const NegativeFloat = new GraphQLScalarType({\n  ...extractConfig(NegativeFloatResolver),\n  name: 'NegativeFloat'\n}); export const NegativeInt = new GraphQLScalarType({\n  ...extractConfig(NegativeIntResolver),\n  name: 'NegativeInt'\n}); export const NonEmptyString = new GraphQLScalarType({\n  ...extractConfig(NonEmptyStringResolver),\n  name: 'NonEmptyString'\n}); export const NonNegativeFloat = new GraphQLScalarType({\n  ...extractConfig(NonNegativeFloatResolver),\n  name: 'NonNegativeFloat'\n}); export const NonNegativeInt = new GraphQLScalarType({\n  ...extractConfig(NonNegativeIntResolver),\n  name: 'NonNegativeInt'\n}); export const PhoneNumber = new GraphQLScalarType({\n  ...extractConfig(PhoneNumberResolver),\n  name: 'PhoneNumber'\n}); export const Port = new GraphQLScalarType({\n  ...extractConfig(PortResolver),\n  name: 'Port'\n}); export const PositiveFloat = new GraphQLScalarType({\n  ...extractConfig(PositiveFloatResolver),\n  name: 'PositiveFloat'\n}); export const PositiveInt = new GraphQLScalarType({\n  ...extractConfig(PositiveIntResolver),\n  name: 'PositiveInt'\n}); export const PostalCode = new GraphQLScalarType({\n  ...extractConfig(PostalCodeResolver),\n  name: 'PostalCode'\n}); export const RGBA = new GraphQLScalarType({\n  ...extractConfig(RGBAResolver),\n  name: 'RGBA'\n}); export const RGB = new GraphQLScalarType({\n  ...extractConfig(RGBResolver),\n  name: 'RGB'\n}); export const URL = new GraphQLScalarType({\n  ...extractConfig(URLResolver),\n  name: 'URL'\n}); export const USCurrency = new GraphQLScalarType({\n  ...extractConfig(USCurrencyResolver),\n  name: 'USCurrency'\n}); export const UUID = new GraphQLScalarType({\n  ...extractConfig(UUIDResolver),\n  name: 'UUID'\n}); export const UtcOffset = new GraphQLScalarType({\n  ...extractConfig(UtcOffsetResolver),\n  name: 'UtcOffset'\n}); export const DID = new GraphQLScalarType({\n  ...extractConfig(DIDResolver),\n  name: 'DID'\n}); export const Latitude = new GraphQLScalarType({\n  ...extractConfig(LatitudeResolver),\n  name: 'Latitude'\n}); export const Longitude = new GraphQLScalarType({\n  ...extractConfig(LongitudeResolver),\n  name: 'Longitude'\n}); export const JWT = new GraphQLScalarType({\n  ...extractConfig(JWTResolver),\n  name: 'JWT'\n}); export const LocalEndTime = new GraphQLScalarType({\n  ...extractConfig(LocalEndTimeResolver),\n  name: 'LocalEndTime'\n}); export const NonPositiveFloat = new GraphQLScalarType({\n  ...extractConfig(NonPositiveFloatResolver),\n  name: 'NonPositiveFloat'\n}); export const NonPositiveInt = new GraphQLScalarType({\n  ...extractConfig(NonPositiveIntResolver),\n  name: 'NonPositiveInt'\n})\n\nexport const Time = new GraphQLScalarType({\n  ...extractConfig(TimeResolver),\n  name: 'Time'\n})\n\nexport const Timestamp = new GraphQLScalarType({\n  ...extractConfig(TimestampResolver),\n  name: 'Timestamp'\n})\n\nexport const Date_ = new GraphQLScalarType({\n  ...extractConfig(DateResolver),\n  name: 'Date'\n})\n\nexport const DateTime = new GraphQLScalarType({\n  ...extractConfig(DateTimeResolver),\n  name: 'DateTime'\n})\n\nexport const JSON_ = new GraphQLScalarType({\n  ...extractConfig(JSONResolver),\n  name: 'JSON'\n})\n\nexport const JSONObject = new GraphQLScalarType({\n  ...extractConfig(JSONObjectResolver),\n  name: 'JSONObject'\n})\n\nexport const graphbackScalarsTypes = [BigInt_, Byte, Currency, DID, Duration, EmailAddress,\n  GUID, HSL, HSLA, HexColorCode, Hexadecimal, IBAN, IPv4, IPv6, ISBN, ISO8601Duration,\n  JWT, Latitude, LocalDate, LocalEndTime, LocalTime, Longitude, MAC, NegativeFloat,\n  NegativeInt, NonEmptyString, NonNegativeFloat, NonNegativeInt, NonPositiveFloat,\n  NonPositiveInt, PhoneNumber, Port, PositiveFloat, PositiveInt, PostalCode,\n  RGB, RGBA, URL, USCurrency, UUID, UtcOffset,\n  Time, Date_, JSON_, DateTime, Timestamp, JSONObject]\n\n/**\n * Checks if the type is on the default Graphback supported scalars\n *\n * @param type - GraphQL type\n */\nexport function isSpecifiedGraphbackScalarType (type: GraphQLNamedType): boolean {\n  return graphbackScalarsTypes.some(({ name }: GraphQLScalarType) => type.name === name)\n}\n\n/**\n * Checks if the type is on the known JSON Graphback supported scalars\n *\n * @param type - GraphQL type\n */\nexport function isSpecifiedGraphbackJSONScalarType (type: GraphQLNamedType): boolean {\n  const name = type.name\n\n  return name === JSONObject.name || name === JSON_.name\n}\n\n/**\n * Extract config from wrapped scalar type\n * @param scalar\n */\nfunction extractConfig (wrappedScalar: GraphQLScalarType) {\n  const { name, ...config } = wrappedScalar.toConfig()\n\n  return config\n}\n"],"mappings":"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","names":[]}