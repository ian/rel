{"version":3,"sources":["../src/crud/mappingHelpers.ts","../src/crud/GraphbackOperationType.ts","../src/plugin/GraphbackPlugin.ts","../src/plugin/GraphbackPluginEngine.ts","../src/plugin/GraphbackCoreMetadata.ts","../src/plugin/ModelDefinition.ts","../src/plugin/getSelectedFieldsFromResolverInfo.ts","../src/db/getPrimaryKey.ts","../src/utils/printSchemaWithDirectives.ts","../src/runtime/CRUDService.ts","../src/utils/convertType.ts","../src/runtime/createInMemoryFilterPredicate.ts","../src/runtime/createCRUDService.ts","../src/runtime/NoDataError.ts","../src/runtime/QueryFilter.ts","../src/scalars/index.ts","../src/utils/directives.ts"],"sourcesContent":["import { GraphQLField, getNamedType, isObjectType, isScalarType, isEnumType } from 'graphql'\nimport pluralize from 'pluralize'\nimport { getPrimaryKey } from '..'\nimport { GraphbackOperationType } from './GraphbackOperationType'\n\n// TODO it is esential to document this element\n\n/**\n * Graphback CRUD Mapping helpers\n */\n\nexport function lowerCaseFirstChar (text: string) {\n  return `${text.charAt(0).toLowerCase()}${text.slice(1)}`\n}\n\nexport function upperCaseFirstChar (text: string) {\n  return `${text.charAt(0).toUpperCase()}${text.slice(1)}`\n}\n\n/**\n * Get name of the field for query and mutation using our crud model.\n * Method trasform specific CRUD operation into compatible name\n *\n * Example:\n * ```\n * type Query {\n *   getUser()\n * }\n * ```\n * This method is compatible with Graphback CRUD specification\n *\n * @param typeName\n * @param action\n */\nexport const getFieldName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n\n  switch (action) {\n    case GraphbackOperationType.FIND_ONE:\n      return `get${finalName}`\n    case GraphbackOperationType.FIND:\n      return `find${pluralize(finalName)}`\n    case GraphbackOperationType.DELETE_BY:\n      return `delete${pluralize(finalName)}`\n    case GraphbackOperationType.UPDATE_BY:\n      return `update${pluralize(finalName)}`\n    default:\n      return `${action}${finalName}`\n  }\n}\n\n/**\n * Returns the input type assocatiated with a CRUD operation\n * @param typeName\n * @param action\n */\nexport const getInputTypeName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n  switch (action) {\n    case GraphbackOperationType.FIND:\n      return `${finalName}Filter`\n    case GraphbackOperationType.CREATE:\n      return `Create${finalName}Input`\n    case GraphbackOperationType.UPDATE:\n    case GraphbackOperationType.DELETE:\n    case GraphbackOperationType.UPDATE_BY:\n    case GraphbackOperationType.DELETE_BY:\n      return `Mutate${finalName}Input`\n    case GraphbackOperationType.SUBSCRIPTION_CREATE:\n    case GraphbackOperationType.SUBSCRIPTION_UPDATE:\n    case GraphbackOperationType.SUBSCRIPTION_DELETE:\n      return `${finalName}SubscriptionFilter`\n    default:\n      return ''\n  }\n}\n\n/**\n * Provides naming patterns for CRUD subscriptions\n */\nexport const getSubscriptionName = (typeName: string, action: GraphbackOperationType): string => {\n  const finalName = upperCaseFirstChar(typeName)\n  if (action === GraphbackOperationType.CREATE) {\n    return `new${finalName}`\n  }\n\n  if (action === GraphbackOperationType.UPDATE) {\n    return `updated${finalName}`\n  }\n\n  if (action === GraphbackOperationType.DELETE) {\n    return `deleted${finalName}`\n  }\n\n  return ''\n}\n\nexport function getInputFieldName (field: GraphQLField<any, any>): string {\n  return field.name\n}\n\nexport function getInputFieldTypeName (modelName: string, field: GraphQLField<any, any>, operation: GraphbackOperationType): string {\n  const fieldType = getNamedType(field.type)\n\n  if (isObjectType(fieldType)) {\n    const idField = getPrimaryKey(fieldType)\n\n    return getNamedType(idField.type).name\n  }\n\n  if (isScalarType(fieldType) || isEnumType(fieldType)) {\n    return fieldType.name\n  }\n\n  if (isObjectType(fieldType)) {\n    // TODO: Filtering on JSON fields\n    if (operation === GraphbackOperationType.FIND) {\n      return undefined\n      // return GraphQLJSON\n    }\n\n    return getInputTypeName(fieldType.name, operation)\n  }\n\n  return undefined\n}\n","\n/**\n * Enum with list of possible resolvers that can be created\n */\n/* eslint-disable no-shadow */\nexport enum GraphbackOperationType {\n  CREATE = 'create',\n  UPDATE = 'update',\n  UPDATE_BY = 'updateBy',\n  FIND = 'find',\n  FIND_ONE = 'findOne',\n  DELETE = 'delete',\n  DELETE_BY = 'deleteBy',\n  SUBSCRIPTION_CREATE = 'subCreate',\n  SUBSCRIPTION_UPDATE = 'subUpdate',\n  SUBSCRIPTION_DELETE = 'subDelete'\n}\n/* eslint-enable no-shadow */\n","import { GraphQLSchema } from 'graphql'\nimport { IResolvers } from '@graphql-tools/utils'\nimport { GraphbackCoreMetadata } from './GraphbackCoreMetadata'\n\n/**\n * Graphback plugin interface\n * Plugins are base for every graphback generator and schema transformers.\n * See documentation for the complete list of the plugins.\n *\n * Plugins can:\n *\n * - Modify the schema\n * - Create resources like files, db tables etc.\n * - Perform some in memory operations based on configuration\n */\nexport abstract class GraphbackPlugin {\n  /**\n   * Performs transformation on the schema and returns target schema\n   * Implementations should extend this method if they wish to apply some changes\n   * to schema. Otherwise unchanged schema should be returned\n   *\n   * @param metadata - metadata object containing schema\n   */\n  public transformSchema (metadata: GraphbackCoreMetadata): GraphQLSchema {\n    return metadata.getSchema()\n  }\n\n  /**\n   * Create resources like files etc. for this plugin.\n   * This method should write resouces to filesystem\n   */\n  public createResources (metadata: GraphbackCoreMetadata): void {\n    return undefined\n  }\n\n  /**\n   * Method to create in-memory resolvers which will be\n   * added to a list of resolvers output by Graphback\n   *\n   * @param metadata - metadata object with model metadata\n   */\n  public createResolvers (metadata: GraphbackCoreMetadata): IResolvers {\n    return undefined\n  }\n\n  protected logWarning (message: string): void {\n    // eslint-disable-next-line no-console\n    console.log(`Warning - ${this.getPluginName()}: ${message}`)\n  }\n\n  protected logError (message: string): void {\n    // eslint-disable-next-line no-console\n    console.error(`Error - ${this.getPluginName()}: ${message}`)\n  }\n\n  /**\n   * @returns Unique name of the plugin\n   */\n  public abstract getPluginName (): string\n};\n","import { buildSchema, GraphQLSchema } from 'graphql'\nimport { GraphbackCoreMetadata } from './GraphbackCoreMetadata'\nimport { GraphbackPlugin } from './GraphbackPlugin'\n\n/**\n * options for the GraphbackPluginEngine\n */\nexport interface GraphBackPluginEngineOptions {\n  schema: GraphQLSchema | string\n  plugins?: GraphbackPlugin[]\n}\n/**\n * Allows to execute chain of plugins that create resources.\n * Common use case is to decorate GraphQL schema with additional\n * actions and generate files like resolvers and database access logic\n *\n * Usage:\n * ```js\n * const engine = GraphbackPluginEngine({ schema });\n * engine.registerPlugin(plugin);\n * printSchema(engine.createResources());\n * ```\n */\nexport class GraphbackPluginEngine {\n  private readonly plugins: GraphbackPlugin[]\n  private readonly metadata: GraphbackCoreMetadata\n\n  public constructor ({ schema, plugins = [] }: GraphBackPluginEngineOptions) {\n    this.plugins = plugins\n    if (!schema) {\n      throw new Error('Plugin engine requires schema')\n    }\n    let graphQLSchema: GraphQLSchema\n    if (typeof schema === 'string') {\n      graphQLSchema = buildSchema(schema)\n    } else {\n      graphQLSchema = schema\n    }\n    this.metadata = new GraphbackCoreMetadata(graphQLSchema)\n  }\n\n  public registerPlugin (...plugins: GraphbackPlugin[]): void {\n    this.plugins.push(...plugins)\n  }\n\n  /**\n   * Allows the transformation of schema by applying transformation logic for each plugin\n   * Creation of resolvers, which has to come after all the changes in schema have been applied\n   * Saving of the transformed schema and related files\n   */\n  public createResources (): GraphbackCoreMetadata {\n    if (this.plugins.length === 0) {\n      console.warn('GraphbackEngine: No Graphback plugins registered')\n    }\n\n    this.createSchema()\n\n    this.createResolvers()\n\n    // Save schema and all files\n    for (const plugin of this.plugins) {\n      plugin.createResources(this.metadata)\n    }\n\n    return this.metadata\n  }\n\n  private createSchema () {\n    // We need to apply all required changes to the schema we need\n    // This is to ensure that every plugin can add changes to the schema\n    for (const plugin of this.plugins) {\n      const newSchema = plugin.transformSchema(this.metadata)\n      this.metadata.setSchema(newSchema)\n    }\n  }\n\n  private createResolvers () {\n    for (const plugin of this.plugins) {\n      const resolvers = plugin.createResolvers(this.metadata)\n      this.metadata.addResolvers(resolvers)\n    }\n  }\n}\n","import { mergeResolvers } from '@graphql-tools/merge'\nimport { GraphQLObjectType, GraphQLSchema, getNamedType } from 'graphql'\nimport { getUserTypesFromSchema, IResolvers } from '@graphql-tools/utils'\nimport { ModelDefinition, ModelFieldMap } from './ModelDefinition'\n\n/**\n * Contains Graphback Core Models\n */\nexport class GraphbackCoreMetadata {\n  private schema: GraphQLSchema\n  private resolvers: IResolvers\n  private models: ModelDefinition[]\n\n  public constructor (schema: GraphQLSchema) {\n    this.schema = schema\n  }\n\n  public getSchema () {\n    return this.schema\n  }\n\n  public setSchema (newSchema: GraphQLSchema) {\n    this.schema = newSchema\n  }\n\n  public addResolvers (resolvers: IResolvers) {\n    if (resolvers) {\n      const mergedResolvers = [\n        this.resolvers,\n        resolvers\n      ]\n      this.resolvers = mergeResolvers(mergedResolvers)\n    }\n  }\n\n  public getResolvers (): IResolvers {\n    return this.resolvers\n  }\n\n  /**\n   * Get Graphback Models - GraphQL Types with additional CRUD configuration\n   */\n  public getModelDefinitions () {\n    // Contains map of the models with their underlying CRUD configuration\n    this.models = []\n    // Get actual user types\n    const modelTypes = this.getGraphQLTypesWithModel()\n\n    for (const modelType of modelTypes) {\n      const model = this.buildModel(modelType)\n      this.models.push(model)\n    }\n\n    return this.models\n  }\n\n  /**\n   * Helper for plugins to fetch all types that should be processed by Graphback plugins.\n   * To mark type as enabled for graphback generators we need to add `model` annotations over the type.\n   *\n   * Returns all user types that have @model in description\n   * @param schema\n   */\n  public getGraphQLTypesWithModel (): GraphQLObjectType[] {\n    return getUserTypesFromSchema(this.schema)\n  }\n\n  private buildModel (modelType: GraphQLObjectType): ModelDefinition {\n    // Merge CRUD options from type with global ones\n    const primaryKey = {\n      name: \"_id\",\n      type: \"ID\"\n    }\n    // parse fields\n    const modelFields = modelType.getFields()\n    const fields: ModelFieldMap = {}\n\n    fields._id = {\n      type: \"ID\"\n    }\n\n    const uniqueFields = []\n    const defaultFields = []\n    const computedFields = []\n\n    for (const field of Object.keys(modelFields)) {\n      let fieldName = field\n      let type: string = ''\n\n      const graphqlField = modelFields[field]\n\n      type = getNamedType(graphqlField.type).name\n\n      if (graphqlField.extensions?.directives?.some?.(d => d.name === \"transient\")) {\n        fields[field] = {\n          name: field,\n          transient: true,\n          type\n        }\n        continue\n      }\n\n      fields[field] = {\n        name: fieldName,\n        type,\n        transient: false\n      }\n\n      if (graphqlField.extensions?.directives?.some?.(d => d.name === \"unique\")) {\n        uniqueFields.push(field)\n      }\n\n      const defaultField = graphqlField.extensions?.directives?.find?.(d => d.name === \"default\")\n      if (defaultField) {\n        let parsedDefaultValue = defaultField.args.value\n        switch (type) {\n          case 'String':\n            break;\n          case 'Boolean':\n            parsedDefaultValue = Boolean(defaultValue);\n            break;\n          case 'Int':\n          case 'Float':\n            parsedDefaultValue = Number(defaultValue);\n            break;\n          default:\n            try {\n              parsedDefaultValue = JSON.parse(defaultValue);\n            } catch {\n              // do nothing, assume the existing value\n            }\n        }\n        defaultFields.push({\n          name: field,\n          default: parsedDefaultValue\n        })\n      }\n\n      const computedField = graphqlField.astNode.directives?.find?.(d => d.name.value === \"computed\")\n      if(computedField) {\n        fields[field].computed = true\n        computedFields.push({\n          name: field,\n          type,\n          template: computedField.arguments?.find(a => a.name.value === \"value\")?.value?.value\n        })\n      }\n    }\n\n    return {\n      fields,\n      primaryKey,\n      relationships: [],\n      uniqueFields,\n      defaultFields,\n      computedFields,\n      graphqlType: modelType\n    }\n  }\n}\n","import { GraphQLObjectType } from 'graphql'\n\n/**\n * Describe the name and type of primary key\n */\nexport interface FieldDescriptor {\n  name: string\n  type: string\n  transient?: boolean | undefined\n  computed?: boolean | undefined\n}\n\nexport interface ModelFieldMap {\n  [key: string]: FieldDescriptor\n}\n\n/**\n * Used to encapsulate configuration for the type\n */\nexport interface ModelDefinition {\n  primaryKey: FieldDescriptor\n  fields: ModelFieldMap\n  graphqlType: GraphQLObjectType\n  relationships: string[]\n  uniqueFields: string[]\n  defaultFields: any[]\n  computedFields: any[] \n}\n\nexport function getModelByName (name: string, models: ModelDefinition[]): ModelDefinition | undefined {\n  if (!models) {\n    return undefined\n  }\n\n  return models.find((m: ModelDefinition) => m.graphqlType.name === name)\n}\n","import { GraphQLResolveInfo } from 'graphql'\nimport graphqlFields from 'graphql-fields'\nimport { ModelDefinition } from './ModelDefinition'\n\n/**\n * Find selectable fields from resolve info for a given model starting on a given path\n * @param info - the resolver info object\n * @param model - the model to find the fields from\n * @param path - the root path to start field resolution from.\n */\nexport const getSelectedFieldsFromResolverInfo = (info: GraphQLResolveInfo, model: ModelDefinition, isMutation = false, path?: string): string[] => {\n  let projectionObj = graphqlFields(info, {}, { processArguments: true })\n  if (path) {\n    projectionObj = projectionObj[path]\n  }\n  const resolverFields = Object.keys(projectionObj)\n  const fieldArgs = {}\n  if (!isMutation) {\n    resolverFields.forEach(k => {\n      if (projectionObj[k].__arguments) {\n        fieldArgs[k] = projectionObj[k].__arguments\n      }\n    })\n  }\n\n  return getModelFieldsFromResolverFields(resolverFields, fieldArgs, model)\n}\n\n/**\n * Get the model specific-fields from a full list of fields\n *\n * @param {string[]} resolverFields - resolver field names\n * @param {ModelDefinition} model - Graphback model\n */\nexport const getModelFieldsFromResolverFields = (resolverFields: string[], fieldArgs: any, model: ModelDefinition): string[] => {\n  const selectedFields = new Set<string>()\n\n  for (const key of resolverFields) {\n    const correspondingFieldInDatabase = model.fields[key]\n    if (correspondingFieldInDatabase && !correspondingFieldInDatabase.transient) {\n      selectedFields.add(correspondingFieldInDatabase.name)\n    }\n  }\n\n  return [[...selectedFields], fieldArgs]\n}\n\n/**\n * Find fields list of resolver info starting at a given path.\n * If path is undefined, return top level fields information.\n * @param info - the resolver info object\n * @param path - the root path to start field resolution from\n */\nexport const getResolverInfoFieldsList = (info: GraphQLResolveInfo, path?: string) => fieldsList(info, { path })\n","import { GraphQLField, GraphQLObjectType, getNamedType, isScalarType, GraphQLInputField } from 'graphql'\n\n/**\n * Returns the primary key field of a GraphQL object.\n * @param graphqlType\n */\nexport function getPrimaryKey (graphqlType: GraphQLObjectType): GraphQLField<any, any> {\n  const fields = Object.values(graphqlType.getFields())\n\n  const autoPrimaryKeyFromScalar: Array<GraphQLField<any, any>> = []\n  for (const field of fields) {\n    if (isAutoPrimaryKey(field)) {\n      autoPrimaryKeyFromScalar.push(field)\n    }\n  }\n\n  if (autoPrimaryKeyFromScalar.length > 1) {\n    throw new Error(`${graphqlType.name} type should not have two potential primary keys.`)\n  }\n\n  const primaryKey = autoPrimaryKeyFromScalar.shift()\n\n  if (!primaryKey) {\n    throw new Error(`${graphqlType.name} type has no primary field.`)\n  }\n\n  return primaryKey\n}\n\n/**\n * Check if a GraphQLField can be inferred as a primary key, specific for each database:\n * A field is a potential primary key if:\n * - is named \"_id\" and has type \"ID\", auto increment primary key for relational database\n * @param field\n */\nexport function isAutoPrimaryKey (field: GraphQLField<any, any> | GraphQLInputField): boolean {\n  const { type, name: fieldName } = field\n  const baseType = getNamedType(type)\n  const name = baseType.name\n\n  return fieldName === '_id' && name === 'ID' && isScalarType(baseType)\n}\n","import { GraphQLSchema } from 'graphql'\nimport { SchemaComposer } from 'graphql-compose'\n\nexport function printSchemaWithDirectives (schemaOrSDL: GraphQLSchema | string): string {\n  const schemaComposer = new SchemaComposer(schemaOrSDL)\n\n  return schemaComposer.toSDL({ exclude: ['String', 'ID', 'Boolean', 'Float', 'Int'] })\n}\n","import { PubSubEngine, withFilter } from 'graphql-subscriptions'\nimport { GraphQLResolveInfo } from 'graphql'\nimport { GraphbackOperationType, getSubscriptionName } from '..'\nimport { ModelDefinition } from '../plugin/ModelDefinition'\nimport { getSelectedFieldsFromResolverInfo, getResolverInfoFieldsList } from '../plugin/getSelectedFieldsFromResolverInfo'\nimport { createInMemoryFilterPredicate } from './createInMemoryFilterPredicate'\nimport { FindByArgs } from './interfaces'\nimport { QueryFilter } from './QueryFilter'\nimport { GraphbackCRUDService, GraphbackDataProvider, GraphbackContext, ResultList } from '.'\n\n/**\n * Configurations necessary to create a CRUDService\n */\nexport interface CRUDServiceConfig {\n  /**\n   * PubSub implementation for creating subscriptions\n   */\n  pubSub?: PubSubEngine\n}\n/**\n * Default implementation of the CRUD service offering following capabilities:\n *\n * - Subscriptions: using default publish subscribe method\n * - Logging: using logging abstraction\n */\n// tslint:disable-next-line: no-any\nexport class CRUDService<Type = any> implements GraphbackCRUDService<Type> {\n  protected db: GraphbackDataProvider\n  protected model: ModelDefinition\n  protected pubSub: PubSubEngine\n\n  public constructor (model: ModelDefinition, db: GraphbackDataProvider, config: CRUDServiceConfig) {\n    this.model = model\n    this.db = db\n    this.pubSub = config.pubSub\n  }\n\n  public async initializeUniqueIndex() {\n    return await this.db.initializeUniqueIndex()\n  }\n\n  public async create (data: Type, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n\n    const result = await this.db.create(data, selectedFields)\n\n    if (this.pubSub) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.CREATE, this.model.graphqlType.name)\n      // TODO use subscription name mapping\n      const payload = this.buildEventPayload('new', result)\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        // eslint-disable-next-line no-console\n        console.error(`Publishing of new \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async update (data: Type, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n\n    const result = await this.db.update(data, selectedFields)\n\n    if (this.pubSub) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.UPDATE, this.model.graphqlType.name)\n      // TODO use subscription name mapping\n      const payload = this.buildEventPayload('updated', result)\n\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        console.error(`Publishing of updates of \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async updateBy (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<ResultList<Type>> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.mode, true)\n    const result = await this.db.updateBy(args, selectedFields)\n\n    return {\n      items: result\n    }\n  }\n\n  public async delete (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n    const result = await this.db.delete(data, selectedFields)\n\n    if (this.pubSub) {\n      const topic = this.subscriptionTopicMapping(GraphbackOperationType.DELETE, this.model.graphqlType.name)\n      const payload = this.buildEventPayload('deleted', result)\n\n      this.pubSub.publish(topic, payload).catch((error: Error) => {\n        // eslint-disable-next-line no-console\n        console.error(`Publishing of deletion of \"${this.model.graphqlType.name}\" with id ${result[this.model.primaryKey.name]} failed: ${error.message}`)\n      })\n    }\n\n    return result\n  }\n\n  public async deleteBy (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<ResultList<Type>> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model, true)\n    const result = await this.db.deleteBy(args, selectedFields)\n\n    return {\n      items: result\n    }\n  }\n\n  public async findOne (args: Partial<Type>, context?: GraphbackContext, info?: GraphQLResolveInfo): Promise<Type> {\n    const [selectedFields, _] = getSelectedFieldsFromResolverInfo(info, this.model)\n    return await this.db.findOne(args, selectedFields)\n  }\n\n  public async findBy (args?: FindByArgs, context?: GraphbackContext, info?: GraphQLResolveInfo, path?: string): Promise<ResultList<Type>> {\n    let requestedCount = false\n    const [selectedFields, fieldArgs] = getSelectedFieldsFromResolverInfo(info, this.model, false, path)\n    requestedCount = path === 'items' && getResolverInfoFieldsList(info).some((field: string) => field === 'count')\n    const items: Type[] = await this.db.findBy(args, selectedFields, fieldArgs)\n\n    // set page values for returned object\n    const resultPageInfo = {\n      offset: 0,\n      ...args?.page\n    }\n\n    let count: number\n    if (requestedCount) {\n      count = await this.db.count(args.filter)\n    }\n\n    return {\n      items,\n      count,\n      offset: 0,\n      ...resultPageInfo\n    }\n  }\n\n  public subscribeToCreate (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.CREATE\n    const createSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(createSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  public subscribeToUpdate (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.UPDATE\n    const updateSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(updateSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  public subscribeToDelete (filter?: QueryFilter): AsyncIterator<Type> | undefined {\n    if (!this.pubSub) {\n      throw Error('Missing PubSub implementation in CRUDService')\n    }\n\n    const operationType = GraphbackOperationType.DELETE\n    const deleteSubKey = this.subscriptionTopicMapping(operationType, this.model.graphqlType.name)\n    const subscriptionName = getSubscriptionName(this.model.graphqlType.name, operationType)\n\n    const asyncIterator = this.pubSub.asyncIterator<Type>(deleteSubKey)\n\n    const subscriptionFilter = createInMemoryFilterPredicate<Type>(filter)\n\n    return withFilter(() => asyncIterator, (payload: any) => subscriptionFilter(payload[subscriptionName]))()\n  }\n\n  /**\n   * Provides way to map runtime topics for subscriptions for specific types and object names\n   */\n  protected subscriptionTopicMapping (triggerType: GraphbackOperationType, objectName: string) {\n    return `${triggerType}_${objectName}`.toUpperCase()\n  }\n\n  private buildEventPayload (action: string, result: any) {\n    const payload = {}\n    payload[`${action}${this.model.graphqlType.name}`] = result\n\n    return payload\n  }\n}\n","/**\n * Helper function to convert a value to another type\n *\n * @param {any} value - Value to convert\n * @param {any} toType - convert value to this type\n */\nexport function convertType (value: any, toType: any): string | number | boolean | BigInt {\n  if (!value) {\n    return undefined\n  }\n\n  switch (typeof toType) {\n    case 'string':\n      return String(value)\n    case 'number':\n      return Number(value)\n    case 'bigint':\n      return BigInt(value)\n    case 'boolean':\n      return Boolean(value)\n    case 'object':\n      if (isDateObject(value)) {\n        return new Date(value).getTime()\n      }\n\n      return value\n    default:\n      return String(value)\n  }\n}\n\n/**\n * Check if value is a Date object\n *\n * @param {any} value\n */\nexport const isDateObject = (value: any): boolean => Object.prototype.toString.call(value) === '[object Date]'\n","import { convertType, isDateObject } from '../utils/convertType'\nimport { QueryFilter } from './QueryFilter'\n\ntype PredicateFn = (input: any) => boolean\ntype InputType = number | string | boolean | Date\n\ninterface IPredicate {\n  eq: (filterValue: InputType) => PredicateFn\n  ne: (filterValue: InputType) => PredicateFn\n  gt: (filterValue: InputType) => PredicateFn\n  ge: (filterValue: InputType) => PredicateFn\n  le: (filterValue: InputType) => PredicateFn\n  lt: (filterValue: InputType) => PredicateFn\n  in: (filterValue: InputType[]) => PredicateFn\n  between: (filterValue: InputType[]) => PredicateFn\n  contains: (filterValue: InputType) => PredicateFn\n  startsWith: (filterValue: string) => PredicateFn\n  endsWith: (filterValue: string) => PredicateFn\n}\n\nconst predicateMap: IPredicate = {\n  eq: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue?.toString() === parsedFilterValue?.toString()\n  },\n  ne: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFilterValue?.toString() !== parsedFieldValue?.toString()\n  },\n  gt: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue > parsedFilterValue\n  },\n  ge: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue >= parsedFilterValue\n  },\n  le: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue <= parsedFilterValue\n  },\n  lt: (filterValue: InputType) => (fieldValue: InputType) => {\n    const parsedFieldValue = convertType(fieldValue, filterValue)\n    const parsedFilterValue = convertType(filterValue, parsedFieldValue)\n\n    return parsedFieldValue < parsedFilterValue\n  },\n  in: (filterValue: InputType[]) => (fieldValue: InputType) => {\n    return filterValue.map((f: InputType) => f?.toString()).includes(fieldValue?.toString())\n  },\n  between: ([fromVal, toVal]: InputType[]) => (fieldValue: InputType) => {\n    if (isDateObject(fieldValue)) {\n      const fieldValDate = convertType(fieldValue, fieldValue)\n      const fromValDate = convertType(fromVal, fieldValue)\n      const toValDate = convertType(toVal, fieldValue)\n\n      return fieldValDate >= fromValDate && fieldValDate <= toValDate\n    }\n\n    const parsedFieldValue = Number(fieldValue)\n\n    return parsedFieldValue >= Number(fromVal) && parsedFieldValue <= Number(toVal)\n  },\n  contains: (filterValue: InputType = '') => (fieldValue: InputType = '') => {\n    return fieldValue?.toString().includes(filterValue?.toString())\n  },\n  startsWith: (filterValue: string = '') => (fieldValue: string = '') => {\n    return fieldValue?.toString().startsWith(filterValue?.toString())\n  },\n  endsWith: (filterValue: string = '') => (fieldValue: string = '') => {\n    return fieldValue?.toString().endsWith(filterValue?.toString())\n  }\n}\n\n/**\n * Dynamically creates a subscription filter predicate using the filter object values\n *\n * @param {QueryFilter} filter - subscription filter input object\n */\nexport function createInMemoryFilterPredicate<T = any> (filter: QueryFilter): (input: Partial<T>) => boolean {\n  filter = filter || {}\n  const andFilter = filter.and\n  const orFilter = filter.or\n  const notFilter = filter.not\n\n  const filterFields = Object.keys(filter).filter((key: string) => !['and', 'or', 'not'].includes(key))\n\n  return (payload: Partial<T>): boolean => {\n    let predicateResult = true\n    for (const fieldName of filterFields) {\n      // skip these filter expressions\n      if (['and', 'or', 'not'].includes(fieldName)) {\n        continue\n      }\n\n      const fieldFilter = filter[fieldName]\n\n      for (const [expr, exprVal] of Object.entries(fieldFilter)) {\n        const predicateFn: PredicateFn = predicateMap[expr](exprVal)\n\n        if (!predicateFn(payload[fieldName])) {\n          predicateResult = false\n          break\n        }\n      }\n    }\n\n    if (orFilter != null) {\n      const orPredicateResult = getOrPredicateResult<T>(orFilter, payload)\n      predicateResult = predicateResult && orPredicateResult\n      if (!predicateResult) {\n        return false\n      }\n    }\n    if (andFilter != null) {\n      const andPredicateResult = getAndPredicateResult(andFilter, payload)\n      predicateResult = predicateResult && andPredicateResult\n    }\n    if (notFilter != null) {\n      const notPredicateResult = createInMemoryFilterPredicate<T>(notFilter)(payload)\n      predicateResult = predicateResult && !notPredicateResult\n    }\n\n    return predicateResult\n  }\n}\n\n/**\n * Get the predicate result of an `and` filter expression\n *\n * @param {QueryFilter[]} and - And filter\n * @param {Partial<T>} payload - Subscription payload\n */\nfunction getAndPredicateResult<T> (and: QueryFilter[], payload: Partial<T>): boolean {\n  let andResult = true\n\n  for (const andItem of and) {\n    andResult = createInMemoryFilterPredicate<T>(andItem)(payload)\n\n    if (!andResult) {\n      break\n    }\n  }\n\n  return andResult\n}\n\n/**\n * Get the boolean result of an `or` filter expression\n *\n * @param {QueryFilter[]} or - Or query filter\n * @param {Partial<T>} payload - Subscription payload\n */\nfunction getOrPredicateResult<T> (or: QueryFilter[], payload: Partial<T>): boolean {\n  let orResult = true\n\n  for (const orItem of or) {\n    orResult = createInMemoryFilterPredicate<T>(orItem)(payload)\n\n    if (orResult) {\n      break\n    }\n  }\n\n  return orResult\n}\n","import { PubSubEngine, PubSub } from 'graphql-subscriptions'\nimport { ModelDefinition } from '..'\nimport { CRUDServiceConfig, CRUDService } from './CRUDService'\nimport { GraphbackDataProvider, GraphbackCRUDService, ServiceCreator } from '.'\n\nexport interface CreateCRUDServiceOptions {\n  /**\n   * PubSub implementation for creating subscriptions\n   */\n  pubSub?: PubSubEngine\n}\n\nexport function createCRUDService (config?: CreateCRUDServiceOptions): ServiceCreator {\n  return async (model: ModelDefinition, dataProvider: GraphbackDataProvider): GraphbackCRUDService => {\n    const serviceConfig: CRUDServiceConfig = {\n      pubSub: new PubSub(),\n      ...config,\n    }\n\n    const crudService = new CRUDService(model, dataProvider, serviceConfig)\n\n    await crudService.initializeUniqueIndex()\n\n    return crudService\n  }\n}","/**\n * Error thrown when database query succeded without any data\n * which is not handled by GraphQL specification\n */\nexport class NoDataError extends Error {\n  public constructor (message: string) {\n    super(`No result from database: ${message}`)\n  }\n}\n","/**\n * Filter mapping for scalars that exit\n */\nexport interface Scalars {\n  ID: string\n  String: string\n  Boolean: boolean\n  Int: number\n  Float: number\n  JSON: any\n  JSONObject: { [key: string]: any }\n  BigInt: number\n  Byte: string\n  Currency: string\n  DID: string\n  Duration: string\n  EmailAddress: string\n  GUID: string\n  HSL: string\n  HSLA: string\n  HexColorCode: string\n  Hexadecimal: string\n  IBAN: string\n  IPv4: string\n  IPv6: string\n  ISBN: string\n  ISO8601Duration: string\n  JWT: any\n  Latitude: number\n  LocalDate: string\n  LocalEndTime: string\n  LocalTime: string\n  Longitude: number\n  MAC: string\n  NegativeFloat: number\n  NegativeInt: number\n  NonEmptyString: string\n  NonNegativeFloat: number\n  NonNegativeInt: number\n  NonPositiveFloat: number\n  NonPositiveInt: number\n  PhoneNumber: string\n  Port: number\n  PositiveFloat: number\n  PositiveInt: number\n  PostalCode: string\n  RGB: string\n  RGBA: string\n  URL: string\n  USCurrency: string\n  UUID: string\n  UtcOffset: string\n  Timestamp: number\n  Time: string\n  Date: Date\n  DateTime: Date\n}\n\n// Names of the scalars that support Graphback filter type generation\nexport const FILTER_SUPPORTED_SCALARS = [\n  'ID', 'String', 'Boolean', 'Int', 'Float', 'Timestamp',\n  'Time', 'Date', 'DateTime', 'BigInt', 'Byte', 'Currency', 'DID', 'Duration', 'EmailAddress',\n  'GUID', 'HSL', 'HSLA', 'HexColorCode', 'Hexadecimal', 'IBAN', 'IPv4', 'IPv6', 'ISBN',\n  'ISO8601Duration', 'Latitude', 'LocalDate', 'LocalEndTime', 'LocalTime',\n  'Longitude', 'MAC', 'NegativeFloat', 'NegativeInt', 'NonEmptyString', 'NonNegativeFloat',\n  'NonNegativeInt', 'NonPositiveFloat', 'NonPositiveInt', 'PhoneNumber', 'Port', 'PositiveFloat',\n  'PositiveInt', 'PostalCode', 'RGB', 'RGBA', 'URL', 'USCurrency', 'UUID', 'UtcOffset'\n]\n\nexport type Maybe<T> = T | null\n\nexport interface BooleanInput {\n  ne?: Maybe<Scalars['Boolean']>\n  eq?: Maybe<Scalars['Boolean']>\n}\n\nexport interface FloatInput {\n  ne?: Maybe<Scalars['Float']>\n  eq?: Maybe<Scalars['Float']>\n  le?: Maybe<Scalars['Float']>\n  lt?: Maybe<Scalars['Float']>\n  ge?: Maybe<Scalars['Float']>\n  gt?: Maybe<Scalars['Float']>\n  in?: Maybe<Array<Scalars['Float']>>\n  between?: Maybe<Array<Scalars['Float']>>\n}\n\nexport interface IdInput {\n  ne?: Maybe<Scalars['ID']>\n  eq?: Maybe<Scalars['ID']>\n  le?: Maybe<Scalars['ID']>\n  lt?: Maybe<Scalars['ID']>\n  ge?: Maybe<Scalars['ID']>\n  gt?: Maybe<Scalars['ID']>\n  in?: Maybe<Array<Scalars['ID']>>\n}\n\nexport interface IntInput {\n  ne?: Maybe<Scalars['Int']>\n  eq?: Maybe<Scalars['Int']>\n  le?: Maybe<Scalars['Int']>\n  lt?: Maybe<Scalars['Int']>\n  ge?: Maybe<Scalars['Int']>\n  gt?: Maybe<Scalars['Int']>\n  in?: Maybe<Scalars['Int']>\n  between?: Maybe<Array<Scalars['Int']>>\n}\n\nexport interface StringInput {\n  ne?: Maybe<Scalars['String']>\n  eq?: Maybe<Scalars['String']>\n  le?: Maybe<Scalars['String']>\n  lt?: Maybe<Scalars['String']>\n  ge?: Maybe<Scalars['String']>\n  gt?: Maybe<Scalars['String']>\n  in?: Maybe<Array<Scalars['String']>>\n  contains?: Maybe<Scalars['String']>\n  startsWith?: Maybe<Scalars['String']>\n  endsWith?: Maybe<Scalars['String']>\n}\n\nexport interface DateInput {\n  ne?: Maybe<Scalars['Date']>\n  eq?: Maybe<Scalars['Date']>\n  le?: Maybe<Scalars['Date']>\n  lt?: Maybe<Scalars['Date']>\n  ge?: Maybe<Scalars['Date']>\n  gt?: Maybe<Scalars['Date']>\n  in?: Maybe<Array<Scalars['Date']>>\n  between?: Maybe<Array<Scalars['Date']>>\n}\n\nexport interface DateTimeInput {\n  ne?: Maybe<Scalars['DateTime']>\n  eq?: Maybe<Scalars['DateTime']>\n  le?: Maybe<Scalars['DateTime']>\n  lt?: Maybe<Scalars['DateTime']>\n  ge?: Maybe<Scalars['DateTime']>\n  gt?: Maybe<Scalars['DateTime']>\n  in?: Maybe<Array<Scalars['DateTime']>>\n  between?: Maybe<Array<Scalars['DateTime']>>\n}\n\nexport interface TimeInput {\n  ne?: Maybe<Scalars['Time']>\n  eq?: Maybe<Scalars['Time']>\n  le?: Maybe<Scalars['Time']>\n  lt?: Maybe<Scalars['Time']>\n  ge?: Maybe<Scalars['Time']>\n  gt?: Maybe<Scalars['Time']>\n  in?: Maybe<Array<Scalars['Time']>>\n  between?: Maybe<Array<Scalars['Time']>>\n}\n\nexport interface TimestampInput {\n  ne?: Maybe<Scalars['Timestamp']>\n  eq?: Maybe<Scalars['Timestamp']>\n  le?: Maybe<Scalars['Timestamp']>\n  lt?: Maybe<Scalars['Timestamp']>\n  ge?: Maybe<Scalars['Timestamp']>\n  gt?: Maybe<Scalars['Timestamp']>\n  in?: Maybe<Array<Scalars['Timestamp']>>\n  between?: Maybe<Array<Scalars['Timestamp']>>\n}\n\nexport interface BigIntInput {\n  ne?: Maybe<Scalars['BigInt']>\n  eq?: Maybe<Scalars['BigInt']>\n  le?: Maybe<Scalars['BigInt']>\n  lt?: Maybe<Scalars['BigInt']>\n  ge?: Maybe<Scalars['BigInt']>\n  gt?: Maybe<Scalars['BigInt']>\n  in?: Maybe<Scalars['BigInt']>\n  between?: Maybe<Array<Scalars['BigInt']>>\n}\nexport interface ByteInput {\n  ne?: Maybe<Scalars['Byte']>\n  eq?: Maybe<Scalars['Byte']>\n  le?: Maybe<Scalars['Byte']>\n  lt?: Maybe<Scalars['Byte']>\n  ge?: Maybe<Scalars['Byte']>\n  gt?: Maybe<Scalars['Byte']>\n  in?: Maybe<Array<Scalars['Byte']>>\n  contains?: Maybe<Scalars['Byte']>\n  startsWith?: Maybe<Scalars['Byte']>\n  endsWith?: Maybe<Scalars['Byte']>\n}\nexport interface CurrencyInput {\n  ne?: Maybe<Scalars['Currency']>\n  eq?: Maybe<Scalars['Currency']>\n  le?: Maybe<Scalars['Currency']>\n  lt?: Maybe<Scalars['Currency']>\n  ge?: Maybe<Scalars['Currency']>\n  gt?: Maybe<Scalars['Currency']>\n  in?: Maybe<Array<Scalars['Currency']>>\n  contains?: Maybe<Scalars['Currency']>\n  startsWith?: Maybe<Scalars['Currency']>\n  endsWith?: Maybe<Scalars['Currency']>\n}\nexport interface DIDInput {\n  ne?: Maybe<Scalars['DID']>\n  eq?: Maybe<Scalars['DID']>\n  le?: Maybe<Scalars['DID']>\n  lt?: Maybe<Scalars['DID']>\n  ge?: Maybe<Scalars['DID']>\n  gt?: Maybe<Scalars['DID']>\n  in?: Maybe<Array<Scalars['DID']>>\n  contains?: Maybe<Scalars['DID']>\n  startsWith?: Maybe<Scalars['DID']>\n  endsWith?: Maybe<Scalars['DID']>\n}\nexport interface DurationInput {\n  ne?: Maybe<Scalars['Duration']>\n  eq?: Maybe<Scalars['Duration']>\n  le?: Maybe<Scalars['Duration']>\n  lt?: Maybe<Scalars['Duration']>\n  ge?: Maybe<Scalars['Duration']>\n  gt?: Maybe<Scalars['Duration']>\n  in?: Maybe<Array<Scalars['Duration']>>\n  contains?: Maybe<Scalars['Duration']>\n  startsWith?: Maybe<Scalars['Duration']>\n  endsWith?: Maybe<Scalars['Duration']>\n}\nexport interface EmailAddressInput {\n  ne?: Maybe<Scalars['EmailAddress']>\n  eq?: Maybe<Scalars['EmailAddress']>\n  le?: Maybe<Scalars['EmailAddress']>\n  lt?: Maybe<Scalars['EmailAddress']>\n  ge?: Maybe<Scalars['EmailAddress']>\n  gt?: Maybe<Scalars['EmailAddress']>\n  in?: Maybe<Array<Scalars['EmailAddress']>>\n  contains?: Maybe<Scalars['EmailAddress']>\n  startsWith?: Maybe<Scalars['EmailAddress']>\n  endsWith?: Maybe<Scalars['EmailAddress']>\n}\nexport interface GUIDInput {\n  ne?: Maybe<Scalars['GUID']>\n  eq?: Maybe<Scalars['GUID']>\n  le?: Maybe<Scalars['GUID']>\n  lt?: Maybe<Scalars['GUID']>\n  ge?: Maybe<Scalars['GUID']>\n  gt?: Maybe<Scalars['GUID']>\n  in?: Maybe<Array<Scalars['GUID']>>\n  contains?: Maybe<Scalars['GUID']>\n  startsWith?: Maybe<Scalars['GUID']>\n  endsWith?: Maybe<Scalars['GUID']>\n}\nexport interface HSLInput {\n  ne?: Maybe<Scalars['HSL']>\n  eq?: Maybe<Scalars['HSL']>\n  le?: Maybe<Scalars['HSL']>\n  lt?: Maybe<Scalars['HSL']>\n  ge?: Maybe<Scalars['HSL']>\n  gt?: Maybe<Scalars['HSL']>\n  in?: Maybe<Array<Scalars['HSL']>>\n  contains?: Maybe<Scalars['HSL']>\n  startsWith?: Maybe<Scalars['HSL']>\n  endsWith?: Maybe<Scalars['HSL']>\n}\nexport interface HSLAInput {\n  ne?: Maybe<Scalars['HSLA']>\n  eq?: Maybe<Scalars['HSLA']>\n  le?: Maybe<Scalars['HSLA']>\n  lt?: Maybe<Scalars['HSLA']>\n  ge?: Maybe<Scalars['HSLA']>\n  gt?: Maybe<Scalars['HSLA']>\n  in?: Maybe<Array<Scalars['HSLA']>>\n  contains?: Maybe<Scalars['HSLA']>\n  startsWith?: Maybe<Scalars['HSLA']>\n  endsWith?: Maybe<Scalars['HSLA']>\n}\nexport interface HexColorCodeInput {\n  ne?: Maybe<Scalars['HexColorCode']>\n  eq?: Maybe<Scalars['HexColorCode']>\n  le?: Maybe<Scalars['HexColorCode']>\n  lt?: Maybe<Scalars['HexColorCode']>\n  ge?: Maybe<Scalars['HexColorCode']>\n  gt?: Maybe<Scalars['HexColorCode']>\n  in?: Maybe<Array<Scalars['HexColorCode']>>\n  contains?: Maybe<Scalars['HexColorCode']>\n  startsWith?: Maybe<Scalars['HexColorCode']>\n  endsWith?: Maybe<Scalars['HexColorCode']>\n}\nexport interface HexadecimalInput {\n  ne?: Maybe<Scalars['Hexadecimal']>\n  eq?: Maybe<Scalars['Hexadecimal']>\n  le?: Maybe<Scalars['Hexadecimal']>\n  lt?: Maybe<Scalars['Hexadecimal']>\n  ge?: Maybe<Scalars['Hexadecimal']>\n  gt?: Maybe<Scalars['Hexadecimal']>\n  in?: Maybe<Array<Scalars['Hexadecimal']>>\n  contains?: Maybe<Scalars['Hexadecimal']>\n  startsWith?: Maybe<Scalars['Hexadecimal']>\n  endsWith?: Maybe<Scalars['Hexadecimal']>\n}\nexport interface IBANInput {\n  ne?: Maybe<Scalars['IBAN']>\n  eq?: Maybe<Scalars['IBAN']>\n  le?: Maybe<Scalars['IBAN']>\n  lt?: Maybe<Scalars['IBAN']>\n  ge?: Maybe<Scalars['IBAN']>\n  gt?: Maybe<Scalars['IBAN']>\n  in?: Maybe<Array<Scalars['IBAN']>>\n  contains?: Maybe<Scalars['IBAN']>\n  startsWith?: Maybe<Scalars['IBAN']>\n  endsWith?: Maybe<Scalars['IBAN']>\n}\nexport interface IPv4Input {\n  ne?: Maybe<Scalars['IPv4']>\n  eq?: Maybe<Scalars['IPv4']>\n  le?: Maybe<Scalars['IPv4']>\n  lt?: Maybe<Scalars['IPv4']>\n  ge?: Maybe<Scalars['IPv4']>\n  gt?: Maybe<Scalars['IPv4']>\n  in?: Maybe<Array<Scalars['IPv4']>>\n  contains?: Maybe<Scalars['IPv4']>\n  startsWith?: Maybe<Scalars['IPv4']>\n  endsWith?: Maybe<Scalars['IPv4']>\n}\nexport interface IPv6Input {\n  ne?: Maybe<Scalars['IPv6']>\n  eq?: Maybe<Scalars['IPv6']>\n  le?: Maybe<Scalars['IPv6']>\n  lt?: Maybe<Scalars['IPv6']>\n  ge?: Maybe<Scalars['IPv6']>\n  gt?: Maybe<Scalars['IPv6']>\n  in?: Maybe<Array<Scalars['IPv6']>>\n  contains?: Maybe<Scalars['IPv6']>\n  startsWith?: Maybe<Scalars['IPv6']>\n  endsWith?: Maybe<Scalars['IPv6']>\n}\nexport interface ISBNInput {\n  ne?: Maybe<Scalars['ISBN']>\n  eq?: Maybe<Scalars['ISBN']>\n  le?: Maybe<Scalars['ISBN']>\n  lt?: Maybe<Scalars['ISBN']>\n  ge?: Maybe<Scalars['ISBN']>\n  gt?: Maybe<Scalars['ISBN']>\n  in?: Maybe<Array<Scalars['ISBN']>>\n  contains?: Maybe<Scalars['ISBN']>\n  startsWith?: Maybe<Scalars['ISBN']>\n  endsWith?: Maybe<Scalars['ISBN']>\n}\nexport interface ISO8601DurationInput {\n  ne?: Maybe<Scalars['ISO8601Duration']>\n  eq?: Maybe<Scalars['ISO8601Duration']>\n  le?: Maybe<Scalars['ISO8601Duration']>\n  lt?: Maybe<Scalars['ISO8601Duration']>\n  ge?: Maybe<Scalars['ISO8601Duration']>\n  gt?: Maybe<Scalars['ISO8601Duration']>\n  in?: Maybe<Array<Scalars['ISO8601Duration']>>\n  contains?: Maybe<Scalars['ISO8601Duration']>\n  startsWith?: Maybe<Scalars['ISO8601Duration']>\n  endsWith?: Maybe<Scalars['ISO8601Duration']>\n}\nexport interface LatitudeInput {\n  ne?: Maybe<Scalars['Latitude']>\n  eq?: Maybe<Scalars['Latitude']>\n  le?: Maybe<Scalars['Latitude']>\n  lt?: Maybe<Scalars['Latitude']>\n  ge?: Maybe<Scalars['Latitude']>\n  gt?: Maybe<Scalars['Latitude']>\n  in?: Maybe<Scalars['Latitude']>\n  between?: Maybe<Array<Scalars['Latitude']>>\n}\nexport interface LocalDateInput {\n  ne?: Maybe<Scalars['LocalDate']>\n  eq?: Maybe<Scalars['LocalDate']>\n  le?: Maybe<Scalars['LocalDate']>\n  lt?: Maybe<Scalars['LocalDate']>\n  ge?: Maybe<Scalars['LocalDate']>\n  gt?: Maybe<Scalars['LocalDate']>\n  in?: Maybe<Array<Scalars['LocalDate']>>\n  between?: Maybe<Array<Scalars['LocalDate']>>\n}\nexport interface LocalEndTimeInput {\n  ne?: Maybe<Scalars['LocalEndTime']>\n  eq?: Maybe<Scalars['LocalEndTime']>\n  le?: Maybe<Scalars['LocalEndTime']>\n  lt?: Maybe<Scalars['LocalEndTime']>\n  ge?: Maybe<Scalars['LocalEndTime']>\n  gt?: Maybe<Scalars['LocalEndTime']>\n  in?: Maybe<Array<Scalars['LocalEndTime']>>\n  contains?: Maybe<Scalars['LocalEndTime']>\n  startsWith?: Maybe<Scalars['LocalEndTime']>\n  endsWith?: Maybe<Scalars['LocalEndTime']>\n}\nexport interface LocalTimeInput {\n  ne?: Maybe<Scalars['LocalTime']>\n  eq?: Maybe<Scalars['LocalTime']>\n  le?: Maybe<Scalars['LocalTime']>\n  lt?: Maybe<Scalars['LocalTime']>\n  ge?: Maybe<Scalars['LocalTime']>\n  gt?: Maybe<Scalars['LocalTime']>\n  in?: Maybe<Array<Scalars['LocalTime']>>\n  between?: Maybe<Array<Scalars['LocalTime']>>\n}\nexport interface LongitudeInput {\n  ne?: Maybe<Scalars['Longitude']>\n  eq?: Maybe<Scalars['Longitude']>\n  le?: Maybe<Scalars['Longitude']>\n  lt?: Maybe<Scalars['Longitude']>\n  ge?: Maybe<Scalars['Longitude']>\n  gt?: Maybe<Scalars['Longitude']>\n  in?: Maybe<Scalars['Longitude']>\n  between?: Maybe<Array<Scalars['Longitude']>>\n}\nexport interface MACInput {\n  ne?: Maybe<Scalars['MAC']>\n  eq?: Maybe<Scalars['MAC']>\n  le?: Maybe<Scalars['MAC']>\n  lt?: Maybe<Scalars['MAC']>\n  ge?: Maybe<Scalars['MAC']>\n  gt?: Maybe<Scalars['MAC']>\n  in?: Maybe<Array<Scalars['MAC']>>\n  contains?: Maybe<Scalars['MAC']>\n  startsWith?: Maybe<Scalars['MAC']>\n  endsWith?: Maybe<Scalars['MAC']>\n}\nexport interface NegativeFloatInput {\n  ne?: Maybe<Scalars['NegativeFloat']>\n  eq?: Maybe<Scalars['NegativeFloat']>\n  le?: Maybe<Scalars['NegativeFloat']>\n  lt?: Maybe<Scalars['NegativeFloat']>\n  ge?: Maybe<Scalars['NegativeFloat']>\n  gt?: Maybe<Scalars['NegativeFloat']>\n  in?: Maybe<Array<Scalars['NegativeFloat']>>\n  between?: Maybe<Array<Scalars['NegativeFloat']>>\n}\nexport interface NegativeIntInput {\n  ne?: Maybe<Scalars['NegativeInt']>\n  eq?: Maybe<Scalars['NegativeInt']>\n  le?: Maybe<Scalars['NegativeInt']>\n  lt?: Maybe<Scalars['NegativeInt']>\n  ge?: Maybe<Scalars['NegativeInt']>\n  gt?: Maybe<Scalars['NegativeInt']>\n  in?: Maybe<Scalars['NegativeInt']>\n  between?: Maybe<Array<Scalars['NegativeInt']>>\n}\nexport interface NonEmptyStringInput {\n  ne?: Maybe<Scalars['NonEmptyString']>\n  eq?: Maybe<Scalars['NonEmptyString']>\n  le?: Maybe<Scalars['NonEmptyString']>\n  lt?: Maybe<Scalars['NonEmptyString']>\n  ge?: Maybe<Scalars['NonEmptyString']>\n  gt?: Maybe<Scalars['NonEmptyString']>\n  in?: Maybe<Array<Scalars['NonEmptyString']>>\n  contains?: Maybe<Scalars['NonEmptyString']>\n  startsWith?: Maybe<Scalars['NonEmptyString']>\n  endsWith?: Maybe<Scalars['NonEmptyString']>\n}\nexport interface NonNegativeFloatInput {\n  ne?: Maybe<Scalars['NonNegativeFloat']>\n  eq?: Maybe<Scalars['NonNegativeFloat']>\n  le?: Maybe<Scalars['NonNegativeFloat']>\n  lt?: Maybe<Scalars['NonNegativeFloat']>\n  ge?: Maybe<Scalars['NonNegativeFloat']>\n  gt?: Maybe<Scalars['NonNegativeFloat']>\n  in?: Maybe<Array<Scalars['NonNegativeFloat']>>\n  between?: Maybe<Array<Scalars['NonNegativeFloat']>>\n}\nexport interface NonNegativeIntInput {\n  ne?: Maybe<Scalars['NonNegativeInt']>\n  eq?: Maybe<Scalars['NonNegativeInt']>\n  le?: Maybe<Scalars['NonNegativeInt']>\n  lt?: Maybe<Scalars['NonNegativeInt']>\n  ge?: Maybe<Scalars['NonNegativeInt']>\n  gt?: Maybe<Scalars['NonNegativeInt']>\n  in?: Maybe<Scalars['NonNegativeInt']>\n  between?: Maybe<Array<Scalars['NonNegativeInt']>>\n}\nexport interface NonPositiveFloatInput {\n  ne?: Maybe<Scalars['NonPositiveFloat']>\n  eq?: Maybe<Scalars['NonPositiveFloat']>\n  le?: Maybe<Scalars['NonPositiveFloat']>\n  lt?: Maybe<Scalars['NonPositiveFloat']>\n  ge?: Maybe<Scalars['NonPositiveFloat']>\n  gt?: Maybe<Scalars['NonPositiveFloat']>\n  in?: Maybe<Array<Scalars['NonPositiveFloat']>>\n  between?: Maybe<Array<Scalars['NonPositiveFloat']>>\n}\nexport interface NonPositiveIntInput {\n  ne?: Maybe<Scalars['NonPositiveInt']>\n  eq?: Maybe<Scalars['NonPositiveInt']>\n  le?: Maybe<Scalars['NonPositiveInt']>\n  lt?: Maybe<Scalars['NonPositiveInt']>\n  ge?: Maybe<Scalars['NonPositiveInt']>\n  gt?: Maybe<Scalars['NonPositiveInt']>\n  in?: Maybe<Scalars['NonPositiveInt']>\n  between?: Maybe<Array<Scalars['NonPositiveInt']>>\n}\nexport interface PhoneNumberInput {\n  ne?: Maybe<Scalars['PhoneNumber']>\n  eq?: Maybe<Scalars['PhoneNumber']>\n  le?: Maybe<Scalars['PhoneNumber']>\n  lt?: Maybe<Scalars['PhoneNumber']>\n  ge?: Maybe<Scalars['PhoneNumber']>\n  gt?: Maybe<Scalars['PhoneNumber']>\n  in?: Maybe<Array<Scalars['PhoneNumber']>>\n  contains?: Maybe<Scalars['PhoneNumber']>\n  startsWith?: Maybe<Scalars['PhoneNumber']>\n  endsWith?: Maybe<Scalars['PhoneNumber']>\n}\nexport interface PortInput {\n  ne?: Maybe<Scalars['Port']>\n  eq?: Maybe<Scalars['Port']>\n  le?: Maybe<Scalars['Port']>\n  lt?: Maybe<Scalars['Port']>\n  ge?: Maybe<Scalars['Port']>\n  gt?: Maybe<Scalars['Port']>\n  in?: Maybe<Scalars['Port']>\n  between?: Maybe<Array<Scalars['Port']>>\n}\nexport interface PositiveFloatInput {\n  ne?: Maybe<Scalars['PositiveFloat']>\n  eq?: Maybe<Scalars['PositiveFloat']>\n  le?: Maybe<Scalars['PositiveFloat']>\n  lt?: Maybe<Scalars['PositiveFloat']>\n  ge?: Maybe<Scalars['PositiveFloat']>\n  gt?: Maybe<Scalars['PositiveFloat']>\n  in?: Maybe<Array<Scalars['PositiveFloat']>>\n  between?: Maybe<Array<Scalars['PositiveFloat']>>\n}\nexport interface PositiveIntInput {\n  ne?: Maybe<Scalars['PositiveInt']>\n  eq?: Maybe<Scalars['PositiveInt']>\n  le?: Maybe<Scalars['PositiveInt']>\n  lt?: Maybe<Scalars['PositiveInt']>\n  ge?: Maybe<Scalars['PositiveInt']>\n  gt?: Maybe<Scalars['PositiveInt']>\n  in?: Maybe<Scalars['PositiveInt']>\n  between?: Maybe<Array<Scalars['PositiveInt']>>\n}\nexport interface PostalCodeInput {\n  ne?: Maybe<Scalars['PostalCode']>\n  eq?: Maybe<Scalars['PostalCode']>\n  le?: Maybe<Scalars['PostalCode']>\n  lt?: Maybe<Scalars['PostalCode']>\n  ge?: Maybe<Scalars['PostalCode']>\n  gt?: Maybe<Scalars['PostalCode']>\n  in?: Maybe<Array<Scalars['PostalCode']>>\n  contains?: Maybe<Scalars['PostalCode']>\n  startsWith?: Maybe<Scalars['PostalCode']>\n  endsWith?: Maybe<Scalars['PostalCode']>\n}\nexport interface RGBInput {\n  ne?: Maybe<Scalars['RGB']>\n  eq?: Maybe<Scalars['RGB']>\n  le?: Maybe<Scalars['RGB']>\n  lt?: Maybe<Scalars['RGB']>\n  ge?: Maybe<Scalars['RGB']>\n  gt?: Maybe<Scalars['RGB']>\n  in?: Maybe<Array<Scalars['RGB']>>\n  contains?: Maybe<Scalars['RGB']>\n  startsWith?: Maybe<Scalars['RGB']>\n  endsWith?: Maybe<Scalars['RGB']>\n}\nexport interface RGBAInput {\n  ne?: Maybe<Scalars['RGBA']>\n  eq?: Maybe<Scalars['RGBA']>\n  le?: Maybe<Scalars['RGBA']>\n  lt?: Maybe<Scalars['RGBA']>\n  ge?: Maybe<Scalars['RGBA']>\n  gt?: Maybe<Scalars['RGBA']>\n  in?: Maybe<Array<Scalars['RGBA']>>\n  contains?: Maybe<Scalars['RGBA']>\n  startsWith?: Maybe<Scalars['RGBA']>\n  endsWith?: Maybe<Scalars['RGBA']>\n}\nexport interface URLInput {\n  ne?: Maybe<Scalars['URL']>\n  eq?: Maybe<Scalars['URL']>\n  le?: Maybe<Scalars['URL']>\n  lt?: Maybe<Scalars['URL']>\n  ge?: Maybe<Scalars['URL']>\n  gt?: Maybe<Scalars['URL']>\n  in?: Maybe<Array<Scalars['URL']>>\n  contains?: Maybe<Scalars['URL']>\n  startsWith?: Maybe<Scalars['URL']>\n  endsWith?: Maybe<Scalars['URL']>\n}\nexport interface USCurrencyInput {\n  ne?: Maybe<Scalars['USCurrency']>\n  eq?: Maybe<Scalars['USCurrency']>\n  le?: Maybe<Scalars['USCurrency']>\n  lt?: Maybe<Scalars['USCurrency']>\n  ge?: Maybe<Scalars['USCurrency']>\n  gt?: Maybe<Scalars['USCurrency']>\n  in?: Maybe<Array<Scalars['USCurrency']>>\n  contains?: Maybe<Scalars['USCurrency']>\n  startsWith?: Maybe<Scalars['USCurrency']>\n  endsWith?: Maybe<Scalars['USCurrency']>\n}\nexport interface UUIDInput {\n  ne?: Maybe<Scalars['UUID']>\n  eq?: Maybe<Scalars['UUID']>\n  le?: Maybe<Scalars['UUID']>\n  lt?: Maybe<Scalars['UUID']>\n  ge?: Maybe<Scalars['UUID']>\n  gt?: Maybe<Scalars['UUID']>\n  in?: Maybe<Array<Scalars['UUID']>>\n  contains?: Maybe<Scalars['UUID']>\n  startsWith?: Maybe<Scalars['UUID']>\n  endsWith?: Maybe<Scalars['UUID']>\n}\nexport interface UtcOffsetInput {\n  ne?: Maybe<Scalars['UtcOffset']>\n  eq?: Maybe<Scalars['UtcOffset']>\n  le?: Maybe<Scalars['UtcOffset']>\n  lt?: Maybe<Scalars['UtcOffset']>\n  ge?: Maybe<Scalars['UtcOffset']>\n  gt?: Maybe<Scalars['UtcOffset']>\n  in?: Maybe<Array<Scalars['UtcOffset']>>\n  contains?: Maybe<Scalars['UtcOffset']>\n  startsWith?: Maybe<Scalars['UtcOffset']>\n  endsWith?: Maybe<Scalars['UtcOffset']>\n}\n\ntype GraphbackScalarInput = BigIntInput | ByteInput | CurrencyInput | DIDInput |\nDurationInput | EmailAddressInput | GUIDInput | HSLInput | HSLAInput | HexColorCodeInput |\nHexadecimalInput | IBANInput | IPv4Input | IPv6Input | ISBNInput | ISO8601DurationInput |\nLatitudeInput | LocalDateInput | LocalEndTimeInput | LocalTimeInput | LongitudeInput |\nMACInput | NegativeFloatInput | NegativeIntInput | NonEmptyStringInput | NonNegativeFloatInput |\nNonNegativeIntInput | NonPositiveFloatInput | NonPositiveIntInput | PhoneNumberInput |\nPortInput | PositiveFloatInput | PositiveIntInput | PostalCodeInput | RGBAInput |\nRGBInput | URLInput | USCurrencyInput | UUIDInput | UtcOffsetInput |\nDateInput | DateTimeInput | TimeInput | TimestampInput\n\nexport type QueryFilterOperator = keyof IdInput | keyof BooleanInput | keyof StringInput | keyof FloatInput | keyof IntInput | keyof GraphbackScalarInput\n/**\n * Query filter used in Graphback services and data providers\n */\nexport type QueryFilter<T = any> = {\n  [P in keyof T]: IdInput | BooleanInput | StringInput | FloatInput | IntInput | GraphbackScalarInput | any;\n} & RootQuerySelector<T>\n\ninterface RootQuerySelector<T = any> {\n  and?: Array<QueryFilter<T>>\n  or?: Array<QueryFilter<T>>\n  not?: QueryFilter<T>\n}\n","import { GraphQLNamedType, GraphQLScalarType } from 'graphql'\nimport {\n  BigIntResolver, ByteResolver, CurrencyResolver, DurationResolver,\n  EmailAddressResolver, GUIDResolver, HSLAResolver, HSLResolver,\n  HexColorCodeResolver, HexadecimalResolver, IBANResolver, IPv4Resolver, IPv6Resolver,\n  ISBNResolver, ISO8601DurationResolver, LocalDateResolver, LocalTimeResolver,\n  MACResolver, NegativeFloatResolver, NegativeIntResolver,\n  NonEmptyStringResolver, NonNegativeFloatResolver, NonNegativeIntResolver,\n  PhoneNumberResolver, PortResolver, PositiveFloatResolver, PositiveIntResolver,\n  PostalCodeResolver, RGBAResolver, RGBResolver,\n  URLResolver, USCurrencyResolver, UUIDResolver,\n  UtcOffsetResolver, DIDResolver, LatitudeResolver,\n  JWTResolver, LongitudeResolver, LocalEndTimeResolver,\n  NonPositiveFloatResolver, NonPositiveIntResolver,\n  TimeResolver, TimestampResolver, DateResolver, DateTimeResolver,\n  JSONResolver, JSONObjectResolver\n} from 'graphql-scalars'\n\nexport const BigInt_ = new GraphQLScalarType({\n  ...extractConfig(BigIntResolver),\n  name: 'BigInt'\n}); export const Byte = new GraphQLScalarType({\n  ...extractConfig(ByteResolver),\n  name: 'Byte'\n}); export const Currency = new GraphQLScalarType({\n  ...extractConfig(CurrencyResolver),\n  name: 'Currency'\n}); export const Duration = new GraphQLScalarType({\n  ...extractConfig(DurationResolver),\n  name: 'Duration'\n}); export const EmailAddress = new GraphQLScalarType({\n  ...extractConfig(EmailAddressResolver),\n  name: 'Email'\n}); export const GUID = new GraphQLScalarType({\n  ...extractConfig(GUIDResolver),\n  name: 'GUID'\n}); export const HSLA = new GraphQLScalarType({\n  ...extractConfig(HSLAResolver),\n  name: 'HSLA'\n}); export const HSL = new GraphQLScalarType({\n  ...extractConfig(HSLResolver),\n  name: 'HSL'\n}); export const HexColorCode = new GraphQLScalarType({\n  ...extractConfig(HexColorCodeResolver),\n  name: 'HexColorCode'\n}); export const Hexadecimal = new GraphQLScalarType({\n  ...extractConfig(HexadecimalResolver),\n  name: 'Hexadecimal'\n}); export const IBAN = new GraphQLScalarType({\n  ...extractConfig(IBANResolver),\n  name: 'IBAN'\n}); export const IPv4 = new GraphQLScalarType({\n  ...extractConfig(IPv4Resolver),\n  name: 'IPv4'\n}); export const IPv6 = new GraphQLScalarType({\n  ...extractConfig(IPv6Resolver),\n  name: 'IPv6'\n}); export const ISBN = new GraphQLScalarType({\n  ...extractConfig(ISBNResolver),\n  name: 'ISBN'\n}); export const ISO8601Duration = new GraphQLScalarType({\n  ...extractConfig(ISO8601DurationResolver),\n  name: 'ISO8601Duration'\n}); export const LocalDate = new GraphQLScalarType({\n  ...extractConfig(LocalDateResolver),\n  name: 'LocalDate'\n}); export const LocalTime = new GraphQLScalarType({\n  ...extractConfig(LocalTimeResolver),\n  name: 'LocalTime'\n}); export const MAC = new GraphQLScalarType({\n  ...extractConfig(MACResolver),\n  name: 'MAC'\n}); export const NegativeFloat = new GraphQLScalarType({\n  ...extractConfig(NegativeFloatResolver),\n  name: 'NegativeFloat'\n}); export const NegativeInt = new GraphQLScalarType({\n  ...extractConfig(NegativeIntResolver),\n  name: 'NegativeInt'\n}); export const NonEmptyString = new GraphQLScalarType({\n  ...extractConfig(NonEmptyStringResolver),\n  name: 'NonEmptyString'\n}); export const NonNegativeFloat = new GraphQLScalarType({\n  ...extractConfig(NonNegativeFloatResolver),\n  name: 'NonNegativeFloat'\n}); export const NonNegativeInt = new GraphQLScalarType({\n  ...extractConfig(NonNegativeIntResolver),\n  name: 'NonNegativeInt'\n}); export const PhoneNumber = new GraphQLScalarType({\n  ...extractConfig(PhoneNumberResolver),\n  name: 'PhoneNumber'\n}); export const Port = new GraphQLScalarType({\n  ...extractConfig(PortResolver),\n  name: 'Port'\n}); export const PositiveFloat = new GraphQLScalarType({\n  ...extractConfig(PositiveFloatResolver),\n  name: 'PositiveFloat'\n}); export const PositiveInt = new GraphQLScalarType({\n  ...extractConfig(PositiveIntResolver),\n  name: 'PositiveInt'\n}); export const PostalCode = new GraphQLScalarType({\n  ...extractConfig(PostalCodeResolver),\n  name: 'PostalCode'\n}); export const RGBA = new GraphQLScalarType({\n  ...extractConfig(RGBAResolver),\n  name: 'RGBA'\n}); export const RGB = new GraphQLScalarType({\n  ...extractConfig(RGBResolver),\n  name: 'RGB'\n}); export const URL = new GraphQLScalarType({\n  ...extractConfig(URLResolver),\n  name: 'URL'\n}); export const USCurrency = new GraphQLScalarType({\n  ...extractConfig(USCurrencyResolver),\n  name: 'USCurrency'\n}); export const UUID = new GraphQLScalarType({\n  ...extractConfig(UUIDResolver),\n  name: 'UUID'\n}); export const UtcOffset = new GraphQLScalarType({\n  ...extractConfig(UtcOffsetResolver),\n  name: 'UtcOffset'\n}); export const DID = new GraphQLScalarType({\n  ...extractConfig(DIDResolver),\n  name: 'DID'\n}); export const Latitude = new GraphQLScalarType({\n  ...extractConfig(LatitudeResolver),\n  name: 'Latitude'\n}); export const Longitude = new GraphQLScalarType({\n  ...extractConfig(LongitudeResolver),\n  name: 'Longitude'\n}); export const JWT = new GraphQLScalarType({\n  ...extractConfig(JWTResolver),\n  name: 'JWT'\n}); export const LocalEndTime = new GraphQLScalarType({\n  ...extractConfig(LocalEndTimeResolver),\n  name: 'LocalEndTime'\n}); export const NonPositiveFloat = new GraphQLScalarType({\n  ...extractConfig(NonPositiveFloatResolver),\n  name: 'NonPositiveFloat'\n}); export const NonPositiveInt = new GraphQLScalarType({\n  ...extractConfig(NonPositiveIntResolver),\n  name: 'NonPositiveInt'\n})\n\nexport const Time = new GraphQLScalarType({\n  ...extractConfig(TimeResolver),\n  name: 'Time'\n})\n\nexport const Timestamp = new GraphQLScalarType({\n  ...extractConfig(TimestampResolver),\n  name: 'Timestamp'\n})\n\nexport const Date_ = new GraphQLScalarType({\n  ...extractConfig(DateResolver),\n  name: 'Date'\n})\n\nexport const DateTime = new GraphQLScalarType({\n  ...extractConfig(DateTimeResolver),\n  name: 'DateTime'\n})\n\nexport const JSON_ = new GraphQLScalarType({\n  ...extractConfig(JSONResolver),\n  name: 'JSON'\n})\n\nexport const JSONObject = new GraphQLScalarType({\n  ...extractConfig(JSONObjectResolver),\n  name: 'JSONObject'\n})\n\nexport const graphbackScalarsTypes = [BigInt_, Byte, Currency, DID, Duration, EmailAddress,\n  GUID, HSL, HSLA, HexColorCode, Hexadecimal, IBAN, IPv4, IPv6, ISBN, ISO8601Duration,\n  JWT, Latitude, LocalDate, LocalEndTime, LocalTime, Longitude, MAC, NegativeFloat,\n  NegativeInt, NonEmptyString, NonNegativeFloat, NonNegativeInt, NonPositiveFloat,\n  NonPositiveInt, PhoneNumber, Port, PositiveFloat, PositiveInt, PostalCode,\n  RGB, RGBA, URL, USCurrency, UUID, UtcOffset,\n  Time, Date_, JSON_, DateTime, Timestamp, JSONObject]\n\n/**\n * Checks if the type is on the default Graphback supported scalars\n *\n * @param type - GraphQL type\n */\nexport function isSpecifiedGraphbackScalarType (type: GraphQLNamedType): boolean {\n  return graphbackScalarsTypes.some(({ name }: GraphQLScalarType) => type.name === name)\n}\n\n/**\n * Checks if the type is on the known JSON Graphback supported scalars\n *\n * @param type - GraphQL type\n */\nexport function isSpecifiedGraphbackJSONScalarType (type: GraphQLNamedType): boolean {\n  const name = type.name\n\n  return name === JSONObject.name || name === JSON_.name\n}\n\n/**\n * Extract config from wrapped scalar type\n * @param scalar\n */\nfunction extractConfig (wrappedScalar: GraphQLScalarType) {\n  const { name, ...config } = wrappedScalar.toConfig()\n\n  return config\n}\n","export const directives = `\n      directive @model on OBJECT\n      directive @unique on FIELD_DEFINITION\n      directive @relation on FIELD_DEFINITION\n      directive @transient on FIELD_DEFINITION\n      directive @default(value: String!) on FIELD_DEFINITION\n      directive @computed(value: String!) on FIELD_DEFINITION\n      directive @constraint(\n            minLength: Int\n            maxLength: Int\n            startsWith: String\n            endsWith: String\n            contains: String\n            notContains: String\n            pattern: String\n            format: String\n            min: Float\n            max: Float\n            exclusiveMin: Float\n            exclusiveMax: Float\n            multipleOf: Float\n        ) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION`"],"mappings":"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","names":[]}