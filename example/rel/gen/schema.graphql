## NOTE: This schema was generated by Rel and should not be changed manually

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

input CreatePostInput {
  body: String!
  ownerId: ID
}

input CreateUserInput {
  name: String!
}

enum EnumPostFields {
  id
  body
}

enum EnumUserFields {
  id
  name
  posts
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID!]
}

input MutatePostInput {
  id: ID!
  body: String
  ownerId: ID
}

input MutateUserInput {
  id: ID!
  name: String
}

type Mutation {
  createPost(input: CreatePostInput!): Post
  updatePost(input: MutatePostInput!): Post
  updatePosts(filter: PostFilter, input: MutatePostInput!): PostMutationResultList
  deletePost(id: ID!): Post
  deletePosts(filter: PostFilter): PostMutationResultList
  createUser(input: CreateUserInput!): User
  updateUser(input: MutateUserInput!): User
  updateUsers(filter: UserFilter, input: MutateUserInput!): UserMutationResultList
  deleteUser(id: ID!): User
  deleteUsers(filter: UserFilter): UserMutationResultList
}

input OfPostInput {
  of: EnumPostFields
}

input OfUserInput {
  of: EnumUserFields
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum = ASC
}

input PageRequest {
  limit: Int
  offset: Int
}

"""@model"""
type Post {
  id: ID!
  body: String!

  """@manyToOne(field: 'posts', key: 'ownerId')"""
  owner: User

  """@transient"""
  count(of: OfPostInput): Int

  """@transient"""
  avg(of: OfPostInput): Int

  """@transient"""
  max(of: OfPostInput): Int

  """@transient"""
  min(of: OfPostInput): Int

  """@transient"""
  sum(of: OfPostInput): Int
}

input PostFilter {
  id: IDInput
  body: StringInput
  ownerId: IDInput
  and: [PostFilter!]
  or: [PostFilter!]
  not: PostFilter
}

type PostMutationResultList {
  items: [Post]!
}

type PostResultList {
  items: [Post]!
  offset: Int
  limit: Int
  count: Int
}

input PostSubscriptionFilter {
  and: [PostSubscriptionFilter!]
  or: [PostSubscriptionFilter!]
  not: PostSubscriptionFilter
  id: IDInput
  body: StringInput
}

type Query {
  getPost(id: ID!): Post
  findPosts(filter: PostFilter, page: PageRequest, orderBy: OrderByInput): PostResultList!
  getUser(id: ID!): User
  findUsers(filter: UserFilter, page: PageRequest, orderBy: OrderByInput): UserResultList!
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newPost(filter: PostSubscriptionFilter): Post!
  updatedPost(filter: PostSubscriptionFilter): Post!
  deletedPost(filter: PostSubscriptionFilter): Post!
  newUser(filter: UserSubscriptionFilter): User!
  updatedUser(filter: UserSubscriptionFilter): User!
  deletedUser(filter: UserSubscriptionFilter): User!
}

"""@model"""
type User {
  id: ID!
  name: String!

  """
  @oneToMany(field: 'owner', key: 'ownerId')
  @oneToMany(field: 'owner')
  """
  posts(filter: PostFilter): [Post]

  """@transient"""
  count(of: OfUserInput): Int

  """@transient"""
  avg(of: OfUserInput): Int

  """@transient"""
  max(of: OfUserInput): Int

  """@transient"""
  min(of: OfUserInput): Int

  """@transient"""
  sum(of: OfUserInput): Int
}

input UserFilter {
  id: IDInput
  name: StringInput
  and: [UserFilter!]
  or: [UserFilter!]
  not: UserFilter
}

type UserMutationResultList {
  items: [User]!
}

type UserResultList {
  items: [User]!
  offset: Int
  limit: Int
  count: Int
}

input UserSubscriptionFilter {
  and: [UserSubscriptionFilter!]
  or: [UserSubscriptionFilter!]
  not: UserSubscriptionFilter
  id: IDInput
  name: StringInput
}